import {
  require_jsx_runtime
} from "./chunk-MTRSJJBN.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-T4PUX6SL.js";

// node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/events@3.3.0/node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/.pnpm/@pipecat-ai+client-react@1.0.1_@pipecat-ai+client-js@1.3.0_@types+react@19.1.13_react-dom@19._gp234ewo3i5ogqtf6mo5pvjjzu/node_modules/@pipecat-ai/client-react/dist/index.module.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@pipecat-ai+client-js@1.3.0/node_modules/@pipecat-ai/client-js/dist/index.module.js
var import_events = __toESM(require_events());

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/constants.js
var BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  "Pale Moon": "pale_moon",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  pale_moon: "Pale Moon",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv",
  bot: "bot"
};
var OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/utils.js
var Utils = class _Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version) {
    switch (version) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version) {
    const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] !== 10) return void 0;
    switch (v[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version) {
    const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] === 1 && v[1] < 5) return void 0;
    if (v[0] === 1 && v[1] < 6) return "Cupcake";
    if (v[0] === 1 && v[1] >= 6) return "Donut";
    if (v[0] === 2 && v[1] < 2) return "Eclair";
    if (v[0] === 2 && v[1] === 2) return "Froyo";
    if (v[0] === 2 && v[1] > 2) return "Gingerbread";
    if (v[0] === 3) return "Honeycomb";
    if (v[0] === 4 && v[1] < 1) return "Ice Cream Sandwich";
    if (v[0] === 4 && v[1] < 4) return "Jelly Bean";
    if (v[0] === 4 && v[1] >= 4) return "KitKat";
    if (v[0] === 5) return "Lollipop";
    if (v[0] === 6) return "Marshmallow";
    if (v[0] === 7) return "Nougat";
    if (v[0] === 8) return "Oreo";
    if (v[0] === 9) return "Pie";
    return void 0;
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version) {
    return version.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = _Utils.getVersionPrecision(versionA);
    const versionBPrecision = _Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = _Utils.map([versionA, versionB], (version) => {
      const delta = precision - _Utils.getVersionPrecision(version);
      const _version = version + new Array(delta + 1).join(".0");
      return _Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i += 1) {
      result.push(iterator(arr[i]));
    }
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i;
    let l;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i = 0, l = arr.length; i < l; i += 1) {
      const value = arr[i];
      if (predicate(value, i)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i;
    let l;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i = 0, l = assigners.length; i < l; i += 1) {
      const assigner = assigners[i];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get browser name for a short version/alias
   *
   * @example
   *   getBrowserTypeByAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
};

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/parser-browsers.js
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      };
      const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/PaleMoon/i],
    describe(ua) {
      const browser = {
        name: "Pale Moon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      };
      const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      };
      const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      };
      const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      };
      const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      };
      const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      };
      const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      };
      const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      };
      const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      };
      const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      };
      const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      };
      const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      };
      const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      };
      const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      };
      const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      };
      const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      };
      const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      };
      const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      };
      const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      };
      const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      };
      const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      };
      const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      };
      const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
var parser_browsers_default = browsersList;

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/parser-os.js
var parser_os_default = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua) {
      const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version);
      return {
        name: OS_MAP.Windows,
        version,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version) {
        result.version = version;
      }
      return result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version);
      const os = {
        name: OS_MAP.MacOS,
        version
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version);
      const os = {
        name: OS_MAP.Android,
        version
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version && version.length) {
        os.version = version;
      }
      return os;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version
      };
    }
  }
];

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/parser-platforms.js
var parser_platforms_default = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: PLATFORMS_MAP.bot,
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Nokia */
  {
    test: [/Nokia/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i, ua);
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nokia"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/parser-engines.js
var parser_engines_default = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  }
];

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/parser.js
var Parser = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(parser_browsers_default, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (Array.isArray(_browser.test)) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(parser_os_default, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (Array.isArray(_os.test)) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    if (toLowerCase) {
      return String(name).toLowerCase() || "";
    }
    return name || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(parser_platforms_default, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (Array.isArray(_platform.test)) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(parser_engines_default, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (Array.isArray(_engine.test)) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name) => this.isPlatform(name)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  /**
   * Check if the browser name equals the passed string
   * @param {string} browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version) {
    let expectedResults = [0];
    let comparableVersion = version;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version[0] === ">" || version[0] === "<") {
      comparableVersion = version.substr(1);
      if (version[1] === "=") {
        isLoose = true;
        comparableVersion = version.substr(2);
      } else {
        expectedResults = [];
      }
      if (version[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version[0] === "=") {
      comparableVersion = version.substr(1);
    } else if (version[0] === "~") {
      isLoose = true;
      comparableVersion = version.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  /**
   * Check if the OS name equals the passed string
   * @param {string} osName The string to compare with the OS name
   * @returns {boolean}
   */
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  /**
   * Check if the platform type equals the passed string
   * @param {string} platformType The string to compare with the platform type
   * @returns {boolean}
   */
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  /**
   * Check if the engine name equals the passed string
   * @param {string} engineName The string to compare with the engine name
   * @returns {boolean}
   */
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
};
var parser_default = Parser;

// node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/src/bowser.js
var Bowser = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new parser_default(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new parser_default(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
};
var bowser_default = Bowser;

// node_modules/.pnpm/@pipecat-ai+client-js@1.3.0/node_modules/@pipecat-ai/client-js/dist/index.module.js
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) {
      return;
    }
    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });
  return dest;
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
var $05fa7b586184a19c$exports = {};
var $364c127d152b1085$exports = {};
$parcel$export($364c127d152b1085$exports, "PipecatClient", () => $364c127d152b1085$export$8f7f86a77535f7a3);
var $e3bad9cc25e327f7$exports = {};
$e3bad9cc25e327f7$exports = JSON.parse('{"name":"@pipecat-ai/client-js","version":"1.3.0","license":"BSD-2-Clause","main":"dist/index.js","module":"dist/index.module.js","types":"dist/index.d.ts","source":"index.ts","repository":{"type":"git","url":"git+https://github.com/pipecat-ai/pipecat-client-web.git"},"files":["dist","package.json","README.md"],"scripts":{"build":"jest --silent --passWithNoTests && parcel build --no-cache","dev":"parcel watch","lint":"eslint . --report-unused-disable-directives --max-warnings 0","test":"jest"},"jest":{"preset":"ts-jest","testEnvironment":"jsdom"},"devDependencies":{"@jest/globals":"^29.7.0","@types/clone-deep":"^4.0.4","@types/jest":"^29.5.12","@types/uuid":"^10.0.0","eslint":"^9.11.1","eslint-config-prettier":"^9.1.0","eslint-plugin-simple-import-sort":"^12.1.1","jest":"^29.7.0","jest-environment-jsdom":"^30.0.2","ts-jest":"^29.2.5"},"dependencies":{"@types/events":"^3.0.3","bowser":"^2.11.0","clone-deep":"^4.0.1","events":"^3.3.0","typed-emitter":"^2.1.0","uuid":"^10.0.0"}}');
var $fc3f408bb0b1f921$exports = {};
var $6396333126da0e76$exports = {};
$parcel$export($6396333126da0e76$exports, "TransportStateEnum", () => $6396333126da0e76$export$8f2038d3679a1d9b);
var $6396333126da0e76$export$8f2038d3679a1d9b;
(function(TransportStateEnum) {
  TransportStateEnum["DISCONNECTED"] = "disconnected";
  TransportStateEnum["INITIALIZING"] = "initializing";
  TransportStateEnum["INITIALIZED"] = "initialized";
  TransportStateEnum["AUTHENTICATING"] = "authenticating";
  TransportStateEnum["AUTHENTICATED"] = "authenticated";
  TransportStateEnum["CONNECTING"] = "connecting";
  TransportStateEnum["CONNECTED"] = "connected";
  TransportStateEnum["READY"] = "ready";
  TransportStateEnum["DISCONNECTING"] = "disconnecting";
  TransportStateEnum["ERROR"] = "error";
})($6396333126da0e76$export$8f2038d3679a1d9b || ($6396333126da0e76$export$8f2038d3679a1d9b = {}));
var $db6391dc7d757577$exports = {};
$parcel$export($db6391dc7d757577$exports, "RTVIError", () => $db6391dc7d757577$export$59b4786f333aac02);
$parcel$export($db6391dc7d757577$exports, "ConnectionTimeoutError", () => $db6391dc7d757577$export$c67992fa684a81a6);
$parcel$export($db6391dc7d757577$exports, "StartBotError", () => $db6391dc7d757577$export$e7544ab812238a61);
$parcel$export($db6391dc7d757577$exports, "TransportStartError", () => $db6391dc7d757577$export$e0624a511a2c4e9);
$parcel$export($db6391dc7d757577$exports, "InvalidTransportParamsError", () => $db6391dc7d757577$export$b6ce555ea7f95fba);
$parcel$export($db6391dc7d757577$exports, "BotNotReadyError", () => $db6391dc7d757577$export$885fb96b850e8fbb);
$parcel$export($db6391dc7d757577$exports, "BotAlreadyStartedError", () => $db6391dc7d757577$export$cc240eab14fa4f50);
$parcel$export($db6391dc7d757577$exports, "UnsupportedFeatureError", () => $db6391dc7d757577$export$bd0820eb8444fcd9);
$parcel$export($db6391dc7d757577$exports, "DeviceError", () => $db6391dc7d757577$export$64c9f614187c1e59);
var $db6391dc7d757577$export$59b4786f333aac02 = class extends Error {
  constructor(message, status) {
    super(message);
    this.status = status;
  }
};
var $db6391dc7d757577$export$c67992fa684a81a6 = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Bot did not enter ready state within the specified timeout period.");
  }
};
var $db6391dc7d757577$export$e7544ab812238a61 = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(message, status) {
    super(message ?? `Failed to connect / invalid auth bundle from base url`, status ?? 500);
    this.error = "invalid-request-error";
  }
};
var $db6391dc7d757577$export$e0624a511a2c4e9 = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Unable to connect to transport");
  }
};
var $db6391dc7d757577$export$b6ce555ea7f95fba = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Invalid transport connection parameters");
  }
};
var $db6391dc7d757577$export$885fb96b850e8fbb = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Attempt to call action on transport when not in 'ready' state.");
  }
};
var $db6391dc7d757577$export$cc240eab14fa4f50 = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Pipecat client has already been started. Please call disconnect() before starting again.");
  }
};
var $db6391dc7d757577$export$bd0820eb8444fcd9 = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(feature, source, message) {
    let msg = `${feature} not supported${message ? `: ${message}` : ""}`;
    if (source) msg = `${source} does not support ${feature}${message ? `: ${message}` : ""}`;
    super(msg);
    this.feature = feature;
  }
};
var $db6391dc7d757577$export$64c9f614187c1e59 = class extends $db6391dc7d757577$export$59b4786f333aac02 {
  constructor(devices, type, message, details) {
    super(message ?? `Device error for ${devices.join(", ")}: ${type}`);
    this.devices = devices;
    this.type = type;
    this.details = details;
  }
};
var $c1b4da4af54f4fa1$exports = {};
$parcel$export($c1b4da4af54f4fa1$exports, "RTVIEvent", () => $c1b4da4af54f4fa1$export$6b4624d233c61fcb);
var $c1b4da4af54f4fa1$export$6b4624d233c61fcb;
(function(RTVIEvent) {
  RTVIEvent["Connected"] = "connected";
  RTVIEvent["Disconnected"] = "disconnected";
  RTVIEvent["TransportStateChanged"] = "transportStateChanged";
  RTVIEvent["BotConnected"] = "botConnected";
  RTVIEvent["BotReady"] = "botReady";
  RTVIEvent["BotDisconnected"] = "botDisconnected";
  RTVIEvent["Error"] = "error";
  RTVIEvent["ServerMessage"] = "serverMessage";
  RTVIEvent["ServerResponse"] = "serverResponse";
  RTVIEvent["MessageError"] = "messageError";
  RTVIEvent["Metrics"] = "metrics";
  RTVIEvent["BotStartedSpeaking"] = "botStartedSpeaking";
  RTVIEvent["BotStoppedSpeaking"] = "botStoppedSpeaking";
  RTVIEvent["UserStartedSpeaking"] = "userStartedSpeaking";
  RTVIEvent["UserStoppedSpeaking"] = "userStoppedSpeaking";
  RTVIEvent["UserTranscript"] = "userTranscript";
  RTVIEvent["BotTranscript"] = "botTranscript";
  RTVIEvent["BotLlmText"] = "botLlmText";
  RTVIEvent["BotLlmStarted"] = "botLlmStarted";
  RTVIEvent["BotLlmStopped"] = "botLlmStopped";
  RTVIEvent["LLMFunctionCall"] = "llmFunctionCall";
  RTVIEvent["BotLlmSearchResponse"] = "botLlmSearchResponse";
  RTVIEvent["BotTtsText"] = "botTtsText";
  RTVIEvent["BotTtsStarted"] = "botTtsStarted";
  RTVIEvent["BotTtsStopped"] = "botTtsStopped";
  RTVIEvent["ParticipantConnected"] = "participantConnected";
  RTVIEvent["ParticipantLeft"] = "participantLeft";
  RTVIEvent["TrackStarted"] = "trackStarted";
  RTVIEvent["TrackStopped"] = "trackStopped";
  RTVIEvent["ScreenTrackStarted"] = "screenTrackStarted";
  RTVIEvent["ScreenTrackStopped"] = "screenTrackStopped";
  RTVIEvent["ScreenShareError"] = "screenShareError";
  RTVIEvent["LocalAudioLevel"] = "localAudioLevel";
  RTVIEvent["RemoteAudioLevel"] = "remoteAudioLevel";
  RTVIEvent["AvailableCamsUpdated"] = "availableCamsUpdated";
  RTVIEvent["AvailableMicsUpdated"] = "availableMicsUpdated";
  RTVIEvent["AvailableSpeakersUpdated"] = "availableSpeakersUpdated";
  RTVIEvent["CamUpdated"] = "camUpdated";
  RTVIEvent["MicUpdated"] = "micUpdated";
  RTVIEvent["SpeakerUpdated"] = "speakerUpdated";
  RTVIEvent["DeviceError"] = "deviceError";
})($c1b4da4af54f4fa1$export$6b4624d233c61fcb || ($c1b4da4af54f4fa1$export$6b4624d233c61fcb = {}));
var $c0d10c4690969999$exports = {};
$parcel$export($c0d10c4690969999$exports, "RTVI_PROTOCOL_VERSION", () => $c0d10c4690969999$export$7bdaf0e0d661a8f5);
$parcel$export($c0d10c4690969999$exports, "RTVI_MESSAGE_LABEL", () => $c0d10c4690969999$export$882b13c7fda338f5);
$parcel$export($c0d10c4690969999$exports, "RTVIMessageType", () => $c0d10c4690969999$export$38b3db05cbf0e240);
$parcel$export($c0d10c4690969999$exports, "setAboutClient", () => $c0d10c4690969999$export$e4036f9b8ddb7379);
$parcel$export($c0d10c4690969999$exports, "RTVIMessage", () => $c0d10c4690969999$export$69aa9ab0334b212);
var $c0d10c4690969999$export$7bdaf0e0d661a8f5 = "1.0.0";
var $c0d10c4690969999$export$882b13c7fda338f5 = "rtvi-ai";
var $c0d10c4690969999$export$38b3db05cbf0e240;
(function(RTVIMessageType) {
  RTVIMessageType["CLIENT_READY"] = "client-ready";
  RTVIMessageType["DISCONNECT_BOT"] = "disconnect-bot";
  RTVIMessageType["CLIENT_MESSAGE"] = "client-message";
  RTVIMessageType["APPEND_TO_CONTEXT"] = "append-to-context";
  RTVIMessageType["BOT_READY"] = "bot-ready";
  RTVIMessageType["ERROR"] = "error";
  RTVIMessageType["METRICS"] = "metrics";
  RTVIMessageType["SERVER_MESSAGE"] = "server-message";
  RTVIMessageType["SERVER_RESPONSE"] = "server-response";
  RTVIMessageType["ERROR_RESPONSE"] = "error-response";
  RTVIMessageType["APPEND_TO_CONTEXT_RESULT"] = "append-to-context-result";
  RTVIMessageType["USER_TRANSCRIPTION"] = "user-transcription";
  RTVIMessageType["BOT_TRANSCRIPTION"] = "bot-transcription";
  RTVIMessageType["USER_STARTED_SPEAKING"] = "user-started-speaking";
  RTVIMessageType["USER_STOPPED_SPEAKING"] = "user-stopped-speaking";
  RTVIMessageType["BOT_STARTED_SPEAKING"] = "bot-started-speaking";
  RTVIMessageType["BOT_STOPPED_SPEAKING"] = "bot-stopped-speaking";
  RTVIMessageType["USER_LLM_TEXT"] = "user-llm-text";
  RTVIMessageType["BOT_LLM_TEXT"] = "bot-llm-text";
  RTVIMessageType["BOT_LLM_STARTED"] = "bot-llm-started";
  RTVIMessageType["BOT_LLM_STOPPED"] = "bot-llm-stopped";
  RTVIMessageType["LLM_FUNCTION_CALL"] = "llm-function-call";
  RTVIMessageType["LLM_FUNCTION_CALL_RESULT"] = "llm-function-call-result";
  RTVIMessageType["BOT_LLM_SEARCH_RESPONSE"] = "bot-llm-search-response";
  RTVIMessageType["BOT_TTS_TEXT"] = "bot-tts-text";
  RTVIMessageType["BOT_TTS_STARTED"] = "bot-tts-started";
  RTVIMessageType["BOT_TTS_STOPPED"] = "bot-tts-stopped";
})($c0d10c4690969999$export$38b3db05cbf0e240 || ($c0d10c4690969999$export$38b3db05cbf0e240 = {}));
var $c0d10c4690969999$var$_aboutClient;
function $c0d10c4690969999$export$e4036f9b8ddb7379(about) {
  if ($c0d10c4690969999$var$_aboutClient) $c0d10c4690969999$var$_aboutClient = {
    ...$c0d10c4690969999$var$_aboutClient,
    ...about
  };
  else
    $c0d10c4690969999$var$_aboutClient = about;
}
var $c0d10c4690969999$export$69aa9ab0334b212 = class _$c0d10c4690969999$export$69aa9ab0334b212 {
  constructor(type, data, id) {
    this.label = $c0d10c4690969999$export$882b13c7fda338f5;
    this.type = type;
    this.data = data;
    this.id = id || (0, v4_default)().slice(0, 8);
  }
  // Outbound message types
  static clientReady() {
    return new _$c0d10c4690969999$export$69aa9ab0334b212($c0d10c4690969999$export$38b3db05cbf0e240.CLIENT_READY, {
      version: $c0d10c4690969999$export$7bdaf0e0d661a8f5,
      about: $c0d10c4690969999$var$_aboutClient || {
        library: (0, $e3bad9cc25e327f7$exports.name),
        library_version: (0, $e3bad9cc25e327f7$exports.version)
      }
    });
  }
  static disconnectBot() {
    return new _$c0d10c4690969999$export$69aa9ab0334b212($c0d10c4690969999$export$38b3db05cbf0e240.DISCONNECT_BOT, {});
  }
  static error(message, fatal = false) {
    return new _$c0d10c4690969999$export$69aa9ab0334b212($c0d10c4690969999$export$38b3db05cbf0e240.ERROR, {
      message,
      fatal
    });
  }
};
$parcel$exportWildcard($fc3f408bb0b1f921$exports, $6396333126da0e76$exports);
$parcel$exportWildcard($fc3f408bb0b1f921$exports, $db6391dc7d757577$exports);
$parcel$exportWildcard($fc3f408bb0b1f921$exports, $c1b4da4af54f4fa1$exports);
$parcel$exportWildcard($fc3f408bb0b1f921$exports, $c0d10c4690969999$exports);
function $c68ef2498d1a7177$export$f1586721024c4dab(_target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function(...args) {
    if (this.state === "ready") return originalMethod.apply(this, args);
    else throw new (0, $db6391dc7d757577$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ready state. Await connect() first.`);
  };
  return descriptor;
}
function $c68ef2498d1a7177$export$ebc0d747cf8770bc(_target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  const states = [
    "authenticating",
    "connecting",
    "connected",
    "ready"
  ];
  descriptor.value = function(...args) {
    if (states.includes(this.state)) throw new (0, $db6391dc7d757577$export$cc240eab14fa4f50)(`Attempt to call ${propertyKey.toString()} when client already started. Please call disconnect() before starting again.`);
    else return originalMethod.apply(this, args);
  };
  return descriptor;
}
var $769bb602511974a1$exports = {};
$parcel$export($769bb602511974a1$exports, "MessageDispatcher", () => $769bb602511974a1$export$e9a960646cc432aa);
var $e0900798b6cc045b$exports = {};
$parcel$export($e0900798b6cc045b$exports, "LogLevel", () => $e0900798b6cc045b$export$243e62d78d3b544d);
$parcel$export($e0900798b6cc045b$exports, "logger", () => $e0900798b6cc045b$export$af88d00dbe7f521);
var $e0900798b6cc045b$export$243e62d78d3b544d;
(function(LogLevel) {
  LogLevel[LogLevel["NONE"] = 0] = "NONE";
  LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
  LogLevel[LogLevel["WARN"] = 2] = "WARN";
  LogLevel[LogLevel["INFO"] = 3] = "INFO";
  LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
})($e0900798b6cc045b$export$243e62d78d3b544d || ($e0900798b6cc045b$export$243e62d78d3b544d = {}));
var $e0900798b6cc045b$var$Logger = class _$e0900798b6cc045b$var$Logger {
  constructor() {
    this.level = $e0900798b6cc045b$export$243e62d78d3b544d.DEBUG;
  }
  static getInstance() {
    if (!_$e0900798b6cc045b$var$Logger.instance) _$e0900798b6cc045b$var$Logger.instance = new _$e0900798b6cc045b$var$Logger();
    return _$e0900798b6cc045b$var$Logger.instance;
  }
  setLevel(level) {
    this.level = level;
  }
  debug(...args) {
    if (this.level >= $e0900798b6cc045b$export$243e62d78d3b544d.DEBUG) console.debug(...args);
  }
  info(...args) {
    if (this.level >= $e0900798b6cc045b$export$243e62d78d3b544d.INFO) console.info(...args);
  }
  warn(...args) {
    if (this.level >= $e0900798b6cc045b$export$243e62d78d3b544d.WARN) console.warn(...args);
  }
  error(...args) {
    if (this.level >= $e0900798b6cc045b$export$243e62d78d3b544d.ERROR) console.error(...args);
  }
};
var $e0900798b6cc045b$export$af88d00dbe7f521 = $e0900798b6cc045b$var$Logger.getInstance();
var $769bb602511974a1$export$e9a960646cc432aa = class {
  constructor(sendMethod) {
    this._queue = new Array();
    this._gcInterval = void 0;
    this._queue = [];
    this._sendMethod = sendMethod;
  }
  disconnect() {
    this.clearQueue();
    clearInterval(this._gcInterval);
    this._gcInterval = void 0;
  }
  dispatch(message_data, type = (0, $c0d10c4690969999$export$38b3db05cbf0e240).CLIENT_MESSAGE, timeout = 1e4) {
    if (!this._gcInterval)
      this._gcInterval = setInterval(() => {
        this._gc();
      }, 2e3);
    const message = new (0, $c0d10c4690969999$export$69aa9ab0334b212)(type, message_data);
    const promise = new Promise((resolve, reject) => {
      this._queue.push({
        message,
        timestamp: Date.now(),
        timeout,
        resolve,
        reject
      });
    });
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[MessageDispatcher] dispatch", message);
    try {
      this._sendMethod(message);
    } catch (e) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).error("[MessageDispatcher] Error sending message", e);
      return Promise.reject(e);
    }
    this._gc();
    return promise;
  }
  clearQueue() {
    this._queue = [];
  }
  _resolveReject(message, resolve = true) {
    const queuedMessage = this._queue.find((msg) => msg.message.id === message.id);
    if (queuedMessage) {
      if (resolve) {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[MessageDispatcher] Resolve", message);
        queuedMessage.resolve(message);
      } else {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[MessageDispatcher] Reject", message);
        queuedMessage.reject(message);
      }
      this._queue = this._queue.filter((msg) => msg.message.id !== message.id);
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[MessageDispatcher] Queue", this._queue);
    }
    return message;
  }
  resolve(message) {
    return this._resolveReject(message, true);
  }
  reject(message) {
    return this._resolveReject(message, false);
  }
  _gc() {
    const expired = [];
    this._queue = this._queue.filter((msg) => {
      const isValid = Date.now() - msg.timestamp < msg.timeout;
      if (!isValid) expired.push(msg);
      return isValid;
    });
    expired.forEach((msg) => {
      if (msg.message.type === (0, $c0d10c4690969999$export$38b3db05cbf0e240).CLIENT_MESSAGE) msg.reject(new (0, $c0d10c4690969999$export$69aa9ab0334b212)((0, $c0d10c4690969999$export$38b3db05cbf0e240).ERROR_RESPONSE, {
        error: "Timed out waiting for response",
        msgType: msg.message.data.t,
        data: msg.message.data.d,
        fatal: false
      }));
    });
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[MessageDispatcher] GC", this._queue);
  }
};
var $d0e914667cc5346b$exports = {};
$parcel$export($d0e914667cc5346b$exports, "isAPIRequest", () => $d0e914667cc5346b$export$2dd7ca293b2783);
$parcel$export($d0e914667cc5346b$exports, "makeRequest", () => $d0e914667cc5346b$export$699251e5611cc6db);
function $d0e914667cc5346b$export$2dd7ca293b2783(value) {
  if (typeof value === "object" && value !== null && Object.keys(value).includes("endpoint")) {
    const endpoint = value["endpoint"];
    return typeof endpoint === "string" || endpoint instanceof URL || typeof Request !== "undefined" && endpoint instanceof Request;
  }
  return false;
}
async function $d0e914667cc5346b$export$699251e5611cc6db(cxnOpts, abortController) {
  if (!abortController) abortController = new AbortController();
  let handshakeTimeout;
  return new Promise((resolve, reject) => {
    (async () => {
      if (cxnOpts.timeout) handshakeTimeout = setTimeout(async () => {
        abortController.abort();
        reject(new Error("Timed out"));
      }, cxnOpts.timeout);
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`[Pipecat Client] Fetching from ${cxnOpts.endpoint}`);
      fetch(cxnOpts.endpoint, {
        method: "POST",
        mode: "cors",
        headers: new Headers({
          "Content-Type": "application/json",
          ...Object.fromEntries((cxnOpts.headers ?? new Headers()).entries())
        }),
        body: JSON.stringify(cxnOpts.requestData),
        signal: abortController == null ? void 0 : abortController.signal
      }).then((res) => {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`[Pipecat Client] Received response from ${cxnOpts.endpoint}`, res);
        if (!res.ok) reject(res);
        res.json().then((data) => resolve(data));
      }).catch((err) => {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).error(`[Pipecat Client] Error fetching: ${err}`);
        reject(err);
      }).finally(() => {
        if (handshakeTimeout) clearTimeout(handshakeTimeout);
      });
    })();
  });
}
var $7ef5cee66c377f4d$exports = {};
$parcel$export($7ef5cee66c377f4d$exports, "Transport", () => $7ef5cee66c377f4d$export$86495b081fef8e52);
$parcel$export($7ef5cee66c377f4d$exports, "TransportWrapper", () => $7ef5cee66c377f4d$export$82b6ede160a64a3c);
var $7ef5cee66c377f4d$export$86495b081fef8e52 = class {
  constructor() {
    this._state = "disconnected";
  }
  /**
   * Establishes a connection with the remote server. This is the main entry
   * point for the transport to start sending and receiving media and messages.
   * This is called from PipecatClient.connect() and should not be called directly.
   * @param connectParams - This type will ultimately be defned by the transport
   * implementation. It is used to pass connection parameters to the transport.
   */
  connect(connectParams) {
    this._abortController = new AbortController();
    let validatedParams = connectParams;
    try {
      validatedParams = this._validateConnectionParams(connectParams);
    } catch (e) {
      throw new (0, $db6391dc7d757577$export$59b4786f333aac02)(`Invalid connection params: ${e.message}. Please check your connection params and try again.`);
    }
    return this._connect(validatedParams);
  }
  /**
   * Disconnects the transport from the remote server. This is called from
   * PipecatClient.disconnect() and should not be called directly.
   */
  disconnect() {
    if (this._abortController) this._abortController.abort();
    return this._disconnect();
  }
};
var $7ef5cee66c377f4d$export$82b6ede160a64a3c = class {
  constructor(transport) {
    this._transport = transport;
    this._proxy = new Proxy(this._transport, {
      get: (target, prop, receiver) => {
        if (typeof target[prop] === "function") {
          let errMsg;
          switch (String(prop)) {
            // Disable methods that modify the lifecycle of the call. These operations
            // should be performed via the Pipecat client in order to keep state in sync.
            case "initialize":
              errMsg = `Direct calls to initialize() are disabled and used internally by the PipecatClient.`;
              break;
            case "initDevices":
              errMsg = `Direct calls to initDevices() are disabled. Please use the PipecatClient.initDevices() wrapper or let PipecatClient.connect() call it for you.`;
              break;
            case "sendReadyMessage":
              errMsg = `Direct calls to sendReadyMessage() are disabled and used internally by the PipecatClient.`;
              break;
            case "connect":
              errMsg = `Direct calls to connect() are disabled. Please use the PipecatClient.connect() wrapper.`;
              break;
            case "disconnect":
              errMsg = `Direct calls to disconnect() are disabled. Please use the PipecatClient.disconnect() wrapper.`;
              break;
          }
          if (errMsg) return () => {
            throw new Error(errMsg);
          };
          return (...args) => {
            return target[prop](...args);
          };
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  get proxy() {
    return this._proxy;
  }
};
var $dfd757760e36925b$exports = {};
$parcel$export($dfd757760e36925b$exports, "learnAboutClient", () => $dfd757760e36925b$export$7eb7b0a641098f31);
function $dfd757760e36925b$export$7eb7b0a641098f31() {
  var _a, _b, _c, _d, _e, _f;
  let about = {
    library: (0, $e3bad9cc25e327f7$exports.name),
    library_version: (0, $e3bad9cc25e327f7$exports.version),
    platform_details: {}
  };
  let navAgentInfo = null;
  if ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) try {
    navAgentInfo = (0, bowser_default).parse(window.navigator.userAgent);
  } catch (_) {
  }
  if ((_b = navAgentInfo == null ? void 0 : navAgentInfo.browser) == null ? void 0 : _b.name) about.platform_details.browser = navAgentInfo.browser.name;
  if (((_c = navAgentInfo == null ? void 0 : navAgentInfo.browser) == null ? void 0 : _c.name) === "Safari" && !navAgentInfo.browser.version) about.platform_details.browser_version = "Web View";
  else if ((_d = navAgentInfo == null ? void 0 : navAgentInfo.browser) == null ? void 0 : _d.version) about.platform_details.browser_version = navAgentInfo.browser.version;
  if ((_e = navAgentInfo == null ? void 0 : navAgentInfo.platform) == null ? void 0 : _e.type) about.platform_details.platform_type = navAgentInfo.platform.type;
  if ((_f = navAgentInfo == null ? void 0 : navAgentInfo.engine) == null ? void 0 : _f.name) about.platform_details.engine = navAgentInfo.engine.name;
  if (navAgentInfo == null ? void 0 : navAgentInfo.os) {
    about.platform = navAgentInfo.os.name;
    about.platform_version = navAgentInfo.os.version;
  }
  return about;
}
var $364c127d152b1085$var$__decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var $364c127d152b1085$var$RTVIEventEmitter = class extends (0, import_events.default) {
};
var $364c127d152b1085$export$8f7f86a77535f7a3 = class extends $364c127d152b1085$var$RTVIEventEmitter {
  constructor(options) {
    super();
    this._functionCallCallbacks = {};
    (0, $c0d10c4690969999$export$e4036f9b8ddb7379)((0, $dfd757760e36925b$export$7eb7b0a641098f31)());
    this._transport = options.transport;
    this._transportWrapper = new (0, $7ef5cee66c377f4d$export$82b6ede160a64a3c)(this._transport);
    const wrappedCallbacks = {
      ...options.callbacks,
      onMessageError: (message) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onMessageError) == null ? void 0 : _b.call(_a, message);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).MessageError, message);
      },
      onError: (message) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onError) == null ? void 0 : _b.call(_a, message);
        try {
          this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).Error, message);
        } catch (e) {
          (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("Could not emit error", message);
        }
        const data = message.data;
        if (data == null ? void 0 : data.fatal) {
          (0, $e0900798b6cc045b$export$af88d00dbe7f521).error("Fatal error reported. Disconnecting...");
          this.disconnect();
        }
      },
      onConnected: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onConnected) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).Connected);
      },
      onDisconnected: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onDisconnected) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).Disconnected);
      },
      onTransportStateChanged: (state) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onTransportStateChanged) == null ? void 0 : _b.call(_a, state);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).TransportStateChanged, state);
      },
      onParticipantJoined: (p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onParticipantJoined) == null ? void 0 : _b.call(_a, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ParticipantConnected, p);
      },
      onParticipantLeft: (p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onParticipantLeft) == null ? void 0 : _b.call(_a, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ParticipantLeft, p);
      },
      onTrackStarted: (track, p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onTrackStarted) == null ? void 0 : _b.call(_a, track, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).TrackStarted, track, p);
      },
      onTrackStopped: (track, p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onTrackStopped) == null ? void 0 : _b.call(_a, track, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).TrackStopped, track, p);
      },
      onScreenTrackStarted: (track, p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onScreenTrackStarted) == null ? void 0 : _b.call(_a, track, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ScreenTrackStarted, track, p);
      },
      onScreenTrackStopped: (track, p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onScreenTrackStopped) == null ? void 0 : _b.call(_a, track, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ScreenTrackStopped, track, p);
      },
      onScreenShareError: (errorMessage) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onScreenShareError) == null ? void 0 : _b.call(_a, errorMessage);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ScreenShareError, errorMessage);
      },
      onAvailableCamsUpdated: (cams) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onAvailableCamsUpdated) == null ? void 0 : _b.call(_a, cams);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableCamsUpdated, cams);
      },
      onAvailableMicsUpdated: (mics) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onAvailableMicsUpdated) == null ? void 0 : _b.call(_a, mics);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableMicsUpdated, mics);
      },
      onAvailableSpeakersUpdated: (speakers) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onAvailableSpeakersUpdated) == null ? void 0 : _b.call(_a, speakers);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableSpeakersUpdated, speakers);
      },
      onCamUpdated: (cam) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onCamUpdated) == null ? void 0 : _b.call(_a, cam);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).CamUpdated, cam);
      },
      onMicUpdated: (mic) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onMicUpdated) == null ? void 0 : _b.call(_a, mic);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).MicUpdated, mic);
      },
      onSpeakerUpdated: (speaker) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onSpeakerUpdated) == null ? void 0 : _b.call(_a, speaker);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).SpeakerUpdated, speaker);
      },
      onDeviceError: (error) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onDeviceError) == null ? void 0 : _b.call(_a, error);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).DeviceError, error);
      },
      onBotConnected: (p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotConnected) == null ? void 0 : _b.call(_a, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotConnected, p);
      },
      onBotReady: (botReadyData) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotReady) == null ? void 0 : _b.call(_a, botReadyData);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotReady, botReadyData);
      },
      onBotDisconnected: (p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotDisconnected) == null ? void 0 : _b.call(_a, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotDisconnected, p);
      },
      onBotStartedSpeaking: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotStartedSpeaking) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotStartedSpeaking);
      },
      onBotStoppedSpeaking: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotStoppedSpeaking) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotStoppedSpeaking);
      },
      onRemoteAudioLevel: (level, p) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onRemoteAudioLevel) == null ? void 0 : _b.call(_a, level, p);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).RemoteAudioLevel, level, p);
      },
      onUserStartedSpeaking: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onUserStartedSpeaking) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).UserStartedSpeaking);
      },
      onUserStoppedSpeaking: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onUserStoppedSpeaking) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).UserStoppedSpeaking);
      },
      onLocalAudioLevel: (level) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onLocalAudioLevel) == null ? void 0 : _b.call(_a, level);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).LocalAudioLevel, level);
      },
      onUserTranscript: (data) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onUserTranscript) == null ? void 0 : _b.call(_a, data);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).UserTranscript, data);
      },
      onBotTranscript: (text) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotTranscript) == null ? void 0 : _b.call(_a, text);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotTranscript, text);
      },
      onBotLlmText: (text) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotLlmText) == null ? void 0 : _b.call(_a, text);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotLlmText, text);
      },
      onBotLlmStarted: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotLlmStarted) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotLlmStarted);
      },
      onBotLlmStopped: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotLlmStopped) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotLlmStopped);
      },
      onBotTtsText: (text) => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotTtsText) == null ? void 0 : _b.call(_a, text);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotTtsText, text);
      },
      onBotTtsStarted: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotTtsStarted) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotTtsStarted);
      },
      onBotTtsStopped: () => {
        var _a, _b;
        (_b = (_a = options == null ? void 0 : options.callbacks) == null ? void 0 : _a.onBotTtsStopped) == null ? void 0 : _b.call(_a);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotTtsStopped);
      }
    };
    this._options = {
      ...options,
      callbacks: wrappedCallbacks,
      enableMic: options.enableMic ?? true,
      enableCam: options.enableCam ?? false,
      enableScreenShare: options.enableScreenShare ?? false
    };
    this._initialize();
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[Pipecat Client] Initialized", this.version);
  }
  setLogLevel(level) {
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).setLevel(level);
  }
  // ------ Transport methods
  /**
   * Initialize local media devices
   */
  async initDevices() {
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[Pipecat Client] Initializing devices...");
    await this._transport.initDevices();
  }
  /**
   * startBot() is a method that initiates the bot by posting to a specified endpoint
   * that optionally returns connection parameters for establishing a transport session.
   * @param startBotParams
   * @returns Promise that resolves to TransportConnectionParams or unknown
   */
  async startBot(startBotParams) {
    this._transport.state = "authenticating";
    this._abortController = new AbortController();
    let response;
    try {
      response = await (0, $d0e914667cc5346b$export$699251e5611cc6db)(startBotParams, this._abortController);
    } catch (e) {
      if (e instanceof Response) {
        const errResp = await e.json();
        throw new $db6391dc7d757577$export$e7544ab812238a61(errResp.info ?? errResp.detail ?? e.statusText, e.status);
      } else if (e instanceof Error) throw new $db6391dc7d757577$export$e7544ab812238a61(e.message);
      else throw new $db6391dc7d757577$export$e7544ab812238a61("An unknown error occurred while starting the bot.");
    }
    this._transport.state = "authenticated";
    return response;
  }
  /**
   * The `connect` function establishes a transport session and awaits a
   * bot-ready signal, handling various connection states and errors.
   * @param {TransportConnectionParams} [connectParams] -
   * The `connectParams` parameter in the `connect` method should be of type
   * `TransportConnectionParams`. This parameter is passed to the transport
   * for establishing a transport session.
   * NOTE: `connectParams` as type `ConnectionEndpoint` IS NOW DEPRECATED. If you
   * want to authenticate and connect to a bot in one step, use
   * `startBotAndConnect()` instead.
   * @returns The `connect` method returns a Promise that resolves to an unknown value.
   */
  async connect(connectParams) {
    if (connectParams && (0, $d0e914667cc5346b$export$2dd7ca293b2783)(connectParams)) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn("Calling connect with an API endpoint is deprecated. Use startBotAndConnect() instead.");
      return this.startBotAndConnect(connectParams);
    }
    return new Promise((resolve, reject) => {
      (async () => {
        this._connectResolve = resolve;
        if (this._transport.state === "disconnected") await this._transport.initDevices();
        try {
          await this._transport.connect(connectParams);
          await this._transport.sendReadyMessage();
        } catch (e) {
          this.disconnect();
          reject(e);
          return;
        }
      })();
    });
  }
  async startBotAndConnect(startBotParams) {
    if (this._transport.state === "disconnected") await this._transport.initDevices();
    const connectionParams = await this.startBot(startBotParams);
    return this.connect(connectionParams);
  }
  /**
   * Disconnect the voice client from the transport
   * Reset / reinitialize transport and abort any pending requests
   */
  async disconnect() {
    await this._transport.disconnect();
    this._messageDispatcher.disconnect();
  }
  /**
   * The _initialize function performs internal set up of the transport and
   * message dispatcher.
   */
  _initialize() {
    this._transport.initialize(this._options, this.handleMessage.bind(this));
    this._messageDispatcher = new (0, $769bb602511974a1$export$e9a960646cc432aa)(this._transport.sendMessage.bind(this._transport));
  }
  /**
   * Get the current state of the transport
   */
  get connected() {
    return [
      "connected",
      "ready"
    ].includes(this._transport.state);
  }
  get transport() {
    return this._transportWrapper.proxy;
  }
  get state() {
    return this._transport.state;
  }
  get version() {
    return (0, $parcel$interopDefault($e3bad9cc25e327f7$exports)).version;
  }
  // ------ Device methods
  async getAllMics() {
    return await this._transport.getAllMics();
  }
  async getAllCams() {
    return await this._transport.getAllCams();
  }
  async getAllSpeakers() {
    return await this._transport.getAllSpeakers();
  }
  get selectedMic() {
    return this._transport.selectedMic;
  }
  get selectedCam() {
    return this._transport.selectedCam;
  }
  get selectedSpeaker() {
    return this._transport.selectedSpeaker;
  }
  updateMic(micId) {
    this._transport.updateMic(micId);
  }
  updateCam(camId) {
    this._transport.updateCam(camId);
  }
  updateSpeaker(speakerId) {
    this._transport.updateSpeaker(speakerId);
  }
  enableMic(enable) {
    this._transport.enableMic(enable);
  }
  get isMicEnabled() {
    return this._transport.isMicEnabled;
  }
  enableCam(enable) {
    this._transport.enableCam(enable);
  }
  get isCamEnabled() {
    return this._transport.isCamEnabled;
  }
  tracks() {
    return this._transport.tracks();
  }
  enableScreenShare(enable) {
    return this._transport.enableScreenShare(enable);
  }
  get isSharingScreen() {
    return this._transport.isSharingScreen;
  }
  // ------ Messages
  /**
   * Directly send a message to the bot via the transport.
   * Do not await a response.
   * @param msgType - a string representing the message type
   * @param data - a dictionary of data to send with the message
   */
  sendClientMessage(msgType, data) {
    this._transport.sendMessage(new (0, $c0d10c4690969999$export$69aa9ab0334b212)((0, $c0d10c4690969999$export$38b3db05cbf0e240).CLIENT_MESSAGE, {
      t: msgType,
      d: data
    }));
  }
  /**
   * Directly send a message to the bot via the transport.
   * Wait for and return the response.
   * @param msgType - a string representing the message type
   * @param data - a dictionary of data to send with the message
   * @param timeout - optional timeout in milliseconds for the response
   */
  async sendClientRequest(msgType, data, timeout) {
    const msgData = {
      t: msgType,
      d: data
    };
    const response = await this._messageDispatcher.dispatch(msgData, (0, $c0d10c4690969999$export$38b3db05cbf0e240).CLIENT_MESSAGE, timeout);
    const ret_data = response.data;
    return ret_data.d;
  }
  registerFunctionCallHandler(functionName, callback) {
    this._functionCallCallbacks[functionName] = callback;
  }
  unregisterFunctionCallHandler(functionName) {
    delete this._functionCallCallbacks[functionName];
  }
  unregisterAllFunctionCallHandlers() {
    this._functionCallCallbacks = {};
  }
  async appendToContext(context) {
    const response = await this._messageDispatcher.dispatch({
      role: context.role,
      content: context.content,
      run_immediately: context.run_immediately
    }, (0, $c0d10c4690969999$export$38b3db05cbf0e240).APPEND_TO_CONTEXT);
    const responseData = response.data;
    return !!responseData.result;
  }
  /**
   * Disconnects the bot, but keeps the session alive
   */
  disconnectBot() {
    this._transport.sendMessage(new (0, $c0d10c4690969999$export$69aa9ab0334b212)((0, $c0d10c4690969999$export$38b3db05cbf0e240).DISCONNECT_BOT, {}));
  }
  handleMessage(ev) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M;
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[RTVI Message]", ev);
    switch (ev.type) {
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_READY: {
        const data = ev.data;
        const botVersion = data.version ? data.version.split(".").map(Number) : [
          0,
          0,
          0
        ];
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`[Pipecat Client] Bot is ready. Version: ${data.version}`);
        if (botVersion[0] < 1) (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn("[Pipecat Client] Bot version is less than 1.0.0, which may not be compatible with this client.");
        (_a = this._connectResolve) == null ? void 0 : _a.call(this, ev.data);
        (_c = (_b = this._options.callbacks) == null ? void 0 : _b.onBotReady) == null ? void 0 : _c.call(_b, ev.data);
        break;
      }
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).ERROR:
        (_e = (_d = this._options.callbacks) == null ? void 0 : _d.onError) == null ? void 0 : _e.call(_d, ev);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).SERVER_RESPONSE:
        this._messageDispatcher.resolve(ev);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).ERROR_RESPONSE: {
        const resp = this._messageDispatcher.reject(ev);
        (_g = (_f = this._options.callbacks) == null ? void 0 : _f.onMessageError) == null ? void 0 : _g.call(_f, resp);
        break;
      }
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).USER_STARTED_SPEAKING:
        (_i = (_h = this._options.callbacks) == null ? void 0 : _h.onUserStartedSpeaking) == null ? void 0 : _i.call(_h);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).USER_STOPPED_SPEAKING:
        (_k = (_j = this._options.callbacks) == null ? void 0 : _j.onUserStoppedSpeaking) == null ? void 0 : _k.call(_j);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_STARTED_SPEAKING:
        (_m = (_l = this._options.callbacks) == null ? void 0 : _l.onBotStartedSpeaking) == null ? void 0 : _m.call(_l);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_STOPPED_SPEAKING:
        (_o = (_n = this._options.callbacks) == null ? void 0 : _n.onBotStoppedSpeaking) == null ? void 0 : _o.call(_n);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).USER_TRANSCRIPTION: {
        const TranscriptData = ev.data;
        (_q = (_p = this._options.callbacks) == null ? void 0 : _p.onUserTranscript) == null ? void 0 : _q.call(_p, TranscriptData);
        break;
      }
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_TRANSCRIPTION:
        (_s = (_r = this._options.callbacks) == null ? void 0 : _r.onBotTranscript) == null ? void 0 : _s.call(_r, ev.data);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_LLM_TEXT:
        (_u = (_t = this._options.callbacks) == null ? void 0 : _t.onBotLlmText) == null ? void 0 : _u.call(_t, ev.data);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_LLM_STARTED:
        (_w = (_v = this._options.callbacks) == null ? void 0 : _v.onBotLlmStarted) == null ? void 0 : _w.call(_v);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_LLM_STOPPED:
        (_y = (_x = this._options.callbacks) == null ? void 0 : _x.onBotLlmStopped) == null ? void 0 : _y.call(_x);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_TTS_TEXT:
        (_A = (_z = this._options.callbacks) == null ? void 0 : _z.onBotTtsText) == null ? void 0 : _A.call(_z, ev.data);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_TTS_STARTED:
        (_C = (_B = this._options.callbacks) == null ? void 0 : _B.onBotTtsStarted) == null ? void 0 : _C.call(_B);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_TTS_STOPPED:
        (_E = (_D = this._options.callbacks) == null ? void 0 : _D.onBotTtsStopped) == null ? void 0 : _E.call(_D);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).METRICS:
        (_G = (_F = this._options.callbacks) == null ? void 0 : _F.onMetrics) == null ? void 0 : _G.call(_F, ev.data);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).Metrics, ev.data);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).APPEND_TO_CONTEXT_RESULT:
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).SERVER_MESSAGE:
        (_I = (_H = this._options.callbacks) == null ? void 0 : _H.onServerMessage) == null ? void 0 : _I.call(_H, ev.data);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ServerMessage, ev.data);
        break;
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).LLM_FUNCTION_CALL: {
        const data = ev.data;
        const fc = this._functionCallCallbacks[data.function_name];
        if (fc) {
          const params = {
            functionName: data.function_name,
            arguments: data.args
          };
          fc(params).then((result) => {
            if (result == void 0) return;
            this._transport.sendMessage(new (0, $c0d10c4690969999$export$69aa9ab0334b212)((0, $c0d10c4690969999$export$38b3db05cbf0e240).LLM_FUNCTION_CALL_RESULT, {
              function_name: data.function_name,
              tool_call_id: data.tool_call_id,
              arguments: data.args,
              result
            }));
          });
        }
        (_K = (_J = this._options.callbacks) == null ? void 0 : _J.onLLMFunctionCall) == null ? void 0 : _K.call(_J, data);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).LLMFunctionCall, data);
        break;
      }
      case (0, $c0d10c4690969999$export$38b3db05cbf0e240).BOT_LLM_SEARCH_RESPONSE: {
        const data = ev.data;
        (_M = (_L = this._options.callbacks) == null ? void 0 : _L.onBotLlmSearchResponse) == null ? void 0 : _M.call(_L, data);
        this.emit((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).BotLlmSearchResponse, data);
        break;
      }
      default:
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[Pipecat Client] Unrecognized message type", ev.type);
        break;
    }
  }
};
$364c127d152b1085$var$__decorate([
  (0, $c68ef2498d1a7177$export$ebc0d747cf8770bc)
], $364c127d152b1085$export$8f7f86a77535f7a3.prototype, "startBot", null);
$364c127d152b1085$var$__decorate([
  (0, $c68ef2498d1a7177$export$ebc0d747cf8770bc)
], $364c127d152b1085$export$8f7f86a77535f7a3.prototype, "connect", null);
$364c127d152b1085$var$__decorate([
  (0, $c68ef2498d1a7177$export$ebc0d747cf8770bc)
], $364c127d152b1085$export$8f7f86a77535f7a3.prototype, "startBotAndConnect", null);
$364c127d152b1085$var$__decorate([
  (0, $c68ef2498d1a7177$export$f1586721024c4dab)
], $364c127d152b1085$export$8f7f86a77535f7a3.prototype, "sendClientMessage", null);
$364c127d152b1085$var$__decorate([
  (0, $c68ef2498d1a7177$export$f1586721024c4dab)
], $364c127d152b1085$export$8f7f86a77535f7a3.prototype, "sendClientRequest", null);
$364c127d152b1085$var$__decorate([
  (0, $c68ef2498d1a7177$export$f1586721024c4dab)
], $364c127d152b1085$export$8f7f86a77535f7a3.prototype, "appendToContext", null);
$364c127d152b1085$var$__decorate([
  (0, $c68ef2498d1a7177$export$f1586721024c4dab)
], $364c127d152b1085$export$8f7f86a77535f7a3.prototype, "disconnectBot", null);
$parcel$exportWildcard($05fa7b586184a19c$exports, $364c127d152b1085$exports);
$parcel$exportWildcard($05fa7b586184a19c$exports, $769bb602511974a1$exports);
$parcel$exportWildcard($05fa7b586184a19c$exports, $e0900798b6cc045b$exports);
$parcel$exportWildcard($05fa7b586184a19c$exports, $d0e914667cc5346b$exports);
$parcel$exportWildcard($05fa7b586184a19c$exports, $7ef5cee66c377f4d$exports);
$parcel$exportWildcard($05fa7b586184a19c$exports, $dfd757760e36925b$exports);

// node_modules/.pnpm/@pipecat-ai+client-react@1.0.1_@pipecat-ai+client-js@1.3.0_@types+react@19.1.13_react-dom@19._gp234ewo3i5ogqtf6mo5pvjjzu/node_modules/@pipecat-ai/client-react/dist/index.module.js
var import_react4 = __toESM(require_react());

// node_modules/.pnpm/jotai@2.14.0_@types+react@19.1.13_react@19.1.1/node_modules/jotai/esm/vanilla/internals.mjs
function isSelfAtom(atom2, a) {
  return atom2.unstable_is ? atom2.unstable_is(a) : a === atom2;
}
function hasInitialValue(atom2) {
  return "init" in atom2;
}
function isActuallyWritableAtom(atom2) {
  return !!atom2.write;
}
function isAtomStateInitialized(atomState) {
  return "v" in atomState || "e" in atomState;
}
function returnAtomValue(atomState) {
  if ("e" in atomState) {
    throw atomState.e;
  }
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("v" in atomState)) {
    throw new Error("[Bug] atom state is not initialized");
  }
  return atomState.v;
}
var promiseStateMap = /* @__PURE__ */ new WeakMap();
function isPendingPromise(value) {
  var _a;
  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);
}
function abortPromise(promise) {
  const promiseState = promiseStateMap.get(promise);
  if (promiseState == null ? void 0 : promiseState[0]) {
    promiseState[0] = false;
    promiseState[1].forEach((fn) => fn());
  }
}
function registerAbortHandler(promise, abortHandler) {
  let promiseState = promiseStateMap.get(promise);
  if (!promiseState) {
    promiseState = [true, /* @__PURE__ */ new Set()];
    promiseStateMap.set(promise, promiseState);
    const settle = () => {
      promiseState[0] = false;
    };
    promise.then(settle, settle);
  }
  promiseState[1].add(abortHandler);
}
function isPromiseLike(p) {
  return typeof (p == null ? void 0 : p.then) === "function";
}
function addPendingPromiseToDependency(atom2, promise, dependencyAtomState) {
  if (!dependencyAtomState.p.has(atom2)) {
    dependencyAtomState.p.add(atom2);
    const cleanup = () => dependencyAtomState.p.delete(atom2);
    promise.then(cleanup, cleanup);
  }
}
function getMountedOrPendingDependents(atom2, atomState, mountedMap) {
  var _a;
  const dependents = /* @__PURE__ */ new Set();
  for (const a of ((_a = mountedMap.get(atom2)) == null ? void 0 : _a.t) || []) {
    if (mountedMap.has(a)) {
      dependents.add(a);
    }
  }
  for (const atomWithPendingPromise of atomState.p) {
    dependents.add(atomWithPendingPromise);
  }
  return dependents;
}
var atomRead = (_store, atom2, ...params) => atom2.read(...params);
var atomWrite = (_store, atom2, ...params) => atom2.write(...params);
var atomOnInit = (store, atom2) => {
  var _a;
  return (_a = atom2.unstable_onInit) == null ? void 0 : _a.call(atom2, store);
};
var atomOnMount = (_store, atom2, setAtom) => {
  var _a;
  return (_a = atom2.onMount) == null ? void 0 : _a.call(atom2, setAtom);
};
var ensureAtomState = (store, atom2) => {
  const buildingBlocks = getBuildingBlocks(store);
  const atomStateMap = buildingBlocks[0];
  const atomOnInit2 = buildingBlocks[9];
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !atom2) {
    throw new Error("Atom is undefined or null");
  }
  let atomState = atomStateMap.get(atom2);
  if (!atomState) {
    atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };
    atomStateMap.set(atom2, atomState);
    atomOnInit2 == null ? void 0 : atomOnInit2(store, atom2);
  }
  return atomState;
};
var flushCallbacks = (store) => {
  const buildingBlocks = getBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const changedAtoms = buildingBlocks[3];
  const mountCallbacks = buildingBlocks[4];
  const unmountCallbacks = buildingBlocks[5];
  const storeHooks = buildingBlocks[6];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const errors = [];
  const call = (fn) => {
    try {
      fn();
    } catch (e) {
      errors.push(e);
    }
  };
  do {
    if (storeHooks.f) {
      call(storeHooks.f);
    }
    const callbacks = /* @__PURE__ */ new Set();
    const add = callbacks.add.bind(callbacks);
    changedAtoms.forEach((atom2) => {
      var _a;
      return (_a = mountedMap.get(atom2)) == null ? void 0 : _a.l.forEach(add);
    });
    changedAtoms.clear();
    unmountCallbacks.forEach(add);
    unmountCallbacks.clear();
    mountCallbacks.forEach(add);
    mountCallbacks.clear();
    callbacks.forEach(call);
    if (changedAtoms.size) {
      recomputeInvalidatedAtoms2(store);
    }
  } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);
  if (errors.length) {
    throw new AggregateError(errors);
  }
};
var recomputeInvalidatedAtoms = (store) => {
  const buildingBlocks = getBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const invalidatedAtoms = buildingBlocks[2];
  const changedAtoms = buildingBlocks[3];
  const ensureAtomState2 = buildingBlocks[11];
  const readAtomState2 = buildingBlocks[14];
  const mountDependencies2 = buildingBlocks[17];
  const topSortedReversed = [];
  const visiting = /* @__PURE__ */ new WeakSet();
  const visited = /* @__PURE__ */ new WeakSet();
  const stack = Array.from(changedAtoms);
  while (stack.length) {
    const a = stack[stack.length - 1];
    const aState = ensureAtomState2(store, a);
    if (visited.has(a)) {
      stack.pop();
      continue;
    }
    if (visiting.has(a)) {
      if (invalidatedAtoms.get(a) === aState.n) {
        topSortedReversed.push([a, aState]);
      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && invalidatedAtoms.has(a)) {
        throw new Error("[Bug] invalidated atom exists");
      }
      visited.add(a);
      stack.pop();
      continue;
    }
    visiting.add(a);
    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
      if (!visiting.has(d)) {
        stack.push(d);
      }
    }
  }
  for (let i = topSortedReversed.length - 1; i >= 0; --i) {
    const [a, aState] = topSortedReversed[i];
    let hasChangedDeps = false;
    for (const dep of aState.d.keys()) {
      if (dep !== a && changedAtoms.has(dep)) {
        hasChangedDeps = true;
        break;
      }
    }
    if (hasChangedDeps) {
      readAtomState2(store, a);
      mountDependencies2(store, a);
    }
    invalidatedAtoms.delete(a);
  }
};
var readAtomState = (store, atom2) => {
  var _a;
  const buildingBlocks = getBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const invalidatedAtoms = buildingBlocks[2];
  const changedAtoms = buildingBlocks[3];
  const storeHooks = buildingBlocks[6];
  const atomRead2 = buildingBlocks[7];
  const ensureAtomState2 = buildingBlocks[11];
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const readAtomState2 = buildingBlocks[14];
  const writeAtomState2 = buildingBlocks[16];
  const mountDependencies2 = buildingBlocks[17];
  const atomState = ensureAtomState2(store, atom2);
  if (isAtomStateInitialized(atomState)) {
    if (mountedMap.has(atom2) && invalidatedAtoms.get(atom2) !== atomState.n) {
      return atomState;
    }
    if (Array.from(atomState.d).every(
      ([a, n]) => (
        // Recursively, read the atom state of the dependency, and
        // check if the atom epoch number is unchanged
        readAtomState2(store, a).n === n
      )
    )) {
      return atomState;
    }
  }
  atomState.d.clear();
  let isSync = true;
  function mountDependenciesIfAsync() {
    if (mountedMap.has(atom2)) {
      mountDependencies2(store, atom2);
      recomputeInvalidatedAtoms2(store);
      flushCallbacks2(store);
    }
  }
  function getter(a) {
    var _a2;
    if (isSelfAtom(atom2, a)) {
      const aState2 = ensureAtomState2(store, a);
      if (!isAtomStateInitialized(aState2)) {
        if (hasInitialValue(a)) {
          setAtomStateValueOrPromise(store, a, a.init);
        } else {
          throw new Error("no atom init");
        }
      }
      return returnAtomValue(aState2);
    }
    const aState = readAtomState2(store, a);
    try {
      return returnAtomValue(aState);
    } finally {
      atomState.d.set(a, aState.n);
      if (isPendingPromise(atomState.v)) {
        addPendingPromiseToDependency(atom2, atomState.v, aState);
      }
      (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom2);
      if (!isSync) {
        mountDependenciesIfAsync();
      }
    }
  }
  let controller;
  let setSelf;
  const options = {
    get signal() {
      if (!controller) {
        controller = new AbortController();
      }
      return controller.signal;
    },
    get setSelf() {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
        console.warn("setSelf function cannot be used with read-only atom");
      }
      if (!setSelf && isActuallyWritableAtom(atom2)) {
        setSelf = (...args) => {
          if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && isSync) {
            console.warn("setSelf function cannot be called in sync");
          }
          if (!isSync) {
            try {
              return writeAtomState2(store, atom2, ...args);
            } finally {
              recomputeInvalidatedAtoms2(store);
              flushCallbacks2(store);
            }
          }
        };
      }
      return setSelf;
    }
  };
  const prevEpochNumber = atomState.n;
  try {
    const valueOrPromise = atomRead2(store, atom2, getter, options);
    setAtomStateValueOrPromise(store, atom2, valueOrPromise);
    if (isPromiseLike(valueOrPromise)) {
      registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());
      valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);
    }
    return atomState;
  } catch (error) {
    delete atomState.v;
    atomState.e = error;
    ++atomState.n;
    return atomState;
  } finally {
    isSync = false;
    if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom2) === prevEpochNumber) {
      invalidatedAtoms.set(atom2, atomState.n);
      changedAtoms.add(atom2);
      (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, atom2);
    }
  }
};
var invalidateDependents = (store, atom2) => {
  const buildingBlocks = getBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const invalidatedAtoms = buildingBlocks[2];
  const ensureAtomState2 = buildingBlocks[11];
  const stack = [atom2];
  while (stack.length) {
    const a = stack.pop();
    const aState = ensureAtomState2(store, a);
    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
      const dState = ensureAtomState2(store, d);
      invalidatedAtoms.set(d, dState.n);
      stack.push(d);
    }
  }
};
var writeAtomState = (store, atom2, ...args) => {
  const buildingBlocks = getBuildingBlocks(store);
  const changedAtoms = buildingBlocks[3];
  const storeHooks = buildingBlocks[6];
  const atomWrite2 = buildingBlocks[8];
  const ensureAtomState2 = buildingBlocks[11];
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const readAtomState2 = buildingBlocks[14];
  const invalidateDependents2 = buildingBlocks[15];
  const mountDependencies2 = buildingBlocks[17];
  let isSync = true;
  const getter = (a) => returnAtomValue(readAtomState2(store, a));
  const setter = (a, ...args2) => {
    var _a;
    const aState = ensureAtomState2(store, a);
    try {
      if (isSelfAtom(atom2, a)) {
        if (!hasInitialValue(a)) {
          throw new Error("atom not writable");
        }
        const prevEpochNumber = aState.n;
        const v = args2[0];
        setAtomStateValueOrPromise(store, a, v);
        mountDependencies2(store, a);
        if (prevEpochNumber !== aState.n) {
          changedAtoms.add(a);
          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);
          invalidateDependents2(store, a);
        }
        return void 0;
      } else {
        return writeAtomState(store, a, ...args2);
      }
    } finally {
      if (!isSync) {
        recomputeInvalidatedAtoms2(store);
        flushCallbacks2(store);
      }
    }
  };
  try {
    return atomWrite2(store, atom2, getter, setter, ...args);
  } finally {
    isSync = false;
  }
};
var mountDependencies = (store, atom2) => {
  var _a;
  const buildingBlocks = getBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const changedAtoms = buildingBlocks[3];
  const storeHooks = buildingBlocks[6];
  const ensureAtomState2 = buildingBlocks[11];
  const invalidateDependents2 = buildingBlocks[15];
  const mountAtom2 = buildingBlocks[18];
  const unmountAtom2 = buildingBlocks[19];
  const atomState = ensureAtomState2(store, atom2);
  const mounted = mountedMap.get(atom2);
  if (mounted && !isPendingPromise(atomState.v)) {
    for (const [a, n] of atomState.d) {
      if (!mounted.d.has(a)) {
        const aState = ensureAtomState2(store, a);
        const aMounted = mountAtom2(store, a);
        aMounted.t.add(atom2);
        mounted.d.add(a);
        if (n !== aState.n) {
          changedAtoms.add(a);
          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);
          invalidateDependents2(store, a);
        }
      }
    }
    for (const a of mounted.d || []) {
      if (!atomState.d.has(a)) {
        mounted.d.delete(a);
        const aMounted = unmountAtom2(store, a);
        aMounted == null ? void 0 : aMounted.t.delete(atom2);
      }
    }
  }
};
var mountAtom = (store, atom2) => {
  var _a;
  const buildingBlocks = getBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const mountCallbacks = buildingBlocks[4];
  const storeHooks = buildingBlocks[6];
  const atomOnMount2 = buildingBlocks[10];
  const ensureAtomState2 = buildingBlocks[11];
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const readAtomState2 = buildingBlocks[14];
  const writeAtomState2 = buildingBlocks[16];
  const atomState = ensureAtomState2(store, atom2);
  let mounted = mountedMap.get(atom2);
  if (!mounted) {
    readAtomState2(store, atom2);
    for (const a of atomState.d.keys()) {
      const aMounted = mountAtom(store, a);
      aMounted.t.add(atom2);
    }
    mounted = {
      l: /* @__PURE__ */ new Set(),
      d: new Set(atomState.d.keys()),
      t: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom2, mounted);
    (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom2);
    if (isActuallyWritableAtom(atom2)) {
      const processOnMount = () => {
        let isSync = true;
        const setAtom = (...args) => {
          try {
            return writeAtomState2(store, atom2, ...args);
          } finally {
            if (!isSync) {
              recomputeInvalidatedAtoms2(store);
              flushCallbacks2(store);
            }
          }
        };
        try {
          const onUnmount = atomOnMount2(store, atom2, setAtom);
          if (onUnmount) {
            mounted.u = () => {
              isSync = true;
              try {
                onUnmount();
              } finally {
                isSync = false;
              }
            };
          }
        } finally {
          isSync = false;
        }
      };
      mountCallbacks.add(processOnMount);
    }
  }
  return mounted;
};
var unmountAtom = (store, atom2) => {
  var _a;
  const buildingBlocks = getBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const unmountCallbacks = buildingBlocks[5];
  const storeHooks = buildingBlocks[6];
  const ensureAtomState2 = buildingBlocks[11];
  const unmountAtom2 = buildingBlocks[19];
  const atomState = ensureAtomState2(store, atom2);
  let mounted = mountedMap.get(atom2);
  if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {
    var _a2;
    return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom2);
  })) {
    if (mounted.u) {
      unmountCallbacks.add(mounted.u);
    }
    mounted = void 0;
    mountedMap.delete(atom2);
    (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom2);
    for (const a of atomState.d.keys()) {
      const aMounted = unmountAtom2(store, a);
      aMounted == null ? void 0 : aMounted.t.delete(atom2);
    }
    return void 0;
  }
  return mounted;
};
var setAtomStateValueOrPromise = (store, atom2, valueOrPromise) => {
  const ensureAtomState2 = getBuildingBlocks(store)[11];
  const atomState = ensureAtomState2(store, atom2);
  const hasPrevValue = "v" in atomState;
  const prevValue = atomState.v;
  if (isPromiseLike(valueOrPromise)) {
    for (const a of atomState.d.keys()) {
      addPendingPromiseToDependency(
        atom2,
        valueOrPromise,
        ensureAtomState2(store, a)
      );
    }
  }
  atomState.v = valueOrPromise;
  delete atomState.e;
  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
    ++atomState.n;
    if (isPromiseLike(prevValue)) {
      abortPromise(prevValue);
    }
  }
};
var storeGet = (store, atom2) => {
  const readAtomState2 = getBuildingBlocks(store)[14];
  return returnAtomValue(readAtomState2(store, atom2));
};
var storeSet = (store, atom2, ...args) => {
  const buildingBlocks = getBuildingBlocks(store);
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const writeAtomState2 = buildingBlocks[16];
  try {
    return writeAtomState2(store, atom2, ...args);
  } finally {
    recomputeInvalidatedAtoms2(store);
    flushCallbacks2(store);
  }
};
var storeSub = (store, atom2, listener) => {
  const buildingBlocks = getBuildingBlocks(store);
  const flushCallbacks2 = buildingBlocks[12];
  const mountAtom2 = buildingBlocks[18];
  const unmountAtom2 = buildingBlocks[19];
  const mounted = mountAtom2(store, atom2);
  const listeners = mounted.l;
  listeners.add(listener);
  flushCallbacks2(store);
  return () => {
    listeners.delete(listener);
    unmountAtom2(store, atom2);
    flushCallbacks2(store);
  };
};
var buildingBlockMap = /* @__PURE__ */ new WeakMap();
function getBuildingBlocks(store) {
  const buildingBlocks = buildingBlockMap.get(store);
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !buildingBlocks) {
    throw new Error(
      "Store must be created by buildStore to read its building blocks"
    );
  }
  return buildingBlocks;
}
function buildStore(...buildArgs) {
  const store = {
    get(atom2) {
      const storeGet2 = getBuildingBlocks(store)[21];
      return storeGet2(store, atom2);
    },
    set(atom2, ...args) {
      const storeSet2 = getBuildingBlocks(store)[22];
      return storeSet2(store, atom2, ...args);
    },
    sub(atom2, listener) {
      const storeSub2 = getBuildingBlocks(store)[23];
      return storeSub2(store, atom2, listener);
    }
  };
  const buildingBlocks = [
    // store state
    /* @__PURE__ */ new WeakMap(),
    // atomStateMap
    /* @__PURE__ */ new WeakMap(),
    // mountedMap
    /* @__PURE__ */ new WeakMap(),
    // invalidatedAtoms
    /* @__PURE__ */ new Set(),
    // changedAtoms
    /* @__PURE__ */ new Set(),
    // mountCallbacks
    /* @__PURE__ */ new Set(),
    // unmountCallbacks
    {},
    // storeHooks
    // atom interceptors
    atomRead,
    atomWrite,
    atomOnInit,
    atomOnMount,
    // building-block functions
    ensureAtomState,
    flushCallbacks,
    recomputeInvalidatedAtoms,
    readAtomState,
    invalidateDependents,
    writeAtomState,
    mountDependencies,
    mountAtom,
    unmountAtom,
    setAtomStateValueOrPromise,
    storeGet,
    storeSet,
    storeSub
  ].map((fn, i) => buildArgs[i] || fn);
  buildingBlockMap.set(store, Object.freeze(buildingBlocks));
  return store;
}

// node_modules/.pnpm/jotai@2.14.0_@types+react@19.1.13_react@19.1.1/node_modules/jotai/esm/vanilla.mjs
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString() {
      return (import.meta.env ? import.meta.env.MODE : void 0) !== "production" && this.debugLabel ? key + ":" + this.debugLabel : key;
    }
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = defaultRead;
    config.write = defaultWrite;
  }
  if (write) {
    config.write = write;
  }
  return config;
}
function defaultRead(get) {
  return get(this);
}
function defaultWrite(get, set, arg) {
  return set(
    this,
    typeof arg === "function" ? arg(get(this)) : arg
  );
}
var overiddenCreateStore;
function createStore() {
  if (overiddenCreateStore) {
    return overiddenCreateStore();
  }
  return buildStore();
}
var defaultStore;
function getDefaultStore() {
  if (!defaultStore) {
    defaultStore = createStore();
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
        console.warn(
          "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
        );
      }
    }
  }
  return defaultStore;
}

// node_modules/.pnpm/jotai@2.14.0_@types+react@19.1.13_react@19.1.1/node_modules/jotai/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var StoreContext = (0, import_react.createContext)(
  void 0
);
function useStore(options) {
  const store = (0, import_react.useContext)(StoreContext);
  return (options == null ? void 0 : options.store) || store || getDefaultStore();
}
function Provider({
  children,
  store
}) {
  const storeRef = (0, import_react.useRef)(void 0);
  if (!store && !storeRef.current) {
    storeRef.current = createStore();
  }
  return (0, import_react.createElement)(
    StoreContext.Provider,
    {
      value: store || storeRef.current
    },
    children
  );
}
var isPromiseLike2 = (x) => typeof (x == null ? void 0 : x.then) === "function";
var attachPromiseStatus = (promise) => {
  if (!promise.status) {
    promise.status = "pending";
    promise.then(
      (v) => {
        promise.status = "fulfilled";
        promise.value = v;
      },
      (e) => {
        promise.status = "rejected";
        promise.reason = e;
      }
    );
  }
};
var use = import_react.default.use || // A shim for older React versions
((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    attachPromiseStatus(promise);
    throw promise;
  }
});
var continuablePromiseMap = /* @__PURE__ */ new WeakMap();
var createContinuablePromise = (promise, getValue) => {
  let continuablePromise = continuablePromiseMap.get(promise);
  if (!continuablePromise) {
    continuablePromise = new Promise((resolve, reject) => {
      let curr = promise;
      const onFulfilled = (me) => (v) => {
        if (curr === me) {
          resolve(v);
        }
      };
      const onRejected = (me) => (e) => {
        if (curr === me) {
          reject(e);
        }
      };
      const onAbort = () => {
        try {
          const nextValue = getValue();
          if (isPromiseLike2(nextValue)) {
            continuablePromiseMap.set(nextValue, continuablePromise);
            curr = nextValue;
            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
            registerAbortHandler(nextValue, onAbort);
          } else {
            resolve(nextValue);
          }
        } catch (e) {
          reject(e);
        }
      };
      promise.then(onFulfilled(promise), onRejected(promise));
      registerAbortHandler(promise, onAbort);
    });
    continuablePromiseMap.set(promise, continuablePromise);
  }
  return continuablePromise;
};
function useAtomValue(atom2, options) {
  const { delay, unstable_promiseStatus: promiseStatus = !import_react.default.use } = options || {};
  const store = useStore(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react.useReducer)(
    (prev) => {
      const nextValue = store.get(atom2);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
        return prev;
      }
      return [nextValue, store, atom2];
    },
    void 0,
    () => [store.get(atom2), store, atom2]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom2) {
    rerender();
    value = store.get(atom2);
  }
  (0, import_react.useEffect)(() => {
    const unsub = store.sub(atom2, () => {
      if (promiseStatus) {
        try {
          const value2 = store.get(atom2);
          if (isPromiseLike2(value2)) {
            attachPromiseStatus(
              createContinuablePromise(value2, () => store.get(atom2))
            );
          }
        } catch (e) {
        }
      }
      if (typeof delay === "number") {
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom2, delay, promiseStatus]);
  (0, import_react.useDebugValue)(value);
  if (isPromiseLike2(value)) {
    const promise = createContinuablePromise(value, () => store.get(atom2));
    if (promiseStatus) {
      attachPromiseStatus(promise);
    }
    return use(promise);
  }
  return value;
}
function useSetAtom(atom2, options) {
  const store = useStore(options);
  const setAtom = (0, import_react.useCallback)(
    (...args) => {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("write" in atom2)) {
        throw new Error("not writable atom");
      }
      return store.set(atom2, ...args);
    },
    [store, atom2]
  );
  return setAtom;
}

// node_modules/.pnpm/jotai@2.14.0_@types+react@19.1.13_react@19.1.1/node_modules/jotai/esm/vanilla/utils.mjs
var RESET = Symbol(
  (import.meta.env ? import.meta.env.MODE : void 0) !== "production" ? "RESET" : ""
);
function atomFamily(initializeAtom, areEqual) {
  let shouldRemove = null;
  const atoms = /* @__PURE__ */ new Map();
  const listeners = /* @__PURE__ */ new Set();
  const createAtom = (param) => {
    let item;
    if (areEqual === void 0) {
      item = atoms.get(param);
    } else {
      for (const [key, value] of atoms) {
        if (areEqual(key, param)) {
          item = value;
          break;
        }
      }
    }
    if (item !== void 0) {
      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {
        createAtom.remove(param);
      } else {
        return item[0];
      }
    }
    const newAtom = initializeAtom(param);
    atoms.set(param, [newAtom, Date.now()]);
    notifyListeners("CREATE", param, newAtom);
    return newAtom;
  };
  const notifyListeners = (type, param, atom2) => {
    for (const listener of listeners) {
      listener({ type, param, atom: atom2 });
    }
  };
  createAtom.unstable_listen = (callback) => {
    listeners.add(callback);
    return () => {
      listeners.delete(callback);
    };
  };
  createAtom.getParams = () => atoms.keys();
  createAtom.remove = (param) => {
    if (areEqual === void 0) {
      if (!atoms.has(param)) return;
      const [atom2] = atoms.get(param);
      atoms.delete(param);
      notifyListeners("REMOVE", param, atom2);
    } else {
      for (const [key, [atom2]] of atoms) {
        if (areEqual(key, param)) {
          atoms.delete(key);
          notifyListeners("REMOVE", key, atom2);
          break;
        }
      }
    }
  };
  createAtom.setShouldRemove = (fn) => {
    shouldRemove = fn;
    if (!shouldRemove) return;
    for (const [key, [atom2, createdAt]] of atoms) {
      if (shouldRemove(createdAt, key)) {
        atoms.delete(key);
        notifyListeners("REMOVE", key, atom2);
      }
    }
  };
  return createAtom;
}
var isPromiseLike$3 = (x) => typeof (x == null ? void 0 : x.then) === "function";
function createJSONStorage(getStringStorage = () => {
  try {
    return window.localStorage;
  } catch (e) {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      if (typeof window !== "undefined") {
        console.warn(e);
      }
    }
    return void 0;
  }
}, options) {
  var _a;
  let lastStr;
  let lastValue;
  const storage = {
    getItem: (key, initialValue) => {
      var _a2, _b;
      const parse2 = (str2) => {
        str2 = str2 || "";
        if (lastStr !== str2) {
          try {
            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);
          } catch (e) {
            return initialValue;
          }
          lastStr = str2;
        }
        return lastValue;
      };
      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;
      if (isPromiseLike$3(str)) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (key, newValue) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(
        key,
        JSON.stringify(newValue, options == null ? void 0 : options.replacer)
      );
    },
    removeItem: (key) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);
    }
  };
  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {
    let newValue;
    try {
      newValue = JSON.parse(v || "");
    } catch (e) {
      newValue = initialValue;
    }
    callback(newValue);
  });
  let subscriber;
  try {
    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;
  } catch (e) {
  }
  if (!subscriber && typeof window !== "undefined" && typeof window.addEventListener === "function" && window.Storage) {
    subscriber = (key, callback) => {
      if (!(getStringStorage() instanceof window.Storage)) {
        return () => {
        };
      }
      const storageEventCallback = (e) => {
        if (e.storageArea === getStringStorage() && e.key === key) {
          callback(e.newValue);
        }
      };
      window.addEventListener("storage", storageEventCallback);
      return () => {
        window.removeEventListener("storage", storageEventCallback);
      };
    };
  }
  if (subscriber) {
    storage.subscribe = createHandleSubscribe(subscriber);
  }
  return storage;
}
var defaultStorage = createJSONStorage();

// node_modules/.pnpm/jotai@2.14.0_@types+react@19.1.13_react@19.1.1/node_modules/jotai/esm/react/utils.mjs
var import_react2 = __toESM(require_react(), 1);
function useAtomCallback(callback, options) {
  const anAtom = (0, import_react2.useMemo)(
    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),
    [callback]
  );
  return useSetAtom(anAtom, options);
}

// node_modules/.pnpm/@pipecat-ai+client-react@1.0.1_@pipecat-ai+client-js@1.3.0_@types+react@19.1.13_react-dom@19._gp234ewo3i5ogqtf6mo5pvjjzu/node_modules/@pipecat-ai/client-react/dist/index.module.js
var $ad20387e24e513d4$exports = {};
$ad20387e24e513d4$exports = JSON.parse(`{"name":"@pipecat-ai/client-react","version":"1.0.1","license":"BSD-2-Clause","main":"dist/index.js","module":"dist/index.module.js","types":"dist/index.d.ts","source":"src/index.ts","repository":{"type":"git","url":"git+https://github.com/pipecat-ai/pipecat-client-web.git"},"files":["dist","package.json","README.md"],"scripts":{"build":"parcel build --no-cache","dev":"parcel watch","lint":"eslint . --report-unused-disable-directives --max-warnings 0 --ignore-pattern 'dist/'"},"devDependencies":{"@pipecat-ai/client-js":"*","@types/react":"^18.3.3","@types/react-dom":"^18.3.0","@typescript-eslint/eslint-plugin":"^8.32.0","eslint":"^9.11.1","eslint-config-prettier":"^9.1.0","eslint-plugin-react-hooks":"^5.2.0","eslint-plugin-simple-import-sort":"^12.1.1","parcel":"^2.12.0","react":"^18.3.1","react-dom":"^18.3.1","typescript":"^5.2.2"},"peerDependencies":{"@pipecat-ai/client-js":"*","react":">=18","react-dom":">=18"},"dependencies":{"jotai":"^2.9.0"}}`);
var $33f16f27e37c90bc$export$fe23d0ef95286467 = (0, import_react4.createContext)({
  on: () => {
  },
  off: () => {
  }
});
var $824ea64b5f757259$export$33a6ac53b8f02625 = (event, handler) => {
  const { on, off } = (0, import_react4.useContext)((0, $33f16f27e37c90bc$export$fe23d0ef95286467));
  (0, import_react4.useEffect)(() => {
    on(event, handler);
    return () => {
      off(event, handler);
    };
  }, [
    event,
    handler,
    on,
    off
  ]);
};
var $a90aa7250c094218$export$d6bdcccacef16204 = (0, import_react4.createContext)({
  enableCam: () => {
    throw new Error("PipecatClientCamStateContext: enableCam() called outside of provider");
  },
  isCamEnabled: false
});
var $a90aa7250c094218$export$802b42df0e0d8153 = (0, import_react4.createContext)({
  enableMic: () => {
    throw new Error("PipecatClientMicStateContext: enableMic() called outside of provider");
  },
  isMicEnabled: false
});
var $a90aa7250c094218$export$db79fdf85ddd6b65 = (0, import_react4.createContext)("disconnected");
var $a90aa7250c094218$export$4777554fda61c378 = ({ children }) => {
  const client = (0, $034a56e7ee1b7bed$export$777fa8498be78705)();
  const [isCamEnabled, setIsCamEnabled] = (0, import_react4.useState)(false);
  const [isMicEnabled, setIsMicEnabled] = (0, import_react4.useState)(false);
  const [transportState, setTransportState] = (0, import_react4.useState)("disconnected");
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).TransportStateChanged, (state) => {
    setTransportState(state);
    if (state === "initialized" && client) {
      setIsCamEnabled(client.isCamEnabled ?? false);
      setIsMicEnabled(client.isMicEnabled ?? false);
    }
  });
  const enableCam = (0, import_react4.useCallback)((enabled) => {
    var _a;
    setIsCamEnabled(enabled);
    (_a = client == null ? void 0 : client.enableCam) == null ? void 0 : _a.call(client, enabled);
  }, [
    client
  ]);
  const enableMic = (0, import_react4.useCallback)((enabled) => {
    var _a;
    setIsMicEnabled(enabled);
    (_a = client == null ? void 0 : client.enableMic) == null ? void 0 : _a.call(client, enabled);
  }, [
    client
  ]);
  return (0, import_jsx_runtime.jsx)($a90aa7250c094218$export$db79fdf85ddd6b65.Provider, {
    value: transportState,
    children: (0, import_jsx_runtime.jsx)($a90aa7250c094218$export$d6bdcccacef16204.Provider, {
      value: {
        enableCam,
        isCamEnabled
      },
      children: (0, import_jsx_runtime.jsx)($a90aa7250c094218$export$802b42df0e0d8153.Provider, {
        value: {
          enableMic,
          isMicEnabled
        },
        children
      })
    })
  });
};
var $d2e362c5a07ee3c5$var$defaultStore = (0, createStore)();
var $d2e362c5a07ee3c5$export$67f6d73bc6cd7bb1 = (0, import_react4.createContext)({});
var $d2e362c5a07ee3c5$export$bb43666ced7a20d0 = ({ children, client, jotaiStore = $d2e362c5a07ee3c5$var$defaultStore }) => {
  (0, import_react4.useEffect)(() => {
    (0, $c0d10c4690969999$export$e4036f9b8ddb7379)({
      library: (0, $ad20387e24e513d4$exports.name),
      library_version: (0, $ad20387e24e513d4$exports.version)
    });
  }, []);
  const eventHandlersMap = (0, import_react4.useRef)({});
  (0, import_react4.useEffect)(() => {
    if (!client) return;
    const allEvents = Object.values((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb)).filter((value) => isNaN(Number(value)));
    const allHandlers = {};
    allEvents.forEach((event) => {
      const handler = (...payload) => {
        const handlers = eventHandlersMap.current[event];
        if (!handlers) return;
        handlers.forEach((h) => {
          h(...payload);
        });
      };
      allHandlers[event] = handler;
      client.on(event, handler);
    });
    return () => {
      allEvents.forEach((event) => {
        client.off(event, allHandlers[event]);
      });
    };
  }, [
    client
  ]);
  const on = (0, import_react4.useCallback)((event, handler) => {
    if (!eventHandlersMap.current[event]) eventHandlersMap.current[event] = /* @__PURE__ */ new Set();
    eventHandlersMap.current[event].add(handler);
  }, []);
  const off = (0, import_react4.useCallback)((event, handler) => {
    var _a;
    (_a = eventHandlersMap.current[event]) == null ? void 0 : _a.delete(handler);
  }, []);
  return (0, import_jsx_runtime.jsx)((0, Provider), {
    store: jotaiStore,
    children: (0, import_jsx_runtime.jsx)($d2e362c5a07ee3c5$export$67f6d73bc6cd7bb1.Provider, {
      value: {
        client
      },
      children: (0, import_jsx_runtime.jsx)((0, $33f16f27e37c90bc$export$fe23d0ef95286467).Provider, {
        value: {
          on,
          off
        },
        children: (0, import_jsx_runtime.jsx)((0, $a90aa7250c094218$export$4777554fda61c378), {
          children
        })
      })
    })
  });
};
$d2e362c5a07ee3c5$export$bb43666ced7a20d0.displayName = "PipecatClientProvider";
var $034a56e7ee1b7bed$export$777fa8498be78705 = () => {
  const { client } = (0, import_react4.useContext)((0, $d2e362c5a07ee3c5$export$67f6d73bc6cd7bb1));
  return client;
};
var $4b4b9099cdb5b776$var$localAudioTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$localVideoTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$localScreenAudioTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$localScreenVideoTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$botAudioTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$botVideoTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$trackAtom = (0, atomFamily)(({ local, trackType }) => {
  if (local) switch (trackType) {
    case "audio":
      return $4b4b9099cdb5b776$var$localAudioTrackAtom;
    case "screenAudio":
      return $4b4b9099cdb5b776$var$localScreenAudioTrackAtom;
    case "screenVideo":
      return $4b4b9099cdb5b776$var$localScreenVideoTrackAtom;
    case "video":
      return $4b4b9099cdb5b776$var$localVideoTrackAtom;
  }
  return trackType === "audio" ? $4b4b9099cdb5b776$var$botAudioTrackAtom : $4b4b9099cdb5b776$var$botVideoTrackAtom;
});
var $4b4b9099cdb5b776$export$9813dcd2d0c26814 = (trackType, participantType) => {
  const client = (0, $034a56e7ee1b7bed$export$777fa8498be78705)();
  const track = (0, useAtomValue)($4b4b9099cdb5b776$var$trackAtom({
    local: participantType === "local",
    trackType
  }));
  const updateTrack = (0, useAtomCallback)((0, import_react4.useCallback)((get, set, track2, trackType2, local) => {
    const atom2 = $4b4b9099cdb5b776$var$trackAtom({
      local,
      trackType: trackType2
    });
    const oldTrack = get(atom2);
    if ((oldTrack == null ? void 0 : oldTrack.id) === track2.id) return;
    set(atom2, track2);
  }, []));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).TrackStarted, (0, import_react4.useCallback)((track2, participant) => {
    updateTrack(track2, track2.kind, Boolean(participant == null ? void 0 : participant.local));
  }, [
    updateTrack
  ]));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ScreenTrackStarted, (0, import_react4.useCallback)((track2, participant) => {
    const trackType2 = track2.kind === "audio" ? "screenAudio" : "screenVideo";
    updateTrack(track2, trackType2, Boolean(participant == null ? void 0 : participant.local));
  }, [
    updateTrack
  ]));
  (0, import_react4.useEffect)(() => {
    var _a;
    if (!client) return;
    const tracks = client.tracks();
    const track2 = (_a = tracks == null ? void 0 : tracks[participantType]) == null ? void 0 : _a[trackType];
    if (!track2) return;
    updateTrack(track2, trackType, participantType === "local");
  }, [
    participantType,
    trackType,
    updateTrack,
    client
  ]);
  return track;
};
var $f209aa7ddb77dcb2$export$b52250cb73ff4de1 = () => {
  const botAudioRef = (0, import_react4.useRef)(null);
  const botAudioTrack = (0, $4b4b9099cdb5b776$export$9813dcd2d0c26814)("audio", "bot");
  (0, import_react4.useEffect)(() => {
    if (!botAudioRef.current || !botAudioTrack) return;
    if (botAudioRef.current.srcObject) {
      const oldTrack = botAudioRef.current.srcObject.getAudioTracks()[0];
      if (oldTrack.id === botAudioTrack.id) return;
    }
    botAudioRef.current.srcObject = new MediaStream([
      botAudioTrack
    ]);
  }, [
    botAudioTrack
  ]);
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).SpeakerUpdated, (0, import_react4.useCallback)((speaker) => {
    if (!botAudioRef.current) return;
    if (typeof botAudioRef.current.setSinkId !== "function") return;
    botAudioRef.current.setSinkId(speaker.deviceId);
  }, []));
  return (0, import_jsx_runtime.jsx)((0, import_jsx_runtime.Fragment), {
    children: (0, import_jsx_runtime.jsx)("audio", {
      ref: botAudioRef,
      autoPlay: true
    })
  });
};
$f209aa7ddb77dcb2$export$b52250cb73ff4de1.displayName = "PipecatClientAudio";
var $e76ee2f021b54325$export$3ea2601427f0430f = () => (0, import_react4.useContext)((0, $a90aa7250c094218$export$d6bdcccacef16204));
var $7cb2ce2c4cbfb401$export$dc9a029eeca8213f = ({ onCamEnabledChanged, disabled = false, children }) => {
  const { isCamEnabled, enableCam } = (0, $e76ee2f021b54325$export$3ea2601427f0430f)();
  const handleToggleCam = (0, import_react4.useCallback)(() => {
    if (disabled) return;
    const newEnabledState = !isCamEnabled;
    enableCam(newEnabledState);
    onCamEnabledChanged == null ? void 0 : onCamEnabledChanged(newEnabledState);
  }, [
    disabled,
    enableCam,
    isCamEnabled,
    onCamEnabledChanged
  ]);
  return (0, import_jsx_runtime.jsx)((0, import_jsx_runtime.Fragment), {
    children: children({
      isCamEnabled,
      onClick: handleToggleCam,
      disabled
    })
  });
};
var $5905c001b0dc8d25$export$388e706586309ef0 = () => (0, import_react4.useContext)((0, $a90aa7250c094218$export$802b42df0e0d8153));
var $2984fdfc31bad375$export$bc8133b69ff660a2 = ({ onMicEnabledChanged, disabled = false, children }) => {
  const { enableMic, isMicEnabled } = (0, $5905c001b0dc8d25$export$388e706586309ef0)();
  const handleToggleMic = (0, import_react4.useCallback)(() => {
    if (disabled) return;
    const newEnabledState = !isMicEnabled;
    enableMic(newEnabledState);
    onMicEnabledChanged == null ? void 0 : onMicEnabledChanged(newEnabledState);
  }, [
    disabled,
    enableMic,
    isMicEnabled,
    onMicEnabledChanged
  ]);
  return (0, import_jsx_runtime.jsx)((0, import_jsx_runtime.Fragment), {
    children: children({
      isMicEnabled,
      onClick: handleToggleMic,
      disabled
    })
  });
};
function $9098519210cf34e2$var$useMergedRef(...refs) {
  return (0, import_react4.useCallback)(
    (element) => {
      for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        if (typeof ref === "function") ref(element);
        else if (ref && typeof ref === "object") ref.current = element;
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
}
var $9098519210cf34e2$export$2e2bcd8739ae039 = $9098519210cf34e2$var$useMergedRef;
var $6a65deb8615a2ad7$export$85974db6d0cc43b3 = (0, import_react4.forwardRef)(function VoiceClientVideo({ participant = "local", fit = "contain", mirror, onResize, style = {}, trackType = "video", ...props }, ref) {
  const videoTrack = (0, $4b4b9099cdb5b776$export$9813dcd2d0c26814)(trackType, participant);
  const videoEl = (0, import_react4.useRef)(null);
  const videoRef = (0, $9098519210cf34e2$export$2e2bcd8739ae039)(videoEl, ref);
  (0, import_react4.useEffect)(function setupVideoEvents() {
    const video = videoEl.current;
    if (!video) return;
    const playVideo = () => {
      const promise = video.play();
      if (promise !== void 0) promise.then(() => {
        video.controls = false;
      }).catch((error) => {
        video.controls = true;
        console.warn("Failed to play video", error);
      });
    };
    const handleCanPlay = () => {
      if (!video.paused) return;
      playVideo();
    };
    const handleEnterPIP = () => {
      video.style.transform = "scale(1)";
    };
    const handleLeavePIP = () => {
      video.style.transform = "";
      setTimeout(() => {
        if (video.paused) playVideo();
      }, 100);
    };
    const handleVisibilityChange = () => {
      if (document.visibilityState === "hidden") return;
      if (!video.paused) return;
      playVideo();
    };
    video.addEventListener("canplay", handleCanPlay);
    video.addEventListener("enterpictureinpicture", handleEnterPIP);
    video.addEventListener("leavepictureinpicture", handleLeavePIP);
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      video.removeEventListener("canplay", handleCanPlay);
      video.removeEventListener("enterpictureinpicture", handleEnterPIP);
      video.removeEventListener("leavepictureinpicture", handleLeavePIP);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, []);
  (0, import_react4.useEffect)(function updateSrcObject() {
    const video = videoEl.current;
    if (!video || !videoTrack) return;
    video.srcObject = new MediaStream([
      videoTrack
    ]);
    video.load();
    return () => {
      video.srcObject = null;
      video.load();
    };
  }, [
    videoTrack,
    videoTrack == null ? void 0 : videoTrack.id
  ]);
  (0, import_react4.useEffect)(function reportVideoDimensions() {
    const video = videoEl.current;
    if (!onResize || !video) return;
    let frame;
    function handleResize() {
      if (frame) cancelAnimationFrame(frame);
      frame = requestAnimationFrame(() => {
        const video2 = videoEl.current;
        if (!video2 || document.hidden) return;
        const videoWidth = video2.videoWidth;
        const videoHeight = video2.videoHeight;
        if (videoWidth && videoHeight) onResize == null ? void 0 : onResize({
          aspectRatio: videoWidth / videoHeight,
          height: videoHeight,
          width: videoWidth
        });
      });
    }
    handleResize();
    video.addEventListener("loadedmetadata", handleResize);
    video.addEventListener("resize", handleResize);
    return () => {
      if (frame) cancelAnimationFrame(frame);
      video.removeEventListener("loadedmetadata", handleResize);
      video.removeEventListener("resize", handleResize);
    };
  }, [
    onResize
  ]);
  return (0, import_jsx_runtime.jsx)("video", {
    autoPlay: true,
    muted: true,
    playsInline: true,
    ref: videoRef,
    style: {
      objectFit: fit,
      transform: mirror ? "scale(-1, 1)" : "",
      ...style
    },
    ...props
  });
});
$6a65deb8615a2ad7$export$85974db6d0cc43b3.displayName = "PipecatClientVideo";
var $f934f1f8b10aaf19$var$availableMicsAtom = (0, atom)([]);
var $f934f1f8b10aaf19$var$availableCamsAtom = (0, atom)([]);
var $f934f1f8b10aaf19$var$availableSpeakersAtom = (0, atom)([]);
var $f934f1f8b10aaf19$var$selectedMicAtom = (0, atom)({});
var $f934f1f8b10aaf19$var$selectedCamAtom = (0, atom)({});
var $f934f1f8b10aaf19$var$selectedSpeakerAtom = (0, atom)({});
var $f934f1f8b10aaf19$export$642bc4d2d2a376f1 = () => {
  const client = (0, $034a56e7ee1b7bed$export$777fa8498be78705)();
  const availableCams = (0, useAtomValue)($f934f1f8b10aaf19$var$availableCamsAtom);
  const availableMics = (0, useAtomValue)($f934f1f8b10aaf19$var$availableMicsAtom);
  const availableSpeakers = (0, useAtomValue)($f934f1f8b10aaf19$var$availableSpeakersAtom);
  const selectedCam = (0, useAtomValue)($f934f1f8b10aaf19$var$selectedCamAtom);
  const selectedMic = (0, useAtomValue)($f934f1f8b10aaf19$var$selectedMicAtom);
  const selectedSpeaker = (0, useAtomValue)($f934f1f8b10aaf19$var$selectedSpeakerAtom);
  const initDevices = (0, useAtomCallback)((0, import_react4.useCallback)(async (_get, set) => {
    if (!client) return;
    const availableCams2 = await client.getAllCams();
    const availableMics2 = await client.getAllMics();
    const availableSpeakers2 = await client.getAllSpeakers();
    set($f934f1f8b10aaf19$var$availableCamsAtom, availableCams2);
    set($f934f1f8b10aaf19$var$availableMicsAtom, availableMics2);
    set($f934f1f8b10aaf19$var$availableSpeakersAtom, availableSpeakers2);
    set($f934f1f8b10aaf19$var$selectedCamAtom, client.selectedCam);
    set($f934f1f8b10aaf19$var$selectedMicAtom, client.selectedMic);
    set($f934f1f8b10aaf19$var$selectedSpeakerAtom, client.selectedSpeaker);
  }, [
    client
  ]));
  (0, import_react4.useEffect)(() => {
    initDevices();
  }, [
    initDevices
  ]);
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableCamsUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, cams) => {
    set($f934f1f8b10aaf19$var$availableCamsAtom, cams);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableMicsUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, mics) => {
    set($f934f1f8b10aaf19$var$availableMicsAtom, mics);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableSpeakersUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, speakers) => {
    set($f934f1f8b10aaf19$var$availableSpeakersAtom, speakers);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).CamUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, cam) => {
    set($f934f1f8b10aaf19$var$selectedCamAtom, cam);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).MicUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, mic) => {
    set($f934f1f8b10aaf19$var$selectedMicAtom, mic);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).SpeakerUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, speaker) => {
    set($f934f1f8b10aaf19$var$selectedSpeakerAtom, speaker);
  }, [])));
  const updateCam = (0, import_react4.useCallback)((id) => {
    client == null ? void 0 : client.updateCam(id);
  }, [
    client
  ]);
  const updateMic = (0, import_react4.useCallback)((id) => {
    client == null ? void 0 : client.updateMic(id);
  }, [
    client
  ]);
  const updateSpeaker = (0, import_react4.useCallback)((id) => {
    client == null ? void 0 : client.updateSpeaker(id);
  }, [
    client
  ]);
  return {
    availableCams,
    availableMics,
    availableSpeakers,
    selectedCam,
    selectedMic,
    selectedSpeaker,
    updateCam,
    updateMic,
    updateSpeaker
  };
};
var $33f3729bbe9f09df$export$30aee278309a867b = () => (0, import_react4.useContext)((0, $a90aa7250c094218$export$db79fdf85ddd6b65));
var $993a744193844a95$export$59bf27bd43679db6 = (0, import_react4.default).memo(({ backgroundColor = "transparent", barColor = "black", barCount = 5, barGap = 12, barLineCap = "round", barMaxHeight = 120, barOrigin = "center", barWidth = 30, participantType }) => {
  const canvasRef = (0, import_react4.useRef)(null);
  const track = (0, $4b4b9099cdb5b776$export$9813dcd2d0c26814)("audio", participantType);
  (0, import_react4.useEffect)(() => {
    if (!canvasRef.current) return;
    const canvasWidth = barCount * barWidth + (barCount - 1) * barGap;
    const canvasHeight = barMaxHeight;
    const canvas = canvasRef.current;
    const scaleFactor = 2;
    const resizeCanvas = () => {
      canvas.width = canvasWidth * scaleFactor;
      canvas.height = canvasHeight * scaleFactor;
      canvas.style.width = `${canvasWidth}px`;
      canvas.style.height = `${canvasHeight}px`;
      canvasCtx.lineCap = barLineCap;
      canvasCtx.scale(scaleFactor, scaleFactor);
    };
    const canvasCtx = canvas.getContext("2d");
    resizeCanvas();
    if (!track) return;
    const audioContext = new AudioContext();
    const source = audioContext.createMediaStreamSource(new MediaStream([
      track
    ]));
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 1024;
    source.connect(analyser);
    const frequencyData = new Uint8Array(analyser.frequencyBinCount);
    canvasCtx.lineCap = barLineCap;
    const bands = Array.from({
      length: barCount
    }, (_, i) => {
      const minFreq = barCount > 20 ? 200 : 80;
      const maxFreq = 1e4;
      const melMin = 2595 * Math.log10(1 + minFreq / 700);
      const melMax = 2595 * Math.log10(1 + maxFreq / 700);
      const melStep = (melMax - melMin) / barCount;
      const melValue = melMin + i * melStep;
      const startFreq = 700 * (Math.pow(10, melValue / 2595) - 1);
      const endFreq = 700 * (Math.pow(10, (melValue + melStep) / 2595) - 1);
      return {
        startFreq,
        endFreq,
        smoothValue: 0
      };
    });
    const getFrequencyBinIndex = (frequency) => {
      const nyquist = audioContext.sampleRate / 2;
      return Math.round(frequency / nyquist * (analyser.frequencyBinCount - 1));
    };
    function drawSpectrum() {
      analyser.getByteFrequencyData(frequencyData);
      canvasCtx.clearRect(0, 0, canvas.width / scaleFactor, canvas.height / scaleFactor);
      canvasCtx.fillStyle = backgroundColor;
      canvasCtx.fillRect(0, 0, canvas.width / scaleFactor, canvas.height / scaleFactor);
      let isActive = false;
      const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
      const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
      const adjustedCircleRadius = barWidth / 2;
      bands.forEach((band, i) => {
        const startIndex = getFrequencyBinIndex(band.startFreq);
        const endIndex = getFrequencyBinIndex(band.endFreq);
        const bandData = frequencyData.slice(startIndex, endIndex);
        const bandValue = bandData.reduce((acc, val) => acc + val, 0) / bandData.length;
        const smoothingFactor = 0.2;
        if (bandValue < 1) band.smoothValue = Math.max(band.smoothValue - smoothingFactor * 5, 0);
        else {
          band.smoothValue = band.smoothValue + (bandValue - band.smoothValue) * smoothingFactor;
          isActive = true;
        }
        const x = startX + i * (barWidth + barGap);
        const minHeight = 0;
        const barHeight = Math.max(minHeight, Math.min(band.smoothValue / 255 * barMaxHeight, barMaxHeight));
        let yTop, yBottom;
        const canvasHeight2 = canvas.height / scaleFactor;
        switch (barOrigin) {
          case "top":
            yTop = adjustedCircleRadius;
            yBottom = Math.min(adjustedCircleRadius + barHeight, canvasHeight2 - adjustedCircleRadius);
            break;
          case "bottom":
            yBottom = canvasHeight2 - adjustedCircleRadius;
            yTop = Math.max(yBottom - barHeight, adjustedCircleRadius);
            break;
          case "center":
          default:
            yTop = Math.max(canvasHeight2 / 2 - barHeight / 2, adjustedCircleRadius);
            yBottom = Math.min(canvasHeight2 / 2 + barHeight / 2, canvasHeight2 - adjustedCircleRadius);
            break;
        }
        if (band.smoothValue > 0) {
          canvasCtx.beginPath();
          canvasCtx.moveTo(x + barWidth / 2, yTop);
          canvasCtx.lineTo(x + barWidth / 2, yBottom);
          canvasCtx.lineWidth = barWidth;
          canvasCtx.strokeStyle = barColor;
          canvasCtx.stroke();
        } else drawInactiveCircle(adjustedCircleRadius, barColor, x, yTop);
      });
      if (!isActive) drawInactiveCircles(adjustedCircleRadius, barColor);
      requestAnimationFrame(drawSpectrum);
    }
    function drawInactiveCircle(circleRadius, color, x, y) {
      switch (barLineCap) {
        case "square":
          canvasCtx.fillStyle = color;
          canvasCtx.fillRect(x + barWidth / 2 - circleRadius, y - circleRadius, circleRadius * 2, circleRadius * 2);
          break;
        case "round":
        default:
          canvasCtx.beginPath();
          canvasCtx.arc(x + barWidth / 2, y, circleRadius, 0, 2 * Math.PI);
          canvasCtx.fillStyle = color;
          canvasCtx.fill();
          canvasCtx.closePath();
          break;
      }
    }
    function drawInactiveCircles(circleRadius, color) {
      const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
      const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
      const canvasHeight2 = canvas.height / scaleFactor;
      let y;
      switch (barOrigin) {
        case "top":
          y = circleRadius;
          break;
        case "bottom":
          y = canvasHeight2 - circleRadius;
          break;
        case "center":
        default:
          y = canvasHeight2 / 2;
          break;
      }
      bands.forEach((_, i) => {
        const x = startX + i * (barWidth + barGap);
        drawInactiveCircle(circleRadius, color, x, y);
      });
    }
    drawSpectrum();
    window.addEventListener("resize", resizeCanvas);
    return () => {
      audioContext.close();
      window.removeEventListener("resize", resizeCanvas);
    };
  }, [
    backgroundColor,
    barColor,
    barCount,
    barGap,
    barLineCap,
    barMaxHeight,
    barOrigin,
    barWidth,
    track
  ]);
  return (0, import_jsx_runtime.jsx)("canvas", {
    ref: canvasRef,
    style: {
      display: "block",
      width: "100%",
      height: "100%"
    }
  });
});
$993a744193844a95$export$59bf27bd43679db6.displayName = "VoiceVisualizer";

export {
  $db6391dc7d757577$export$59b4786f333aac02,
  $db6391dc7d757577$export$e0624a511a2c4e9,
  $db6391dc7d757577$export$bd0820eb8444fcd9,
  $db6391dc7d757577$export$64c9f614187c1e59,
  $c1b4da4af54f4fa1$export$6b4624d233c61fcb,
  $c0d10c4690969999$export$69aa9ab0334b212,
  $e0900798b6cc045b$export$af88d00dbe7f521,
  $d0e914667cc5346b$export$2dd7ca293b2783,
  $d0e914667cc5346b$export$699251e5611cc6db,
  $7ef5cee66c377f4d$export$86495b081fef8e52,
  $364c127d152b1085$export$8f7f86a77535f7a3,
  $824ea64b5f757259$export$33a6ac53b8f02625,
  $d2e362c5a07ee3c5$export$bb43666ced7a20d0,
  $034a56e7ee1b7bed$export$777fa8498be78705,
  $4b4b9099cdb5b776$export$9813dcd2d0c26814,
  $f209aa7ddb77dcb2$export$b52250cb73ff4de1,
  $e76ee2f021b54325$export$3ea2601427f0430f,
  $7cb2ce2c4cbfb401$export$dc9a029eeca8213f,
  $5905c001b0dc8d25$export$388e706586309ef0,
  $2984fdfc31bad375$export$bc8133b69ff660a2,
  $6a65deb8615a2ad7$export$85974db6d0cc43b3,
  $f934f1f8b10aaf19$export$642bc4d2d2a376f1,
  $33f3729bbe9f09df$export$30aee278309a867b,
  $993a744193844a95$export$59bf27bd43679db6
};
/*! Bundled license information:

bowser/src/bowser.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=chunk-MS24FLHN.js.map
