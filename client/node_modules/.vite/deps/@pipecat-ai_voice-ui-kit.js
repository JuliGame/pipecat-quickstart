import {
  $034a56e7ee1b7bed$export$777fa8498be78705,
  $2984fdfc31bad375$export$bc8133b69ff660a2,
  $33f3729bbe9f09df$export$30aee278309a867b,
  $364c127d152b1085$export$8f7f86a77535f7a3,
  $4b4b9099cdb5b776$export$9813dcd2d0c26814,
  $6a65deb8615a2ad7$export$85974db6d0cc43b3,
  $7cb2ce2c4cbfb401$export$dc9a029eeca8213f,
  $7ef5cee66c377f4d$export$86495b081fef8e52,
  $824ea64b5f757259$export$33a6ac53b8f02625,
  $993a744193844a95$export$59bf27bd43679db6,
  $c0d10c4690969999$export$69aa9ab0334b212,
  $c1b4da4af54f4fa1$export$6b4624d233c61fcb,
  $d0e914667cc5346b$export$2dd7ca293b2783,
  $d0e914667cc5346b$export$699251e5611cc6db,
  $d2e362c5a07ee3c5$export$bb43666ced7a20d0,
  $db6391dc7d757577$export$59b4786f333aac02,
  $db6391dc7d757577$export$64c9f614187c1e59,
  $db6391dc7d757577$export$bd0820eb8444fcd9,
  $db6391dc7d757577$export$e0624a511a2c4e9,
  $e0900798b6cc045b$export$af88d00dbe7f521,
  $f209aa7ddb77dcb2$export$b52250cb73ff4de1,
  $f934f1f8b10aaf19$export$642bc4d2d2a376f1
} from "./chunk-MS24FLHN.js";
import {
  require_jsx_runtime
} from "./chunk-MTRSJJBN.js";
import {
  require_react_dom
} from "./chunk-XELL3RXV.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-T4PUX6SL.js";

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports, module) {
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq2 = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq2(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction3(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = (function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    })();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction3 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject2 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    module.exports = arrayEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty = (function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    })();
    module.exports = defineProperty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq2 = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props2, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length = props2.length;
      while (++index2 < length) {
        var key = props2[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports, module) {
    var isArray2 = Array.isArray;
    module.exports = isArray2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    })();
    module.exports = nodeUtil;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction3 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module.exports = baseAssign;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject2 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray(source, array) {
      var index2 = -1, length = source.length;
      array || (array = Array(length));
      while (++index2 < length) {
        array[index2] = source[index2];
      }
      return array;
    }
    module.exports = copyArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module.exports = copySymbols;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset2 = array.length;
      while (++index2 < length) {
        array[offset2 + index2] = values[index2];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray2 = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports, module) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject2 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ (function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    })();
    module.exports = baseCreate;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray2 = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject2 = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props2 = isArr ? void 0 : keysFunc(value);
      arrayEach(props2 || value, function(subValue, key2) {
        if (props2) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/cloneDeep.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module.exports = cloneDeep;
  }
});

// node_modules/.pnpm/@pipecat-ai+voice-ui-kit@0.1.1_@daily-co+daily-js@0.83.1_@pipecat-ai+client-js@1.3.0_@pipecat_khij4yv43apaa6fksg3kmyvpgq/node_modules/@pipecat-ai/voice-ui-kit/dist/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/.pnpm/@pipecat-ai+voice-ui-kit@0.1.1_@daily-co+daily-js@0.83.1_@pipecat-ai+client-js@1.3.0_@pipecat_khij4yv43apaa6fksg3kmyvpgq/node_modules/@pipecat-ai/voice-ui-kit/dist/Metrics-B9xaddk1.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  var _a22;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a22 = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a22.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    classGroups
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const classGroupId in classGroups) {
    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
  }
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var MODIFIER_SEPARATOR = ":";
var MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
var createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + MODIFIER_SEPARATOR_LENGTH;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      } else if (currentCharacter === "(") {
        parenDepth++;
      } else if (currentCharacter === ")") {
        parenDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
      isExternal: true,
      modifiers: [],
      hasImportantModifier: false,
      baseClassName: className,
      maybePostfixModifierPosition: void 0
    };
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
var stripImportantModifier = (baseClassName) => {
  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(0, baseClassName.length - 1);
  }
  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(1);
  }
  return baseClassName;
};
var createSortModifiers = (config) => {
  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
      if (isPositionSensitive) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  return sortModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
var arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
var fractionRegex = /^\d+\/\d+$/;
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isFraction = (value) => fractionRegex.test(value);
var isNumber$1 = (value) => !!value && !Number.isNaN(Number(value));
var isInteger = (value) => !!value && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber$1(value.slice(0, -1));
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var isAny = () => true;
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
var isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
var isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber$1);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
var isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
var isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
var isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
var isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
var isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
var isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
var isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
var isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
var getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
var isLabelPosition = (label) => label === "position" || label === "percentage";
var isLabelImage = (label) => label === "image" || label === "url";
var isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
var isLabelLength = (label) => label === "length";
var isLabelNumber = (label) => label === "number";
var isLabelFamilyName = (label) => label === "family-name";
var isLabelShadow = (label) => label === "shadow";
var getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ];
  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleBgRepeat = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }];
  const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber$1, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleMaskImagePosition = () => [isNumber$1, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleRotate = () => ["none", isNumber$1, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber$1, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber$1, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber$1],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber$1, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: scalePositionWithArbitrary()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber$1, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber$1, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber$1, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber$1, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: scaleBgPosition()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: scaleBgRepeat()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: scaleBgSize()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber$1, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: scaleColor()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber$1, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber$1]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": scaleMaskImagePosition()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": scaleMaskImagePosition()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": scaleColor()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": scaleColor()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": scaleMaskImagePosition()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": scaleMaskImagePosition()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": scaleColor()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": scaleColor()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": scaleMaskImagePosition()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": scaleMaskImagePosition()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": scaleColor()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": scaleColor()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": scaleMaskImagePosition()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": scaleMaskImagePosition()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": scaleColor()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": scaleColor()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": scaleMaskImagePosition()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": scaleMaskImagePosition()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": scaleColor()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": scaleColor()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": scaleMaskImagePosition()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": scaleMaskImagePosition()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": scaleColor()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": scaleColor()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": scaleMaskImagePosition()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": scaleMaskImagePosition()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": scaleColor()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": scaleColor()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": scaleMaskImagePosition()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": scaleMaskImagePosition()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": scaleColor()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": scaleColor()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": scalePosition()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber$1]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": scaleMaskImagePosition()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": scaleMaskImagePosition()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": scaleColor()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": scaleColor()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: scaleBgPosition()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: scaleBgRepeat()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: scaleBgSize()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": scaleColor()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber$1, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber$1, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scalePositionWithArbitrary()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scalePositionWithArbitrary()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber$1, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
};
var twMerge = createTailwindMerge(getDefaultConfig);
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
function round(v2) {
  return v2 + 0.5 | 0;
}
var lim = (v2, l2, h3) => Math.max(Math.min(v2, h3), l2);
function p2b(v2) {
  return lim(round(v2 * 2.55), 0, 255);
}
function n2b(v2) {
  return lim(round(v2 * 255), 0, 255);
}
function b2n(v2) {
  return lim(round(v2 / 2.55) / 100, 0, 1);
}
function n2p(v2) {
  return lim(round(v2 * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b2) => hex[b2 & 15];
var h2 = (b2) => hex[(b2 & 240) >> 4] + hex[b2 & 15];
var eq = (b2) => (b2 & 240) >> 4 === (b2 & 15);
var isShort = (v2) => eq(v2.r) && eq(v2.g) && eq(v2.b) && eq(v2.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a2, f2) => a2 < 255 ? f2(a2) : "";
function hexString(v2) {
  var f2 = isShort(v2) ? h1 : h2;
  return v2 ? "#" + f2(v2.r) + f2(v2.g) + f2(v2.b) + alpha(v2.a, f2) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h3, s2, l2) {
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h3 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  return [f2(0), f2(8), f2(4)];
}
function hsv2rgbn(h3, s2, v2) {
  const f2 = (n2, k2 = (n2 + h3 / 60) % 6) => v2 - v2 * s2 * Math.max(Math.min(k2, 4 - k2, 1), 0);
  return [f2(5), f2(3), f2(1)];
}
function hwb2rgbn(h3, w2, b2) {
  const rgb = hsl2rgbn(h3, 1, 0.5);
  let i2;
  if (w2 + b2 > 1) {
    i2 = 1 / (w2 + b2);
    w2 *= i2;
    b2 *= i2;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] *= 1 - w2 - b2;
    rgb[i2] += w2;
  }
  return rgb;
}
function hueValue(r22, g2, b2, d2, max2) {
  if (r22 === max2) {
    return (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
  }
  if (g2 === max2) {
    return (b2 - r22) / d2 + 2;
  }
  return (r22 - g2) / d2 + 4;
}
function rgb2hsl(v2) {
  const range = 255;
  const r22 = v2.r / range;
  const g2 = v2.g / range;
  const b2 = v2.b / range;
  const max2 = Math.max(r22, g2, b2);
  const min2 = Math.min(r22, g2, b2);
  const l2 = (max2 + min2) / 2;
  let h3, s2, d2;
  if (max2 !== min2) {
    d2 = max2 - min2;
    s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
    h3 = hueValue(r22, g2, b2, d2, max2);
    h3 = h3 * 60 + 0.5;
  }
  return [h3 | 0, s2 || 0, l2];
}
function calln(f2, a2, b2, c2) {
  return (Array.isArray(a2) ? f2(a2[0], a2[1], a2[2]) : f2(a2, b2, c2)).map(n2b);
}
function hsl2rgb(h3, s2, l2) {
  return calln(hsl2rgbn, h3, s2, l2);
}
function hwb2rgb(h3, w2, b2) {
  return calln(hwb2rgbn, h3, w2, b2);
}
function hsv2rgb(h3, s2, v2) {
  return calln(hsv2rgbn, h3, s2, v2);
}
function hue(h3) {
  return (h3 % 360 + 360) % 360;
}
function hueParse(str) {
  const m2 = HUE_RE.exec(str);
  let a2 = 255;
  let v2;
  if (!m2) {
    return;
  }
  if (m2[5] !== v2) {
    a2 = m2[6] ? p2b(+m2[5]) : n2b(+m2[5]);
  }
  const h3 = hue(+m2[2]);
  const p1 = +m2[3] / 100;
  const p2 = +m2[4] / 100;
  if (m2[1] === "hwb") {
    v2 = hwb2rgb(h3, p1, p2);
  } else if (m2[1] === "hsv") {
    v2 = hsv2rgb(h3, p1, p2);
  } else {
    v2 = hsl2rgb(h3, p1, p2);
  }
  return {
    r: v2[0],
    g: v2[1],
    b: v2[2],
    a: a2
  };
}
function rotate(v2, deg) {
  var h3 = rgb2hsl(v2);
  h3[0] = hue(h3[0] + deg);
  h3 = hsl2rgb(h3);
  v2.r = h3[0];
  v2.g = h3[1];
  v2.b = h3[2];
}
function hslString(v2) {
  if (!v2) {
    return;
  }
  const a2 = rgb2hsl(v2);
  const h3 = a2[0];
  const s2 = n2p(a2[1]);
  const l2 = n2p(a2[2]);
  return v2.a < 255 ? `hsla(${h3}, ${s2}%, ${l2}%, ${b2n(v2.a)})` : `hsl(${h3}, ${s2}%, ${l2}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i2, j2, k2, ok, nk;
  for (i2 = 0; i2 < keys.length; i2++) {
    ok = nk = keys[i2];
    for (j2 = 0; j2 < tkeys.length; j2++) {
      k2 = tkeys[j2];
      nk = nk.replace(k2, map[k2]);
    }
    k2 = parseInt(names$1[ok], 16);
    unpacked[nk] = [k2 >> 16 & 255, k2 >> 8 & 255, k2 & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a2 = names[str.toLowerCase()];
  return a2 && {
    r: a2[0],
    g: a2[1],
    b: a2[2],
    a: a2.length === 4 ? a2[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m2 = RGB_RE.exec(str);
  let a2 = 255;
  let r22, g2, b2;
  if (!m2) {
    return;
  }
  if (m2[7] !== r22) {
    const v2 = +m2[7];
    a2 = m2[8] ? p2b(v2) : lim(v2 * 255, 0, 255);
  }
  r22 = +m2[1];
  g2 = +m2[3];
  b2 = +m2[5];
  r22 = 255 & (m2[2] ? p2b(r22) : lim(r22, 0, 255));
  g2 = 255 & (m2[4] ? p2b(g2) : lim(g2, 0, 255));
  b2 = 255 & (m2[6] ? p2b(b2) : lim(b2, 0, 255));
  return {
    r: r22,
    g: g2,
    b: b2,
    a: a2
  };
}
function rgbString(v2) {
  return v2 && (v2.a < 255 ? `rgba(${v2.r}, ${v2.g}, ${v2.b}, ${b2n(v2.a)})` : `rgb(${v2.r}, ${v2.g}, ${v2.b})`);
}
var to = (v2) => v2 <= 31308e-7 ? v2 * 12.92 : Math.pow(v2, 1 / 2.4) * 1.055 - 0.055;
var from = (v2) => v2 <= 0.04045 ? v2 / 12.92 : Math.pow((v2 + 0.055) / 1.055, 2.4);
function interpolate$1(rgb1, rgb2, t2) {
  const r22 = from(b2n(rgb1.r));
  const g2 = from(b2n(rgb1.g));
  const b2 = from(b2n(rgb1.b));
  return {
    r: n2b(to(r22 + t2 * (from(b2n(rgb2.r)) - r22))),
    g: n2b(to(g2 + t2 * (from(b2n(rgb2.g)) - g2))),
    b: n2b(to(b2 + t2 * (from(b2n(rgb2.b)) - b2))),
    a: rgb1.a + t2 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v2, i2, ratio) {
  if (v2) {
    let tmp = rgb2hsl(v2);
    tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v2.r = tmp[0];
    v2.g = tmp[1];
    v2.b = tmp[2];
  }
}
function clone$1(v2, proto) {
  return v2 ? Object.assign(proto || {}, v2) : v2;
}
function fromObject(input) {
  var v2 = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v2 = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v2.a = n2b(input[3]);
      }
    }
  } else {
    v2 = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
    v2.a = n2b(v2.a);
  }
  return v2;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class _Color {
  constructor(input) {
    if (input instanceof _Color) {
      return input;
    }
    const type = typeof input;
    let v2;
    if (type === "object") {
      v2 = fromObject(input);
    } else if (type === "string") {
      v2 = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v2;
    this._valid = !!v2;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v2 = clone$1(this._rgb);
    if (v2) {
      v2.a = b2n(v2.a);
    }
    return v2;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p2 = weight === w2 ? 0.5 : weight;
      const w3 = 2 * p2 - 1;
      const a2 = c1.a - c2.a;
      const w1 = ((w3 * a2 === -1 ? w3 : (w3 + a2) / (1 + w3 * a2)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p2 * c1.a + (1 - p2) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t2) {
    if (color2) {
      this._rgb = interpolate$1(this._rgb, color2._rgb, t2);
    }
    return this;
  }
  clone() {
    return new _Color(this.rgb);
  }
  alpha(a2) {
    this._rgb.a = n2b(a2);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v2 = this._rgb;
    v2.r = 255 - v2.r;
    v2.g = 255 - v2.g;
    v2.b = 255 - v2.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function noop() {
}
var uid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || value === void 0;
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn2, args, thisArg) {
  if (fn2 && typeof fn2.call === "function") {
    return fn2.apply(thisArg, args);
  }
}
function each(loopable, fn2, thisArg, reverse) {
  let i2, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    {
      for (i2 = 0; i2 < len; i2++) {
        fn2.call(thisArg, loopable[i2], i2);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i2 = 0; i2 < len; i2++) {
      fn2.call(thisArg, loopable[keys[i2]], keys[i2]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i2, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
    v0 = a0[i2];
    v1 = a1[i2];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k2 = 0;
    for (; k2 < klen; ++k2) {
      target[keys[k2]] = clone(source[keys[k2]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i2 = 0; i2 < ilen; ++i2) {
    current = sources[i2];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k2 = 0, klen = keys.length; k2 < klen; ++k2) {
      merger(keys[k2], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v2) => v2,
  // default resolvers
  x: (o2) => o2.x,
  y: (o2) => o2.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k2 of keys) {
      if (k2 === "") {
        break;
      }
      obj = obj && obj[k2];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a2, b2) => {
  if (a2.size !== b2.size) {
    return false;
  }
  for (const item of a2) {
    if (!b2.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e2) {
  return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x2, y2, epsilon) {
  return Math.abs(x2 - y2) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i2;
  for (i2 = 1; i2 < sqrt; i2++) {
    if (value % i2 === 0) {
      result.push(i2);
      result.push(value / i2);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a2, b2) => a2 - b2).pop();
  return result;
}
function isNonPrimitive(n2) {
  return typeof n2 === "symbol" || typeof n2 === "object" && n2 !== null && !(Symbol.toPrimitive in n2 || "toString" in n2 || "valueOf" in n2);
}
function isNumber(n2) {
  return !isNonPrimitive(n2) && !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostWhole(x2, epsilon) {
  const rounded = Math.round(x2);
  return rounded - epsilon <= x2 && rounded + epsilon >= x2;
}
function _setMinAndMaxByKey(array, target, property) {
  let i2, ilen, value;
  for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
    value = array[i2][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x2) {
  if (!isNumberFinite(x2)) {
    return;
  }
  let e2 = 1;
  let p2 = 0;
  while (Math.round(x2 * e2) / e2 !== x2) {
    e2 *= 10;
    p2++;
  }
  return p2;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a2, b2) {
  return (a2 - b2 + PITAU) % TAU - PI;
}
function _normalizeAngle(a2) {
  return (a2 % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a2 = _normalizeAngle(angle);
  const s2 = _normalizeAngle(start);
  const e2 = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s2 - a2);
  const angleToEnd = _normalizeAngle(e2 - a2);
  const startToAngle = _normalizeAngle(a2 - s2);
  const endToAngle = _normalizeAngle(a2 - e2);
  return a2 === s2 || a2 === e2 || sameAngleIsFullCircle && s2 === e2 || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi2 = table.length - 1;
  let lo2 = 0;
  let mid;
  while (hi2 - lo2 > 1) {
    mid = lo2 + hi2 >> 1;
    if (cmp(mid)) {
      lo2 = mid;
    } else {
      hi2 = mid;
    }
  }
  return {
    lo: lo2,
    hi: hi2
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti2 = table[index2][key];
  return ti2 < value || ti2 === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min2, max2) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min2) {
    start++;
  }
  while (end > start && values[end - 1] > max2) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = (function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
})();
function throttled(fn2, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn2.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn2, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn2, delay, args);
    } else {
      fn2.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count2 = pointCount;
  if (meta._sorted) {
    const { iScale, vScale, _parsed } = meta;
    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
    const axis = iScale.axis;
    const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min2).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo
      );
      if (spanGaps) {
        const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        start -= Math.max(0, distanceToDefinedLo);
      }
      start = _limitValue(start, 0, pointCount - 1);
    }
    if (maxDefined) {
      let end = Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
      );
      if (spanGaps) {
        const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        end += Math.max(0, distanceToDefinedHi);
      }
      count2 = _limitValue(end, start, pointCount) - start;
    } else {
      count2 = pointCount - start;
    }
  }
  return {
    start,
    count: count2
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t2) => t2 === 0 || t2 === 1;
var elasticIn = (t2, s2, p2) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * TAU / p2));
var elasticOut = (t2, s2, p2) => Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * TAU / p2) + 1;
var effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s2 = 0.1125;
    const p2 = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s2, p2) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s2, p2);
  },
  easeInBack(t2) {
    const s2 = 1.70158;
    return t2 * t2 * ((s2 + 1) * t2 - s2);
  },
  easeOutBack(t2) {
    const s2 = 1.70158;
    return (t2 -= 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
  },
  easeInOutBack(t2) {
    let s2 = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m2 = 7.5625;
    const d2 = 2.75;
    if (t2 < 1 / d2) {
      return m2 * t2 * t2;
    }
    if (t2 < 2 / d2) {
      return m2 * (t2 -= 1.5 / d2) * t2 + 0.75;
    }
    if (t2 < 2.5 / d2) {
      return m2 * (t2 -= 2.25 / d2) * t2 + 0.9375;
    }
    return m2 * (t2 -= 2.625 / d2) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v2) => v2 | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i2 = 0, n2 = keys.length; i2 < n2; ++i2) {
    const k2 = keys[i2];
    node = node[k2] || (node[k2] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc2, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc2.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  if (!ctx && !canvas) {
    return;
  }
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x2, y2) {
  drawPointLegend(ctx, options, x2, y2, null);
}
function drawPointLegend(ctx, options, x2, y2, w2) {
  let type, xOffset, yOffset, size2, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x2, y2);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    // Default includes circle
    default:
      if (w2) {
        ctx.ellipse(x2, y2, w2 / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x2, y2, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w2 ? w2 / 2 : radius;
      ctx.moveTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size2 = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size2;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size2);
      yOffset = Math.sin(rad + QUARTER_PI) * size2;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size2);
      ctx.arc(x2 - xOffsetW, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x2 + yOffsetW, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x2 + xOffsetW, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x2 - yOffsetW, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size2 = Math.SQRT1_2 * radius;
        width = w2 ? w2 / 2 : size2;
        ctx.rect(x2 - width, y2 - size2, 2 * width, 2 * size2);
        break;
      }
      rad += QUARTER_PI;
    /* falls through */
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    /* falls through */
    case "cross":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      break;
    case "line":
      xOffset = w2 ? w2 / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      break;
    case "dash":
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 + Math.cos(rad) * (w2 ? w2 / 2 : radius), y2 + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip2, mode2) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode2 === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode2 === "after" !== !!flip2) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip2) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip2 ? previous.cp1x : previous.cp2x, flip2 ? previous.cp1y : previous.cp2y, flip2 ? target.cp2x : target.cp1x, flip2 ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x2, y2, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x2 - metrics.actualBoundingBoxLeft;
    const right = x2 + metrics.actualBoundingBoxRight;
    const top = y2 - metrics.actualBoundingBoxAscent;
    const bottom = y2 + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x2, y2, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i2, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i2 = 0; i2 < lines.length; ++i2) {
    line = lines[i2];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x2, y2, opts.maxWidth);
    }
    ctx.fillText(line, x2, y2, opts.maxWidth);
    decorateText(ctx, x2, y2, line, opts);
    y2 += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x: x2, y: y2, w: w2, h: h3, radius } = rect;
  ctx.arc(x2 + radius.topLeft, y2 + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x2, y2 + h3 - radius.bottomLeft);
  ctx.arc(x2 + radius.bottomLeft, y2 + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x2 + w2 - radius.bottomRight, y2 + h3);
  ctx.arc(x2 + w2 - radius.bottomRight, y2 + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x2 + w2, y2 + radius.topRight);
  ctx.arc(x2 + w2 - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x2 + radius.topLeft, y2);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size2) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size2 * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size2 * value;
}
var numberOrZero = (v2) => +v2 || 0;
function _readValueToProps(value, props2) {
  const ret = {};
  const objProps = isObject(props2);
  const keys = objProps ? Object.keys(props2) : props2;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props2[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size2 = valueOrDefault(options.size, fallback.size);
  if (typeof size2 === "string") {
    size2 = parseInt(size2, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size2),
    size: size2,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let i2, ilen, value;
  for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
    value = inputs[i2];
    if (value === void 0) {
      continue;
    }
    if (value !== void 0) {
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min: min2, max: max2 } = minmax;
  const change = toDimension(grace, (max2 - min2) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min2, -Math.abs(change)),
    max: keepZero(max2, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k2) => !k2.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa2 = t2 * s01;
  const fb = t2 * s12;
  return {
    previous: {
      x: current.x - fa2 * (next.x - previous.x),
      y: current.y - fa2 * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i2], 0, EPSILON)) {
      mK[i2] = mK[i2 + 1] = 0;
      continue;
    }
    alphaK = mK[i2] / deltaK[i2];
    betaK = mK[i2 + 1] / deltaK[i2];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i2] = alphaK * tauK * deltaK[i2];
    mK[i2 + 1] = betaK * tauK * deltaK[i2];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i2, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt2, min2, max2) {
  return Math.max(Math.min(pt2, max2), min2);
}
function capBezierPoints(points, area) {
  let i2, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i2];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i2, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt2) => !pt2.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      point = points[i2];
      controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle2(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i2 = 0; i2 < 4; i2++) {
    const pos = positions[i2];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x2, y2, target) => (x2 > 0 || y2 > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e2, canvas) {
  const touches = e2.touches;
  const source = touches && touches.length ? touches[0] : e2;
  const { offsetX, offsetY } = source;
  let box = false;
  let x2, y2;
  if (useOffsetPos(offsetX, offsetY, e2.target)) {
    x2 = offsetX;
    y2 = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x2 = source.clientX - rect.left;
    y2 = source.clientY - rect.top;
    box = true;
  }
  return {
    x: x2,
    y: y2,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle2(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x: x2, y: y2, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x2 - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y2 - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v2) => Math.round(v2 * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio2) {
  const style = getComputedStyle2(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio2 ? width / aspectRatio2 : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio2 && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio2));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = (function() {
  let passiveSupported2 = false;
  try {
    const options = {
      get passive() {
        passiveSupported2 = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e2) {
  }
  return passiveSupported2;
})();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t2, mode2) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: p1.y + t2 * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t2, mode2) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: mode2 === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode2 === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t2, mode2) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a2 = _pointInLine(p1, cp1, t2);
  const b2 = _pointInLine(cp1, cp2, t2);
  const c2 = _pointInLine(cp2, p2, t2);
  const d2 = _pointInLine(a2, b2, t2);
  const e2 = _pointInLine(b2, c2, t2);
  return _pointInLine(d2, e2, t2);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x2) {
      return rectX + rectX + width - x2;
    },
    setWidth(w2) {
      width = w2;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x2, value) {
      return x2 - value;
    },
    leftForLtr(x2, itemWidth) {
      return x2 - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x2) {
      return x2;
    },
    setWidth(w2) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x2, value) {
      return x2 + value;
    },
    leftForLtr(x2, _itemWidth) {
      return x2;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a2, b2) => a2 - b2,
    normalize: (x2) => x2
  };
}
function normalizeSegment({ start, end, count: count2, loop, style }) {
  return {
    start: start % count2,
    end: end % count2,
    loop: loop && (end - start + 1) % count2 === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count2 = points.length;
  let { start, end, loop } = segment;
  let i2, ilen;
  if (loop) {
    start += count2;
    end += count2;
    for (i2 = 0, ilen = count2; i2 < ilen; ++i2) {
      if (!between(normalize(points[start % count2][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count2;
    end %= count2;
  }
  if (end < start) {
    end += count2;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count2 = points.length;
  const { compare: compare2, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare2(startBound, prevValue) !== 0;
  const endIsBefore = () => compare2(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i2 = start, prev = start; i2 <= end; ++i2) {
    point = points[i2 % count2];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare2(value, startBound) === 0 ? i2 : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i2,
        loop,
        count: count2,
        style
      }));
      subStart = null;
    }
    prev = i2;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count: count2,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const sub = _boundSegment(segments[i2], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count2, loop, spanGaps) {
  let start = 0;
  let end = count2 - 1;
  if (loop && !spanGaps) {
    while (start < count2 && !points[start].skip) {
      start++;
    }
  }
  while (start < count2 && points[start].skip) {
    start++;
  }
  start %= count2;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count2].skip) {
    end--;
  }
  end %= count2;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max2, loop) {
  const count2 = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max2; ++end) {
    const cur = points[end % count2];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count2,
          end: (end - 1) % count2,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count2,
      end: last % count2,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count2 = points.length;
  if (!count2) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count2, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max2 = end < start ? end + count2 : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count2 - 1;
  return splitByStyles(line, solidSegments(points, start, max2, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count2 = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i2 = start;
  function addStyle(s2, e2, l2, st2) {
    const dir = spanGaps ? -1 : 1;
    if (s2 === e2) {
      return;
    }
    s2 += count2;
    while (points[s2 % count2].skip) {
      s2 -= dir;
    }
    while (points[e2 % count2].skip) {
      e2 += dir;
    }
    if (s2 % count2 !== e2 % count2) {
      result.push({
        start: s2 % count2,
        end: e2 % count2,
        loop: l2,
        style: st2
      });
      prevStyle = st2;
      start = e2 % count2;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count2];
    let style;
    for (i2 = start + 1; i2 <= segment.end; i2++) {
      const pt2 = points[i2 % count2];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt2,
        p0DataIndex: (i2 - 1) % count2,
        p1DataIndex: i2 % count2,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i2 - 1, segment.loop, prevStyle);
      }
      prev = pt2;
      prevStyle = style;
    }
    if (start < i2 - 1) {
      addStyle(start, i2 - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
function getDatasetClipArea(chart, meta) {
  const clip = meta._clip;
  if (clip.disabled) {
    return false;
  }
  const area = getDatasetArea(meta, chart.chartArea);
  return {
    left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
    right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
    top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
    bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
  };
}
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn2) => fn2({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      let draw2 = false;
      let item;
      for (; i2 >= 0; --i2) {
        item = items[i2];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i2] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i2 = items.length - 1;
    for (; i2 >= 0; --i2) {
      items[i2].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to22, factor) {
    return factor > 0.5 ? to22 : from2;
  },
  color(from2, to22, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to22 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to22;
  },
  number(from2, to22, factor) {
    return from2 + (to22 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to22) {
    const currentValue = target[prop];
    to22 = resolve([
      cfg.to,
      to22,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to22
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to22;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to22, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to22,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to22
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to22 = this._to;
    let factor;
    this._active = from2 !== to22 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to22;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to22, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i2 = 0; i2 < promises.length; i2++) {
      promises[i2][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props2 = Object.keys(values);
    const date = Date.now();
    let i2;
    for (i2 = props2.length - 1; i2 >= 0; --i2) {
      const prop = props2[i2];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i2 = 0; i2 < keys.length; i2++) {
    const anim = animations[keys[i2]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min2 = opts.min === void 0 ? allowedOverflow : 0;
  const max2 = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max2 : min2,
    end: reverse ? min2 : max2
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x2 = scaleClip(xScale, allowedOverflow);
  const y2 = scaleClip(yScale, allowedOverflow);
  return {
    top: y2.end,
    right: x2.end,
    bottom: y2.start,
    left: x2.start
  };
}
function toClip(value) {
  let t2, r22, b2, l2;
  if (isObject(value)) {
    t2 = value.top;
    r22 = value.right;
    b2 = value.bottom;
    l2 = value.left;
  } else {
    t2 = r22 = b2 = l2 = value;
  }
  return {
    top: t2,
    right: r22,
    bottom: b2,
    left: l2,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i2, ilen;
  for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    keys.push(metasets[i2].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i2, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  let found = false;
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    datasetIndex = +keys[i2];
    if (datasetIndex === dsIndex) {
      found = true;
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  if (!found && !options.all) {
    return 0;
  }
  return value;
}
function convertObjectDataToArray(data, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i2, ilen, key;
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    key = keys[i2];
    adata[i2] = {
      [iAxisKey]: key,
      [vAxisKey]: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min: min2, max: max2, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max2 : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i2 = 0; i2 < ilen; ++i2) {
    const item = parsed[i2];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode2) => mode2 === "reset" || mode2 === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x2, y2, r22) => axis === "x" ? x2 : axis === "r" ? r22 : y2;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data, meta);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
      meta._stacked = isStacked(meta.vScale, meta);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count2) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count2 === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i2, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count2);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count2);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count2);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i2 = 0; i2 < count2; ++i2) {
        meta._parsed[i2 + start] = cur = parsed[i2];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count2) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count2);
    let i2, ilen, index2;
    for (i2 = 0, ilen = count2; i2 < ilen; ++i2) {
      index2 = i2 + start;
      parsed[i2] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count2) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count2);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count2; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count2) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count2);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count2; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode2) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode: mode2
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i2, parsed;
    function _skip() {
      parsed = _parsed[i2];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i2 = 0; i2 < ilen; ++i2) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i2 = ilen - 1; i2 >= 0; --i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i2, ilen, value;
    for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
      value = parsed[i2][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode2) {
    const meta = this._cachedMeta;
    this.update(mode2 || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode2) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count2 = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i2;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count2);
    }
    for (i2 = start; i2 < start + count2; ++i2) {
      const element = elements[i2];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i2 = 0; i2 < active.length; ++i2) {
      active[i2].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode2 = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode2) : this.resolveDataElementOptions(index2 || 0, mode2);
  }
  getContext(index2, active, mode2) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode2;
    return context;
  }
  resolveDatasetElementOptions(mode2) {
    return this._resolveElementOptions(this.datasetElementType.id, mode2);
  }
  resolveDataElementOptions(index2, mode2) {
    return this._resolveElementOptions(this.dataElementType.id, mode2, index2);
  }
  _resolveElementOptions(elementType, mode2 = "default", index2) {
    const active = mode2 === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode2;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode2);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode2, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode2) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode2) {
    const firstOpts = this.resolveDataElementOptions(start, mode2);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode2, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode2, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode2) {
    if (isDirectUpdateMode(mode2)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode2).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode2, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode2)) {
      this._resolveAnimations(void 0, mode2).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode2, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode2, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count2 = Math.min(numData, numMeta);
    if (count2) {
      this.parse(0, count2);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count2, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count2;
    let i2;
    const move = (arr) => {
      arr.length += count2;
      for (i2 = arr.length - 1; i2 >= end; i2--) {
        arr[i2] = arr[i2 - count2];
      }
    };
    move(data);
    for (i2 = start; i2 < end; ++i2) {
      data[i2] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count2);
    if (resetNewElements) {
      this.updateElements(data, start, count2, "reset");
    }
  }
  updateElements(element, start, count2, mode2) {
  }
  _removeElements(start, count2) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count2);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count2);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count2 = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count2,
      count2
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count2) {
    if (count2) {
      this._sync([
        "_removeElements",
        start,
        count2
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode2) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count: count2 } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count2;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count2 = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode2);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode2);
    this.updateElements(points, start, count2, mode2);
  }
  updateElements(points, start, count2, mode2) {
    const reset = mode2 === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode2);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode2 === "none";
    const end = start + count2;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i2 = 0; i2 < pointsCount; ++i2) {
      const point = points[i2];
      const properties = directUpdate ? point : {};
      if (i2 < start || i2 >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i2);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode2);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode2);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class _DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(_DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      const result = lookupMethod(data, axis, value);
      if (spanGaps) {
        const { vScale } = controller._cachedMeta;
        const { _parsed } = metaset;
        const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.lo -= Math.max(0, distanceToDefinedLo);
        const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.hi += Math.max(0, distanceToDefinedHi);
      }
      return result;
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    const { index: index2, data } = metasets[i2];
    const { lo: lo2, hi: hi2 } = binarySearch(metasets[i2], axis, value, intersect);
    for (let j2 = lo2; j2 <= hi2; ++j2) {
      const element = data[j2];
      if (!element.skip) {
        handler(element, index2, j2);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements;
    },
    dataset(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i2 = 0; i2 < data.length; ++i2) {
          items.push({
            element: data[i2],
            datasetIndex,
            index: i2
          });
        }
      }
      return items;
    },
    point(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v2) => v2.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v2) => STATIC_POSITIONS.indexOf(v2.pos) === -1 && v2.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a2, b2) => {
    const v0 = reverse ? b2 : a2;
    const v1 = reverse ? a2 : b2;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i2, ilen, box, pos, stack, stackWeight;
  for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
    box = boxes[i2];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i2,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i2, ilen, layout;
  for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
    layout = layouts2[i2];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a2, b2) {
  return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b2], chartArea[b2]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i2, ilen, layout, box, refit, changed;
  for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
    layout = boxes[i2];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x: x2, y: y2 } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y2, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
      }
      stack.start = y2;
      stack.placed += width;
      y2 = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x2, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x2, chartArea.top + stack.placed, width, height);
      }
      stack.start = x2;
      stack.placed += height;
      x2 = box.right;
    }
  }
  chartArea.x = x2;
  chartArea.y = y2;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio2) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio2) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio2 ? Math.floor(width / aspectRatio2) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio2) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio2 || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x: x2, y: y2 } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x2 !== void 0 ? x2 : null,
    y: y2 !== void 0 ? y2 : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w2 = container.clientWidth;
    listener(width, height);
    if (w2 < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio2) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio2);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio2) {
    return getMaximumSize(canvas, width, height, aspectRatio2);
  }
  isAttached(canvas) {
    const container = canvas && _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element2 = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x: x2, y: y2 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y2
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props2, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props2.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element2, "defaults", {});
__publicField(Element2, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i2, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
      skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset2 = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
    const factor = factors[i2];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i2, ilen;
  for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
    if (ticks[i2].major) {
      result.push(i2);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count2 = 0;
  let next = majorIndices[0];
  let i2;
  spacing = Math.ceil(spacing);
  for (i2 = 0; i2 < ticks.length; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count2++;
      next = majorIndices[count2 * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count2 = 0;
  let length, i2, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count2++;
    next = Math.round(start + count2 * spacing);
  }
  for (i2 = Math.max(start, 0); i2 < end; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count2++;
      next = Math.round(start + count2 * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i2, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
    if (arr[i2] - arr[i2 - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i2 = 0;
  for (; i2 < len; i2 += increment) {
    result.push(arr[Math.floor(i2)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset2;
  if (offsetGridLines) {
    if (length === 1) {
      offset2 = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset2 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset2 : -offset2;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc2 = cache.gc;
    const gcLen = gc2.length / 2;
    let i2;
    if (gcLen > length) {
      for (i2 = 0; i2 < gcLen; ++i2) {
        delete cache.data[gc2[i2]];
      }
      gc2.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset2, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset2;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
    } else {
      titleY = offsetFromEdge(scale, position, offset2);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset2;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
    } else {
      titleX = offsetFromEdge(scale, position, offset2);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class _Scale extends Element2 {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min: min2,
        max: max2
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      range = metas[i2].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min2 = Math.min(min2, range.min);
      }
      if (!maxDefined) {
        max2 = Math.max(max2, range.max);
      }
    }
    min2 = maxDefined && min2 > max2 ? max2 : min2;
    max2 = minDefined && min2 > max2 ? min2 : max2;
    return {
      min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
      max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      tick = ticks[i2];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i2,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (isNullOrUndef(ticks[i2].label)) {
        ticks.splice(i2, 1);
        ilen--;
        i2--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i2, j2, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i2 = 0; i2 < length; i2 += increment) {
      label = ticks[i2].label;
      tickFont = this._resolveTickFontOptions(i2);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
          nestedLabel = label[j2];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: min2, max: max2 } = this;
    return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w2 = labelSizes ? labelSizes.widest.width + padding : 0;
    const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h3 * cos > w2 * sin ? w2 / cos : h3 / sin : h3 * sin < w2 * cos ? h3 / cos : w2 / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset2 = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset2 ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i2, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i2 = 0; i2 < ticksLength; i2 += step) {
      const context = this.getContext(i2);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i2, offset2);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i2, ilen, tick, label, x2, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y2 = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y2 = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y2 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x2 = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i2));
      pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i2);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x2 = pixel;
        if (textAlign === "inner") {
          if (i2 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i2 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x2 += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y2 = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i2];
        const width = labelSizes.widths[i2];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i2 === ilen - 1) {
              left -= width;
            } else if (i2 > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x2,
            y2
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x2;
    if (position === "left") {
      if (mirror) {
        x2 = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 += widest;
        }
      } else {
        x2 = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x2 = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 -= widest;
        }
      } else {
        x2 = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x: x2
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t2) => t2.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i2, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        const item = items[i2];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y2 = item.textOffset;
      renderText(ctx, label, 0, y2, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset2 = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset2 += padding.bottom;
      if (isArray(title.text)) {
        offset2 += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset2 += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      const meta = metas[i2];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element2, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
      const reg = this._typedRegistries[i2];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a2, b2) => a2.filter((x2) => !b2.some((y2) => x2.plugin.id === y2.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i2 = 0; i2 < keys.length; i2++) {
    plugins.push(registry.getPlugin(keys[i2]));
  }
  const local = config.plugins || [];
  for (let i2 = 0; i2 < local.length; i2++) {
    const plugin = local[i2];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d2) => d2.xAxisID === id || d2.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p2) => !p2.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.5.0";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a2, b2) {
    return a2[l1] === b2[l1] ? a2[l2] - b2[l2] : a2[l1] - b2[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e2.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e2;
}
var Chart$1 = (_a = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode2) => this.update(mode2), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio: aspectRatio2, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio2)) {
      return aspectRatio2;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio2 = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio2);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode2 = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode2)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a2, b2) => a2.index - b2.index);
    if (numMeta > numData) {
      for (let i2 = numData; i2 < numMeta; ++i2) {
        this._destroyDatasetMeta(i2);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i2, ilen;
    this._removeUnreferencedMetasets();
    for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
      const dataset = datasets[i2];
      let meta = this.getDatasetMeta(i2);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i2);
        meta = this.getDatasetMeta(i2);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i2;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i2);
      if (meta.controller) {
        meta.controller.updateIndex(i2);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i2);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode2) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode: mode2,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
      const { controller } = this.getDatasetMeta(i2);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode2);
    this.notifyPlugins("afterUpdate", {
      mode: mode2
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count: count2 } of changes) {
      const move = method === "_removeElements" ? -count2 : count2;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i2 = 1; i2 < datasetCount; i2++) {
      if (!setsEqual(changeSet, makeSet(i2))) {
        return;
      }
    }
    return Array.from(changeSet).map((c2) => c2.split(",")).map((a2) => ({
      method: a2[1],
      start: +a2[2],
      count: +a2[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode2) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: mode2,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this.getDatasetMeta(i2).controller.configure();
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._updateDataset(i2, isFunction(mode2) ? mode2({
        datasetIndex: i2
      }) : mode2);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode: mode2
    });
  }
  _updateDataset(index2, mode2) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode: mode2,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode2);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i2;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null;
      this._resize(width, height);
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i2 < layers.length; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const meta = metasets[i2];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      this._drawDataset(metasets[i2]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    const clip = getDatasetClipArea(this, meta);
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (clip) {
      clipArea(ctx, clip);
    }
    meta.controller.draw();
    if (clip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e2, mode2, options, useFinalPosition) {
    const method = Interaction.modes[mode2];
    if (typeof method === "function") {
      return method(this, e2, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode2 = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode2);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode2 : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i2, ilen;
    this.stop();
    animator.remove(this);
    for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._destroyDatasetMeta(i2);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform2 = this.platform;
    const _add = (type, listener2) => {
      platform2.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e2, x2, y2) => {
      e2.offsetX = x2;
      e2.offsetY = y2;
      this._eventHandler(e2);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform2 = this.platform;
    const _add = (type, listener2) => {
      platform2.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform2.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform2.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode2, enabled2) {
    const prefix = enabled2 ? "set" : "remove";
    let meta, item, i2, ilen;
    if (mode2 === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      item = items[i2];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p2) => p2.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a2, b2) => a2.filter((x2) => !b2.some((y2) => x2.datasetIndex === y2.datasetIndex && x2.index === y2.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e2, replay) {
    const args = {
      event: e2,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e2)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e2.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e2, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e2, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e2);
    const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e2,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e2,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}, __publicField(_a, "defaults", defaults), __publicField(_a, "instances", instances), __publicField(_a, "overrides", overrides), __publicField(_a, "registry", registry), __publicField(_a, "version", version), __publicField(_a, "getChart", getChart), _a);
function invalidatePlugins() {
  return each(Chart$1.instances, (chart) => chart._plugins.invalidate());
}
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count2 = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count2 - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count: count2,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count2 + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count: count2, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i2, point, prev;
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[(start + (reverse ? ilen - i2 : i2)) % count2];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count2];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count: count2, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i2, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count2;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[pointIndex(i2)];
    if (point.skip) {
      continue;
    }
    const x2 = point.x;
    const y2 = point.y;
    const truncX = x2 | 0;
    if (truncX === prevX) {
      if (y2 < minY) {
        minY = y2;
      } else if (y2 > maxY) {
        maxY = y2;
      }
      avgX = (countX * avgX + x2) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x2, y2);
      prevX = truncX;
      countX = 0;
      minY = maxY = y2;
    }
    lastY = y2;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count2) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count2)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count2) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count2 - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count2) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count2);
  } else {
    strokePathDirect(ctx, line, start, count2);
  }
}
var LineElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count2 = segments.length;
    return count2 && points[segments[count2 - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i2, ilen;
    for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
      const { start, end } = segments[i2];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t2, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count2) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count2 = count2 || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count2 - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count2) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count2);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element2 {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x: x2, y: y2 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y2, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y2
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a2, b2) => a2 !== null && b2 !== null && a2.datasetIndex === b2.datasetIndex && a2.index === b2.index;
var Legend = class extends Element2 {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a2, b2) => labelOpts.sort(a2, b2, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i2) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i2] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i2) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i2] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x2, y2, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
        const centerY = y2 + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x2, y2, legendItem) {
      renderText(ctx, legendItem.text, x2, y2 + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i2) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x2 = cursor.x;
      let y2 = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i2 > 0 && x2 + width + padding > this.right) {
          y2 = cursor.y += lineHeight;
          cursor.line++;
          x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i2 > 0 && y2 + lineHeight > this.bottom) {
        x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y2 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x2);
      drawLegendBox(realX, y2, legendItem);
      x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x2), y2, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y2;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y2 = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size2) => Math.max(acc, size2.height), 0);
      y2 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x2 = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x2, y2, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x2, y2) {
    let i2, hitBox, lh;
    if (_isBetween(x2, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i2 = 0; i2 < lh.length; ++i2) {
        hitBox = lh[i2];
        if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i2];
        }
      }
    }
    return null;
  }
  handleEvent(e2) {
    const opts = this.options;
    if (!isListened(e2.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
    if (e2.type === "mousemove" || e2.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e2,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e2,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e2,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a2, b2) => a2.length > b2.length ? a2 : b2);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e2, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element2 {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset2) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset2;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset2;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset2;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset2 = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i2, len;
    let xSet = /* @__PURE__ */ new Set();
    let y2 = 0;
    let count2 = 0;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y2 += pos.y;
        ++count2;
      }
    }
    if (count2 === 0 || xSet.size === 0) {
      return false;
    }
    const xAverage = [
      ...xSet
    ].reduce((a2, b2) => a2 + b2) / xSet.size;
    return {
      x: xAverage,
      y: y2 / count2
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x2 = eventPosition.x;
    let y2 = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i2, len, nearestElement;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d2 = distanceBetweenPoints(eventPosition, center);
        if (d2 < minDistance) {
          minDistance = d2;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x2 = tp.x;
      y2 = tp.y;
    }
    return {
      x: x2,
      y: y2
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count2, bodyItem) => count2 + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size2) {
  const { y: y2, height } = size2;
  if (y2 < height / 2) {
    return "top";
  } else if (y2 > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size2) {
  const { x: x2, width } = size2;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x2 + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x2 - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size2, yAlign) {
  const { x: x2, width } = size2;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x2 <= (left + right) / 2 ? "left" : "right";
  } else if (x2 <= width / 2) {
    xAlign = "left";
  } else if (x2 >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size2)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size2) {
  const yAlign = size2.yAlign || options.yAlign || determineYAlign(chart, size2);
  return {
    xAlign: size2.xAlign || options.xAlign || determineXAlign(chart, options, size2, yAlign),
    yAlign
  };
}
function alignX(size2, xAlign) {
  let { x: x2, width } = size2;
  if (xAlign === "right") {
    x2 -= width;
  } else if (xAlign === "center") {
    x2 -= width / 2;
  }
  return x2;
}
function alignY(size2, yAlign, paddingAndSize) {
  let { y: y2, height } = size2;
  if (yAlign === "top") {
    y2 += paddingAndSize;
  } else if (yAlign === "bottom") {
    y2 -= height + paddingAndSize;
  } else {
    y2 -= height / 2;
  }
  return y2;
}
function getBackgroundPoint(options, size2, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x2 = alignX(size2, xAlign);
  const y2 = alignY(size2, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x2 += paddingAndSize;
    } else if (xAlign === "right") {
      x2 -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x2 -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x2 += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x2, 0, chart.width - size2.width),
    y: _limitValue(y2, 0, chart.height - size2.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element2 {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i2, len;
    for (i2 = 0, len = active.length; i2 < len; ++i2) {
      tooltipItems.push(createTooltipItem(this.chart, active[i2]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a2, b2) => options.itemSort(a2, b2, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size2 = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size2);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size2.width,
        height: size2.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size2, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size2, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size2, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size2;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt2, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(title[i2], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
        pt2.y += titleFont.lineHeight + titleSpacing;
        if (i2 + 1 === length) {
          pt2.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt2, i2, rtlHelper, options) {
    const labelColor = this.labelColors[i2];
    const labelPointStyle = this.labelPointStyles[i2];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt2.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i2];
  }
  drawBody(pt2, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
      pt2.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i2, j2, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt2.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
      bodyItem = body[i2];
      textColor = this.labelTextColors[i2];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt2, i2, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
        fillLineOfText(lines[j2]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt2.y -= bodySpacing;
  }
  drawFooter(pt2, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.footerAlign, options);
      pt2.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(footer[i2], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
        pt2.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt2, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x: x2, y: y2 } = pt2;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x2 + topLeft, y2);
    if (yAlign === "top") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width - topRight, y2);
    ctx.quadraticCurveTo(x2 + width, y2, x2 + width, y2 + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width, y2 + height - bottomRight);
    ctx.quadraticCurveTo(x2 + width, y2 + height, x2 + width - bottomRight, y2 + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + bottomLeft, y2 + height);
    ctx.quadraticCurveTo(x2, y2 + height, x2, y2 + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2, y2 + topLeft);
    ctx.quadraticCurveTo(x2, y2, x2 + topLeft, y2);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size2 = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size2.width;
        this.height = size2.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt2 = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt2, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt2.y += padding.top;
      this.drawTitle(pt2, ctx, options);
      this.drawBody(pt2, ctx, options);
      this.drawFooter(pt2, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e2, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e2);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e2.x,
          y: e2.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e2, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i2) => this.chart.data.datasets[i2.datasetIndex] && this.chart.getDatasetMeta(i2.datasetIndex).controller.getParsed(i2.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e2) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e2);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max2) => index2 === null ? null : _limitValue(Math.round(index2), 0, max2);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min2, max: max2 } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min2 = 0;
      }
      if (!maxDefined) {
        max2 = this.getLabels().length - 1;
      }
    }
    this.min = min2;
    this.max = max2;
  }
  buildTicks() {
    const min2 = this.min;
    const max2 = this.max;
    const offset2 = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min2 === 0 && max2 === labels.length - 1 ? labels : labels.slice(min2, max2 + 1);
    this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
    this._startValue = this.min - (offset2 ? 0.5 : 0);
    for (let value = min2; value <= max2; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min: min2, max: max2, precision, count: count2, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min2);
  const maxDefined = !isNullOrUndef(max2);
  const countDefined = !isNullOrUndef(count2);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
    spacing = (max2 - min2) / numSpaces;
    niceMin = min2;
    niceMax = max2;
  } else if (countDefined) {
    niceMin = minDefined ? min2 : niceMin;
    niceMax = maxDefined ? max2 : niceMax;
    numSpaces = count2 - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j2 = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min2) {
      ticks.push({
        value: min2
      });
      if (niceMin < min2) {
        j2++;
      }
      if (almostEquals(Math.round((niceMin + j2 * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
        j2++;
      }
    } else if (niceMin < min2) {
      j2++;
    }
  }
  for (; j2 < numSpaces; ++j2) {
    const tickValue = Math.round((niceMin + j2 * spacing) * factor) / factor;
    if (maxDefined && tickValue > max2) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max2) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max2;
    } else {
      ticks.push({
        value: max2
      });
    }
  } else if (!maxDefined || niceMax === max2) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min2, max: max2 } = this;
    const setMin = (v2) => min2 = minDefined ? min2 : v2;
    const setMax = (v2) => max2 = maxDefined ? max2 : v2;
    if (beginAtZero) {
      const minSign = sign(min2);
      const maxSign = sign(max2);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min2 === max2) {
      let offset2 = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
      setMax(max2 + offset2);
      if (!beginAtZero) {
        setMin(min2 - offset2);
      }
    }
    this.min = min2;
    this.max = max2;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset2;
      end += offset2;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min: min2, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min2) ? min2 : 0;
    this.max = isNumberFinite(max2) ? max2 : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a2, b2) {
  return a2 - b2;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round22, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round22) {
    value = round22 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round22);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
  const ilen = UNITS.length;
  for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
    const interval = INTERVALS[UNITS[i2]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
      return UNITS[i2];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min2, max2) {
  for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
    const unit = UNITS[i2];
    if (INTERVALS[unit].common && scale._adapter.diff(max2, min2, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
    if (INTERVALS[UNITS[i2]].common) {
      return UNITS[i2];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo: lo2, hi: hi2 } = _lookup(timestamps, time);
    const timestamp = timestamps[lo2] >= time ? timestamps[lo2] : timestamps[hi2];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map2, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map2[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map2 = {};
  const ilen = values.length;
  let i2, value;
  for (i2 = 0; i2 < ilen; ++i2) {
    value = values[i2];
    map2[value] = i2;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props2) {
    super(props2);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min2 = Math.min(min2, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max2 = Math.max(max2, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
    max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min2, max2 - 1);
    this.max = Math.max(min2 + 1, max2);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min2 = Number.POSITIVE_INFINITY;
    let max2 = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min2 = arr[0];
      max2 = arr[arr.length - 1];
    }
    return {
      min: min2,
      max: max2
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min2 = this.min;
    const max2 = this.max;
    const ticks = _filterBetween(timestamps, min2, max2);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min2 = this.min;
    const max2 = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min2;
    let time, count2;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
      throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count2 = 0; time < max2; time = +adapter.add(time, stepSize, minor), count2++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max2 || options.bounds === "ticks" || count2 === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x2) => +x2);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      tick.label = this._tickFormatFunction(tick.value, i2, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size2 = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size2.w : this.height / size2.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
      timestamps.push(parse(this, labels[i2]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate(table, val, reverse) {
  let lo2 = 0;
  let hi2 = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo2].pos && val <= table[hi2].pos) {
      ({ lo: lo2, hi: hi2 } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo2]);
    ({ pos: nextSource, time: nextTarget } = table[hi2]);
  } else {
    if (val >= table[lo2].time && val <= table[hi2].time) {
      ({ lo: lo2, hi: hi2 } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo2]);
    ({ time: nextSource, pos: nextTarget } = table[hi2]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props2) {
    super(props2);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min: min2, max: max2 } = this;
    const items = [];
    const table = [];
    let i2, ilen, prev, curr, next;
    for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
      curr = timestamps[i2];
      if (curr >= min2 && curr <= max2) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min2,
          pos: 0
        },
        {
          time: max2,
          pos: 1
        }
      ];
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      next = items[i2 + 1];
      prev = items[i2 - 1];
      curr = items[i2];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i2 / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min2 = this.min;
    const max2 = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min2) || !timestamps.length) {
      timestamps.splice(0, 0, min2);
    }
    if (!timestamps.includes(max2) || timestamps.length === 1) {
      timestamps.push(max2);
    }
    return timestamps.sort((a2, b2) => a2 - b2);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var defaultDatasetIdKey = "label";
function reforwardRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function setOptions(chart, nextOptions) {
  const options = chart.options;
  if (options && nextOptions) {
    Object.assign(options, nextOptions);
  }
}
function setLabels(currentData, nextLabels) {
  currentData.labels = nextLabels;
}
function setDatasets(currentData, nextDatasets) {
  let datasetIdKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultDatasetIdKey;
  const addedDatasets = [];
  currentData.datasets = nextDatasets.map((nextDataset) => {
    const currentDataset = currentData.datasets.find((dataset) => dataset[datasetIdKey] === nextDataset[datasetIdKey]);
    if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
      return {
        ...nextDataset
      };
    }
    addedDatasets.push(currentDataset);
    Object.assign(currentDataset, nextDataset);
    return currentDataset;
  });
}
function cloneData(data) {
  let datasetIdKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultDatasetIdKey;
  const nextData = {
    labels: [],
    datasets: []
  };
  setLabels(nextData, data.labels);
  setDatasets(nextData, data.datasets, datasetIdKey);
  return nextData;
}
function ChartComponent(props2, ref) {
  const { height = 150, width = 300, redraw = false, datasetIdKey, type, data, options, plugins = [], fallbackContent, updateMode, ...canvasProps } = props2;
  const canvasRef = (0, import_react.useRef)(null);
  const chartRef = (0, import_react.useRef)(null);
  const renderChart = () => {
    if (!canvasRef.current) return;
    chartRef.current = new Chart$1(canvasRef.current, {
      type,
      data: cloneData(data, datasetIdKey),
      options: options && {
        ...options
      },
      plugins
    });
    reforwardRef(ref, chartRef.current);
  };
  const destroyChart = () => {
    reforwardRef(ref, null);
    if (chartRef.current) {
      chartRef.current.destroy();
      chartRef.current = null;
    }
  };
  (0, import_react.useEffect)(() => {
    if (!redraw && chartRef.current && options) {
      setOptions(chartRef.current, options);
    }
  }, [
    redraw,
    options
  ]);
  (0, import_react.useEffect)(() => {
    if (!redraw && chartRef.current) {
      setLabels(chartRef.current.config.data, data.labels);
    }
  }, [
    redraw,
    data.labels
  ]);
  (0, import_react.useEffect)(() => {
    if (!redraw && chartRef.current && data.datasets) {
      setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);
    }
  }, [
    redraw,
    data.datasets
  ]);
  (0, import_react.useEffect)(() => {
    if (!chartRef.current) return;
    if (redraw) {
      destroyChart();
      setTimeout(renderChart);
    } else {
      chartRef.current.update(updateMode);
    }
  }, [
    redraw,
    options,
    data.labels,
    data.datasets,
    updateMode
  ]);
  (0, import_react.useEffect)(() => {
    if (!chartRef.current) return;
    destroyChart();
    setTimeout(renderChart);
  }, [
    type
  ]);
  (0, import_react.useEffect)(() => {
    renderChart();
    return () => destroyChart();
  }, []);
  return import_react.default.createElement("canvas", {
    ref: canvasRef,
    role: "img",
    height,
    width,
    ...canvasProps
  }, fallbackContent);
}
var Chart = (0, import_react.forwardRef)(ChartComponent);
function createTypedChart(type, registerables) {
  Chart$1.register(registerables);
  return (0, import_react.forwardRef)((props2, ref) => import_react.default.createElement(Chart, {
    ...props2,
    ref,
    type
  }));
}
var Line = createTypedChart("line", LineController);
Chart$1.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  plugin_title,
  plugin_tooltip,
  plugin_legend
);
var Metrics = ({
  chartOptions = {},
  classNames = {},
  ignoreProcessorNames = [],
  noPromptTokens = false,
  noCompletionTokens = false,
  noTotalTokens = false
}) => {
  const [metrics, setMetrics] = (0, import_react.useState)({});
  const [tokenMetrics, setTokenMetrics] = (0, import_react.useState)({});
  const transportState = $33f3729bbe9f09df$export$30aee278309a867b();
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.Connected, () => {
    setMetrics({});
    setTokenMetrics({
      completion_tokens: 0,
      prompt_tokens: 0,
      total_tokens: 0
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.Metrics, (data) => {
    if ((data == null ? void 0 : data.processing) && Array.isArray(data.processing)) {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString();
      setMetrics((prevMetrics) => {
        const newMetrics = { ...prevMetrics };
        (data.processing ?? []).forEach((item) => {
          const { processor, value } = item;
          if (ignoreProcessorNames.includes(processor)) {
            return;
          }
          if (!newMetrics[processor]) {
            newMetrics[processor] = [];
          }
          const updatedMetrics = [
            ...newMetrics[processor],
            { timestamp, value }
          ].slice(-100);
          newMetrics[processor] = updatedMetrics;
        });
        return newMetrics;
      });
    }
    const tokens = data == null ? void 0 : data.tokens;
    if (tokens && Array.isArray(tokens) && tokens.length > 0) {
      const tokenData = tokens[0];
      setTokenMetrics((prev) => ({
        completion_tokens: prev.completion_tokens + (noCompletionTokens ? 0 : tokenData.completion_tokens || 0),
        prompt_tokens: prev.prompt_tokens + (noPromptTokens ? 0 : tokenData.prompt_tokens || 0),
        total_tokens: prev.total_tokens + (noTotalTokens ? 0 : tokenData.total_tokens || 0)
      }));
    }
  });
  const generateChartData = (processorName, data) => {
    return {
      labels: data.map((d2) => {
        const date = new Date(d2.timestamp);
        return `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.${date.getMilliseconds()}`;
      }),
      datasets: [
        {
          label: `TTFB (${processorName})`,
          data: data.map((d2) => d2.value * 1e3),
          // Convert to ms for better readability
          borderColor: getColorForProcessor(processorName),
          backgroundColor: getColorForProcessor(processorName, 0.2),
          tension: 0.4
        }
      ]
    };
  };
  const getColorForProcessor = (processor, alpha2 = 1) => {
    const hash = processor.split("").reduce((acc, char) => {
      return char.charCodeAt(0) + ((acc << 5) - acc);
    }, 0);
    const h3 = Math.abs(hash) % 360;
    return `hsla(${h3}, 70%, 50%, ${alpha2})`;
  };
  const lineChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
      y: {
        title: {
          display: true,
          text: "Time (ms)"
        },
        beginAtZero: true
      },
      x: {
        title: {
          display: true,
          text: "Time"
        },
        ticks: {
          maxRotation: 0,
          autoSkip: true,
          maxTicksLimit: 10
        }
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          label: function(context) {
            return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} ms`;
          }
        }
      }
    },
    ...chartOptions
  };
  const isConnecting = transportState === "authenticating" || transportState === "connecting";
  const isConnected = transportState === "connected" || transportState === "ready";
  const hasTokenMetrics = Object.keys(tokenMetrics).length > 0;
  const hasMetrics = Object.keys(metrics).length > 0;
  const tokenCardClassName = cn(
    "vkui:bg-card vkui:rounded-md vkui:p-3 vkui:shadow-sm",
    classNames.tokenCard
  );
  const tokenTypeClassName = cn(
    "vkui:text-sm vkui:text-muted-foreground",
    classNames.tokenType
  );
  const tokenValueClassName = cn(
    "vkui:text-2xl vkui:font-medium",
    classNames.tokenValue
  );
  if (hasMetrics || hasTokenMetrics) {
    return (0, import_jsx_runtime.jsxs)(
      "div",
      {
        className: cn(
          "vkui:@container/metrics vkui:grid vkui:gap-6 vkui:items-start vkui:p-4 vkui:max-h-full vkui:overflow-auto",
          classNames.container
        ),
        children: [
          hasTokenMetrics && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
            (0, import_jsx_runtime.jsx)(
              "h2",
              {
                className: cn(
                  "vkui:text-xl vkui:font-semibold",
                  classNames.heading
                ),
                children: "Token Usage"
              }
            ),
            (0, import_jsx_runtime.jsxs)(
              "div",
              {
                className: cn(
                  "vkui:grid vkui:grid-cols-1 vkui:@xl/metrics:grid-cols-2 vkui:@3xl/metrics:grid-cols-3 vkui:gap-4",
                  classNames.tokenContainer
                ),
                children: [
                  !noPromptTokens && (0, import_jsx_runtime.jsxs)("div", { className: tokenCardClassName, children: [
                    (0, import_jsx_runtime.jsx)("div", { className: tokenTypeClassName, children: "Prompt Tokens" }),
                    (0, import_jsx_runtime.jsx)("div", { className: tokenValueClassName, children: tokenMetrics.prompt_tokens })
                  ] }),
                  !noCompletionTokens && (0, import_jsx_runtime.jsxs)("div", { className: tokenCardClassName, children: [
                    (0, import_jsx_runtime.jsx)("div", { className: tokenTypeClassName, children: "Completion Tokens" }),
                    (0, import_jsx_runtime.jsx)("div", { className: tokenValueClassName, children: tokenMetrics.completion_tokens })
                  ] }),
                  !noTotalTokens && (0, import_jsx_runtime.jsxs)("div", { className: tokenCardClassName, children: [
                    (0, import_jsx_runtime.jsx)("div", { className: tokenTypeClassName, children: "Total Tokens" }),
                    (0, import_jsx_runtime.jsx)("div", { className: tokenValueClassName, children: tokenMetrics.total_tokens })
                  ] })
                ]
              }
            )
          ] }),
          hasMetrics && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
            (0, import_jsx_runtime.jsx)(
              "h2",
              {
                className: cn(
                  "vkui:text-xl vkui:font-semibold",
                  classNames.heading
                ),
                children: "TTFB Metrics"
              }
            ),
            (0, import_jsx_runtime.jsx)(
              "div",
              {
                className: cn(
                  "vkui:grid vkui:grid-cols-1 vkui:@xl/metrics:grid-cols-2 vkui:@3xl/metrics:grid-cols-3 vkui:gap-4",
                  classNames.metricsContainer
                ),
                children: Object.entries(metrics).map(([processorName, data]) => (0, import_jsx_runtime.jsxs)(
                  "div",
                  {
                    className: cn(
                      "vkui:bg-card vkui:border vkui:rounded-lg vkui:shadow-sm vkui:p-3 vkui:h-60",
                      classNames.metricsCard
                    ),
                    children: [
                      (0, import_jsx_runtime.jsx)("h3", { className: cn("vkui:mb-2", classNames.metricsTitle), children: processorName }),
                      (0, import_jsx_runtime.jsx)("div", { className: cn("vkui:h-44", classNames.metricsChart), children: (0, import_jsx_runtime.jsx)(
                        Line,
                        {
                          data: generateChartData(processorName, data),
                          options: lineChartOptions
                        }
                      ) })
                    ]
                  },
                  processorName
                ))
              }
            )
          ] })
        ]
      }
    );
  }
  if (isConnecting) {
    return (0, import_jsx_runtime.jsx)(
      "div",
      {
        className: cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:text-muted-foreground vkui:text-sm",
          classNames.container
        ),
        children: "Connecting to agent..."
      }
    );
  }
  if (!isConnected) {
    return (0, import_jsx_runtime.jsx)(
      "div",
      {
        className: cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:text-muted-foreground vkui:text-center",
          classNames.container
        ),
        children: (0, import_jsx_runtime.jsxs)("div", { className: "vkui:p-4", children: [
          (0, import_jsx_runtime.jsx)("div", { className: "vkui:mb-2", children: "Not connected to agent" }),
          (0, import_jsx_runtime.jsx)("p", { className: "vkui:text-sm vkui:max-w-md", children: "Connect to an agent to view metrics in real-time." })
        ] })
      }
    );
  }
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      className: cn(
        "vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:text-muted-foreground vkui:text-sm",
        classNames.container
      ),
      children: "Waiting for metrics data..."
    }
  );
};

// node_modules/.pnpm/@daily-co+daily-js@0.83.1/node_modules/@daily-co/daily-js/dist/daily-esm.js
function e(e2, t2) {
  if (null == e2) return {};
  var n2, r3, i2 = (function(e3, t3) {
    if (null == e3) return {};
    var n3 = {};
    for (var r4 in e3) if ({}.hasOwnProperty.call(e3, r4)) {
      if (-1 !== t3.indexOf(r4)) continue;
      n3[r4] = e3[r4];
    }
    return n3;
  })(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    for (r3 = 0; r3 < o2.length; r3++) n2 = o2[r3], -1 === t2.indexOf(n2) && {}.propertyIsEnumerable.call(e2, n2) && (i2[n2] = e2[n2]);
  }
  return i2;
}
function t(e2, t2) {
  if (!(e2 instanceof t2)) throw new TypeError("Cannot call a class as a function");
}
function n(e2) {
  return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  }, n(e2);
}
function r2(e2) {
  var t2 = (function(e3, t3) {
    if ("object" != n(e3) || !e3) return e3;
    var r3 = e3[Symbol.toPrimitive];
    if (void 0 !== r3) {
      var i2 = r3.call(e3, t3 || "default");
      if ("object" != n(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t3 ? String : Number)(e3);
  })(e2, "string");
  return "symbol" == n(t2) ? t2 : t2 + "";
}
function i(e2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var i2 = t2[n2];
    i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, r2(i2.key), i2);
  }
}
function o(e2, t2, n2) {
  return t2 && i(e2.prototype, t2), n2 && i(e2, n2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function s(e2, t2) {
  if (t2 && ("object" == n(t2) || "function" == typeof t2)) return t2;
  if (void 0 !== t2) throw new TypeError("Derived constructors may only return object or undefined");
  return (function(e3) {
    if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  })(e2);
}
function a(e2) {
  return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e3) {
    return e3.__proto__ || Object.getPrototypeOf(e3);
  }, a(e2);
}
function c(e2, t2) {
  return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
    return e3.__proto__ = t3, e3;
  }, c(e2, t2);
}
function l(e2, t2) {
  if ("function" != typeof t2 && null !== t2) throw new TypeError("Super expression must either be null or a function");
  e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t2 && c(e2, t2);
}
function u(e2, t2, n2) {
  return (t2 = r2(t2)) in e2 ? Object.defineProperty(e2, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t2] = n2, e2;
}
function d(e2, t2, n2, r3, i2, o2, s2) {
  try {
    var a2 = e2[o2](s2), c2 = a2.value;
  } catch (e3) {
    return void n2(e3);
  }
  a2.done ? t2(c2) : Promise.resolve(c2).then(r3, i2);
}
function p(e2) {
  return function() {
    var t2 = this, n2 = arguments;
    return new Promise((function(r3, i2) {
      var o2 = e2.apply(t2, n2);
      function s2(e3) {
        d(o2, r3, i2, s2, a2, "next", e3);
      }
      function a2(e3) {
        d(o2, r3, i2, s2, a2, "throw", e3);
      }
      s2(void 0);
    }));
  };
}
function h(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r3 = Array(t2); n2 < t2; n2++) r3[n2] = e2[n2];
  return r3;
}
function f(e2, t2) {
  return (function(e3) {
    if (Array.isArray(e3)) return e3;
  })(e2) || (function(e3, t3) {
    var n2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
    if (null != n2) {
      var r3, i2, o2, s2, a2 = [], c2 = true, l2 = false;
      try {
        if (o2 = (n2 = n2.call(e3)).next, 0 === t3) {
          if (Object(n2) !== n2) return;
          c2 = false;
        } else for (; !(c2 = (r3 = o2.call(n2)).done) && (a2.push(r3.value), a2.length !== t3); c2 = true) ;
      } catch (e4) {
        l2 = true, i2 = e4;
      } finally {
        try {
          if (!c2 && null != n2.return && (s2 = n2.return(), Object(s2) !== s2)) return;
        } finally {
          if (l2) throw i2;
        }
      }
      return a2;
    }
  })(e2, t2) || (function(e3, t3) {
    if (e3) {
      if ("string" == typeof e3) return h(e3, t3);
      var n2 = {}.toString.call(e3).slice(8, -1);
      return "Object" === n2 && e3.constructor && (n2 = e3.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e3) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? h(e3, t3) : void 0;
    }
  })(e2, t2) || (function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  })();
}
function v(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
var g;
var m = { exports: {} };
var y = (function() {
  if (g) return m.exports;
  g = 1;
  var e2, t2 = "object" == typeof Reflect ? Reflect : null, n2 = t2 && "function" == typeof t2.apply ? t2.apply : function(e3, t3, n3) {
    return Function.prototype.apply.call(e3, t3, n3);
  };
  e2 = t2 && "function" == typeof t2.ownKeys ? t2.ownKeys : Object.getOwnPropertySymbols ? function(e3) {
    return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));
  } : function(e3) {
    return Object.getOwnPropertyNames(e3);
  };
  var r3 = Number.isNaN || function(e3) {
    return e3 != e3;
  };
  function i2() {
    i2.init.call(this);
  }
  m.exports = i2, m.exports.once = function(e3, t3) {
    return new Promise((function(n3, r4) {
      function i3(n4) {
        e3.removeListener(t3, o3), r4(n4);
      }
      function o3() {
        "function" == typeof e3.removeListener && e3.removeListener("error", i3), n3([].slice.call(arguments));
      }
      f2(e3, t3, o3, { once: true }), "error" !== t3 && (function(e4, t4, n4) {
        "function" == typeof e4.on && f2(e4, "error", t4, n4);
      })(e3, i3, { once: true });
    }));
  }, i2.EventEmitter = i2, i2.prototype._events = void 0, i2.prototype._eventsCount = 0, i2.prototype._maxListeners = void 0;
  var o2 = 10;
  function s2(e3) {
    if ("function" != typeof e3) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e3);
  }
  function a2(e3) {
    return void 0 === e3._maxListeners ? i2.defaultMaxListeners : e3._maxListeners;
  }
  function c2(e3, t3, n3, r4) {
    var i3, o3, c3, l3;
    if (s2(n3), void 0 === (o3 = e3._events) ? (o3 = e3._events = /* @__PURE__ */ Object.create(null), e3._eventsCount = 0) : (void 0 !== o3.newListener && (e3.emit("newListener", t3, n3.listener ? n3.listener : n3), o3 = e3._events), c3 = o3[t3]), void 0 === c3) c3 = o3[t3] = n3, ++e3._eventsCount;
    else if ("function" == typeof c3 ? c3 = o3[t3] = r4 ? [n3, c3] : [c3, n3] : r4 ? c3.unshift(n3) : c3.push(n3), (i3 = a2(e3)) > 0 && c3.length > i3 && !c3.warned) {
      c3.warned = true;
      var u3 = new Error("Possible EventEmitter memory leak detected. " + c3.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u3.name = "MaxListenersExceededWarning", u3.emitter = e3, u3.type = t3, u3.count = c3.length, l3 = u3, console && console.warn && console.warn(l3);
    }
    return e3;
  }
  function l2() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function u2(e3, t3, n3) {
    var r4 = { fired: false, wrapFn: void 0, target: e3, type: t3, listener: n3 }, i3 = l2.bind(r4);
    return i3.listener = n3, r4.wrapFn = i3, i3;
  }
  function d2(e3, t3, n3) {
    var r4 = e3._events;
    if (void 0 === r4) return [];
    var i3 = r4[t3];
    return void 0 === i3 ? [] : "function" == typeof i3 ? n3 ? [i3.listener || i3] : [i3] : n3 ? (function(e4) {
      for (var t4 = new Array(e4.length), n4 = 0; n4 < t4.length; ++n4) t4[n4] = e4[n4].listener || e4[n4];
      return t4;
    })(i3) : h3(i3, i3.length);
  }
  function p2(e3) {
    var t3 = this._events;
    if (void 0 !== t3) {
      var n3 = t3[e3];
      if ("function" == typeof n3) return 1;
      if (void 0 !== n3) return n3.length;
    }
    return 0;
  }
  function h3(e3, t3) {
    for (var n3 = new Array(t3), r4 = 0; r4 < t3; ++r4) n3[r4] = e3[r4];
    return n3;
  }
  function f2(e3, t3, n3, r4) {
    if ("function" == typeof e3.on) r4.once ? e3.once(t3, n3) : e3.on(t3, n3);
    else {
      if ("function" != typeof e3.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e3);
      e3.addEventListener(t3, (function i3(o3) {
        r4.once && e3.removeEventListener(t3, i3), n3(o3);
      }));
    }
  }
  return Object.defineProperty(i2, "defaultMaxListeners", { enumerable: true, get: function() {
    return o2;
  }, set: function(e3) {
    if ("number" != typeof e3 || e3 < 0 || r3(e3)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e3 + ".");
    o2 = e3;
  } }), i2.init = function() {
    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, i2.prototype.setMaxListeners = function(e3) {
    if ("number" != typeof e3 || e3 < 0 || r3(e3)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
    return this._maxListeners = e3, this;
  }, i2.prototype.getMaxListeners = function() {
    return a2(this);
  }, i2.prototype.emit = function(e3) {
    for (var t3 = [], r4 = 1; r4 < arguments.length; r4++) t3.push(arguments[r4]);
    var i3 = "error" === e3, o3 = this._events;
    if (void 0 !== o3) i3 = i3 && void 0 === o3.error;
    else if (!i3) return false;
    if (i3) {
      var s3;
      if (t3.length > 0 && (s3 = t3[0]), s3 instanceof Error) throw s3;
      var a3 = new Error("Unhandled error." + (s3 ? " (" + s3.message + ")" : ""));
      throw a3.context = s3, a3;
    }
    var c3 = o3[e3];
    if (void 0 === c3) return false;
    if ("function" == typeof c3) n2(c3, this, t3);
    else {
      var l3 = c3.length, u3 = h3(c3, l3);
      for (r4 = 0; r4 < l3; ++r4) n2(u3[r4], this, t3);
    }
    return true;
  }, i2.prototype.addListener = function(e3, t3) {
    return c2(this, e3, t3, false);
  }, i2.prototype.on = i2.prototype.addListener, i2.prototype.prependListener = function(e3, t3) {
    return c2(this, e3, t3, true);
  }, i2.prototype.once = function(e3, t3) {
    return s2(t3), this.on(e3, u2(this, e3, t3)), this;
  }, i2.prototype.prependOnceListener = function(e3, t3) {
    return s2(t3), this.prependListener(e3, u2(this, e3, t3)), this;
  }, i2.prototype.removeListener = function(e3, t3) {
    var n3, r4, i3, o3, a3;
    if (s2(t3), void 0 === (r4 = this._events)) return this;
    if (void 0 === (n3 = r4[e3])) return this;
    if (n3 === t3 || n3.listener === t3) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r4[e3], r4.removeListener && this.emit("removeListener", e3, n3.listener || t3));
    else if ("function" != typeof n3) {
      for (i3 = -1, o3 = n3.length - 1; o3 >= 0; o3--) if (n3[o3] === t3 || n3[o3].listener === t3) {
        a3 = n3[o3].listener, i3 = o3;
        break;
      }
      if (i3 < 0) return this;
      0 === i3 ? n3.shift() : (function(e4, t4) {
        for (; t4 + 1 < e4.length; t4++) e4[t4] = e4[t4 + 1];
        e4.pop();
      })(n3, i3), 1 === n3.length && (r4[e3] = n3[0]), void 0 !== r4.removeListener && this.emit("removeListener", e3, a3 || t3);
    }
    return this;
  }, i2.prototype.off = i2.prototype.removeListener, i2.prototype.removeAllListeners = function(e3) {
    var t3, n3, r4;
    if (void 0 === (n3 = this._events)) return this;
    if (void 0 === n3.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e3] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e3]), this;
    if (0 === arguments.length) {
      var i3, o3 = Object.keys(n3);
      for (r4 = 0; r4 < o3.length; ++r4) "removeListener" !== (i3 = o3[r4]) && this.removeAllListeners(i3);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if ("function" == typeof (t3 = n3[e3])) this.removeListener(e3, t3);
    else if (void 0 !== t3) for (r4 = t3.length - 1; r4 >= 0; r4--) this.removeListener(e3, t3[r4]);
    return this;
  }, i2.prototype.listeners = function(e3) {
    return d2(this, e3, true);
  }, i2.prototype.rawListeners = function(e3) {
    return d2(this, e3, false);
  }, i2.listenerCount = function(e3, t3) {
    return "function" == typeof e3.listenerCount ? e3.listenerCount(t3) : p2.call(e3, t3);
  }, i2.prototype.listenerCount = p2, i2.prototype.eventNames = function() {
    return this._eventsCount > 0 ? e2(this._events) : [];
  }, m.exports;
})();
var b = v(y);
var _ = Object.prototype.hasOwnProperty;
function w(e2, t2, n2) {
  for (n2 of e2.keys()) if (S(n2, t2)) return n2;
}
function S(e2, t2) {
  var n2, r3, i2;
  if (e2 === t2) return true;
  if (e2 && t2 && (n2 = e2.constructor) === t2.constructor) {
    if (n2 === Date) return e2.getTime() === t2.getTime();
    if (n2 === RegExp) return e2.toString() === t2.toString();
    if (n2 === Array) {
      if ((r3 = e2.length) === t2.length) for (; r3-- && S(e2[r3], t2[r3]); ) ;
      return -1 === r3;
    }
    if (n2 === Set) {
      if (e2.size !== t2.size) return false;
      for (r3 of e2) {
        if ((i2 = r3) && "object" == typeof i2 && !(i2 = w(t2, i2))) return false;
        if (!t2.has(i2)) return false;
      }
      return true;
    }
    if (n2 === Map) {
      if (e2.size !== t2.size) return false;
      for (r3 of e2) {
        if ((i2 = r3[0]) && "object" == typeof i2 && !(i2 = w(t2, i2))) return false;
        if (!S(r3[1], t2.get(i2))) return false;
      }
      return true;
    }
    if (n2 === ArrayBuffer) e2 = new Uint8Array(e2), t2 = new Uint8Array(t2);
    else if (n2 === DataView) {
      if ((r3 = e2.byteLength) === t2.byteLength) for (; r3-- && e2.getInt8(r3) === t2.getInt8(r3); ) ;
      return -1 === r3;
    }
    if (ArrayBuffer.isView(e2)) {
      if ((r3 = e2.byteLength) === t2.byteLength) for (; r3-- && e2[r3] === t2[r3]; ) ;
      return -1 === r3;
    }
    if (!n2 || "object" == typeof e2) {
      for (n2 in r3 = 0, e2) {
        if (_.call(e2, n2) && ++r3 && !_.call(t2, n2)) return false;
        if (!(n2 in t2) || !S(e2[n2], t2[n2])) return false;
      }
      return Object.keys(t2).length === r3;
    }
  }
  return e2 != e2 && t2 != t2;
}
var k = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
var M = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
var C = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
var E = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
var T = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
var O = class _O {
  static getFirstMatch(e2, t2) {
    const n2 = t2.match(e2);
    return n2 && n2.length > 0 && n2[1] || "";
  }
  static getSecondMatch(e2, t2) {
    const n2 = t2.match(e2);
    return n2 && n2.length > 1 && n2[2] || "";
  }
  static matchAndReturnConst(e2, t2, n2) {
    if (e2.test(t2)) return n2;
  }
  static getWindowsVersionName(e2) {
    switch (e2) {
      case "NT":
        return "NT";
      case "XP":
      case "NT 5.1":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  static getMacOSVersionName(e2) {
    const t2 = e2.split(".").splice(0, 2).map(((e3) => parseInt(e3, 10) || 0));
    if (t2.push(0), 10 === t2[0]) switch (t2[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return;
    }
  }
  static getAndroidVersionName(e2) {
    const t2 = e2.split(".").splice(0, 2).map(((e3) => parseInt(e3, 10) || 0));
    if (t2.push(0), !(1 === t2[0] && t2[1] < 5)) return 1 === t2[0] && t2[1] < 6 ? "Cupcake" : 1 === t2[0] && t2[1] >= 6 ? "Donut" : 2 === t2[0] && t2[1] < 2 ? "Eclair" : 2 === t2[0] && 2 === t2[1] ? "Froyo" : 2 === t2[0] && t2[1] > 2 ? "Gingerbread" : 3 === t2[0] ? "Honeycomb" : 4 === t2[0] && t2[1] < 1 ? "Ice Cream Sandwich" : 4 === t2[0] && t2[1] < 4 ? "Jelly Bean" : 4 === t2[0] && t2[1] >= 4 ? "KitKat" : 5 === t2[0] ? "Lollipop" : 6 === t2[0] ? "Marshmallow" : 7 === t2[0] ? "Nougat" : 8 === t2[0] ? "Oreo" : 9 === t2[0] ? "Pie" : void 0;
  }
  static getVersionPrecision(e2) {
    return e2.split(".").length;
  }
  static compareVersions(e2, t2, n2 = false) {
    const r3 = _O.getVersionPrecision(e2), i2 = _O.getVersionPrecision(t2);
    let o2 = Math.max(r3, i2), s2 = 0;
    const a2 = _O.map([e2, t2], ((e3) => {
      const t3 = o2 - _O.getVersionPrecision(e3), n3 = e3 + new Array(t3 + 1).join(".0");
      return _O.map(n3.split("."), ((e4) => new Array(20 - e4.length).join("0") + e4)).reverse();
    }));
    for (n2 && (s2 = o2 - Math.min(r3, i2)), o2 -= 1; o2 >= s2; ) {
      if (a2[0][o2] > a2[1][o2]) return 1;
      if (a2[0][o2] === a2[1][o2]) {
        if (o2 === s2) return 0;
        o2 -= 1;
      } else if (a2[0][o2] < a2[1][o2]) return -1;
    }
  }
  static map(e2, t2) {
    const n2 = [];
    let r3;
    if (Array.prototype.map) return Array.prototype.map.call(e2, t2);
    for (r3 = 0; r3 < e2.length; r3 += 1) n2.push(t2(e2[r3]));
    return n2;
  }
  static find(e2, t2) {
    let n2, r3;
    if (Array.prototype.find) return Array.prototype.find.call(e2, t2);
    for (n2 = 0, r3 = e2.length; n2 < r3; n2 += 1) {
      const r4 = e2[n2];
      if (t2(r4, n2)) return r4;
    }
  }
  static assign(e2, ...t2) {
    const n2 = e2;
    let r3, i2;
    if (Object.assign) return Object.assign(e2, ...t2);
    for (r3 = 0, i2 = t2.length; r3 < i2; r3 += 1) {
      const e3 = t2[r3];
      if ("object" == typeof e3 && null !== e3) {
        Object.keys(e3).forEach(((t3) => {
          n2[t3] = e3[t3];
        }));
      }
    }
    return e2;
  }
  static getBrowserAlias(e2) {
    return k[e2];
  }
  static getBrowserTypeByAlias(e2) {
    return M[e2] || "";
  }
};
var P = /version\/(\d+(\.?_?\d+)+)/i;
var A = [{ test: [/googlebot/i], describe(e2) {
  const t2 = { name: "Googlebot" }, n2 = O.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/opera/i], describe(e2) {
  const t2 = { name: "Opera" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/opr\/|opios/i], describe(e2) {
  const t2 = { name: "Opera" }, n2 = O.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/SamsungBrowser/i], describe(e2) {
  const t2 = { name: "Samsung Internet for Android" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/Whale/i], describe(e2) {
  const t2 = { name: "NAVER Whale Browser" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/MZBrowser/i], describe(e2) {
  const t2 = { name: "MZ Browser" }, n2 = O.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/focus/i], describe(e2) {
  const t2 = { name: "Focus" }, n2 = O.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/swing/i], describe(e2) {
  const t2 = { name: "Swing" }, n2 = O.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/coast/i], describe(e2) {
  const t2 = { name: "Opera Coast" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe(e2) {
  const t2 = { name: "Opera Touch" }, n2 = O.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/yabrowser/i], describe(e2) {
  const t2 = { name: "Yandex Browser" }, n2 = O.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/ucbrowser/i], describe(e2) {
  const t2 = { name: "UC Browser" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/Maxthon|mxios/i], describe(e2) {
  const t2 = { name: "Maxthon" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/epiphany/i], describe(e2) {
  const t2 = { name: "Epiphany" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/puffin/i], describe(e2) {
  const t2 = { name: "Puffin" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/sleipnir/i], describe(e2) {
  const t2 = { name: "Sleipnir" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/k-meleon/i], describe(e2) {
  const t2 = { name: "K-Meleon" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/micromessenger/i], describe(e2) {
  const t2 = { name: "WeChat" }, n2 = O.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/qqbrowser/i], describe(e2) {
  const t2 = { name: /qqbrowserlite/i.test(e2) ? "QQ Browser Lite" : "QQ Browser" }, n2 = O.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/msie|trident/i], describe(e2) {
  const t2 = { name: "Internet Explorer" }, n2 = O.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/\sedg\//i], describe(e2) {
  const t2 = { name: "Microsoft Edge" }, n2 = O.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/edg([ea]|ios)/i], describe(e2) {
  const t2 = { name: "Microsoft Edge" }, n2 = O.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/vivaldi/i], describe(e2) {
  const t2 = { name: "Vivaldi" }, n2 = O.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/seamonkey/i], describe(e2) {
  const t2 = { name: "SeaMonkey" }, n2 = O.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/sailfish/i], describe(e2) {
  const t2 = { name: "Sailfish" }, n2 = O.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/silk/i], describe(e2) {
  const t2 = { name: "Amazon Silk" }, n2 = O.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/phantom/i], describe(e2) {
  const t2 = { name: "PhantomJS" }, n2 = O.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/slimerjs/i], describe(e2) {
  const t2 = { name: "SlimerJS" }, n2 = O.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e2) {
  const t2 = { name: "BlackBerry" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/(web|hpw)[o0]s/i], describe(e2) {
  const t2 = { name: "WebOS Browser" }, n2 = O.getFirstMatch(P, e2) || O.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/bada/i], describe(e2) {
  const t2 = { name: "Bada" }, n2 = O.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/tizen/i], describe(e2) {
  const t2 = { name: "Tizen" }, n2 = O.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/qupzilla/i], describe(e2) {
  const t2 = { name: "QupZilla" }, n2 = O.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/firefox|iceweasel|fxios/i], describe(e2) {
  const t2 = { name: "Firefox" }, n2 = O.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/electron/i], describe(e2) {
  const t2 = { name: "Electron" }, n2 = O.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/MiuiBrowser/i], describe(e2) {
  const t2 = { name: "Miui" }, n2 = O.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/chromium/i], describe(e2) {
  const t2 = { name: "Chromium" }, n2 = O.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e2) || O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/chrome|crios|crmo/i], describe(e2) {
  const t2 = { name: "Chrome" }, n2 = O.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/GSA/i], describe(e2) {
  const t2 = { name: "Google Search" }, n2 = O.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test(e2) {
  const t2 = !e2.test(/like android/i), n2 = e2.test(/android/i);
  return t2 && n2;
}, describe(e2) {
  const t2 = { name: "Android Browser" }, n2 = O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/playstation 4/i], describe(e2) {
  const t2 = { name: "PlayStation 4" }, n2 = O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/safari|applewebkit/i], describe(e2) {
  const t2 = { name: "Safari" }, n2 = O.getFirstMatch(P, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/.*/i], describe(e2) {
  const t2 = -1 !== e2.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
  return { name: O.getFirstMatch(t2, e2), version: O.getSecondMatch(t2, e2) };
} }];
var j = [{ test: [/Roku\/DVP/], describe(e2) {
  const t2 = O.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e2);
  return { name: E.Roku, version: t2 };
} }, { test: [/windows phone/i], describe(e2) {
  const t2 = O.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e2);
  return { name: E.WindowsPhone, version: t2 };
} }, { test: [/windows /i], describe(e2) {
  const t2 = O.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e2), n2 = O.getWindowsVersionName(t2);
  return { name: E.Windows, version: t2, versionName: n2 };
} }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe(e2) {
  const t2 = { name: E.iOS }, n2 = O.getSecondMatch(/(Version\/)(\d[\d.]+)/, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/macintosh/i], describe(e2) {
  const t2 = O.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e2).replace(/[_\s]/g, "."), n2 = O.getMacOSVersionName(t2), r3 = { name: E.MacOS, version: t2 };
  return n2 && (r3.versionName = n2), r3;
} }, { test: [/(ipod|iphone|ipad)/i], describe(e2) {
  const t2 = O.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e2).replace(/[_\s]/g, ".");
  return { name: E.iOS, version: t2 };
} }, { test(e2) {
  const t2 = !e2.test(/like android/i), n2 = e2.test(/android/i);
  return t2 && n2;
}, describe(e2) {
  const t2 = O.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e2), n2 = O.getAndroidVersionName(t2), r3 = { name: E.Android, version: t2 };
  return n2 && (r3.versionName = n2), r3;
} }, { test: [/(web|hpw)[o0]s/i], describe(e2) {
  const t2 = O.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e2), n2 = { name: E.WebOS };
  return t2 && t2.length && (n2.version = t2), n2;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e2) {
  const t2 = O.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e2) || O.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e2) || O.getFirstMatch(/\bbb(\d+)/i, e2);
  return { name: E.BlackBerry, version: t2 };
} }, { test: [/bada/i], describe(e2) {
  const t2 = O.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e2);
  return { name: E.Bada, version: t2 };
} }, { test: [/tizen/i], describe(e2) {
  const t2 = O.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e2);
  return { name: E.Tizen, version: t2 };
} }, { test: [/linux/i], describe: () => ({ name: E.Linux }) }, { test: [/CrOS/], describe: () => ({ name: E.ChromeOS }) }, { test: [/PlayStation 4/], describe(e2) {
  const t2 = O.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e2);
  return { name: E.PlayStation4, version: t2 };
} }];
var I = [{ test: [/googlebot/i], describe: () => ({ type: "bot", vendor: "Google" }) }, { test: [/huawei/i], describe(e2) {
  const t2 = O.getFirstMatch(/(can-l01)/i, e2) && "Nova", n2 = { type: C.mobile, vendor: "Huawei" };
  return t2 && (n2.model = t2), n2;
} }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: () => ({ type: C.tablet, vendor: "Nexus" }) }, { test: [/ipad/i], describe: () => ({ type: C.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: () => ({ type: C.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/kftt build/i], describe: () => ({ type: C.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" }) }, { test: [/silk/i], describe: () => ({ type: C.tablet, vendor: "Amazon" }) }, { test: [/tablet(?! pc)/i], describe: () => ({ type: C.tablet }) }, { test(e2) {
  const t2 = e2.test(/ipod|iphone/i), n2 = e2.test(/like (ipod|iphone)/i);
  return t2 && !n2;
}, describe(e2) {
  const t2 = O.getFirstMatch(/(ipod|iphone)/i, e2);
  return { type: C.mobile, vendor: "Apple", model: t2 };
} }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: () => ({ type: C.mobile, vendor: "Nexus" }) }, { test: [/[^-]mobi/i], describe: () => ({ type: C.mobile }) }, { test: (e2) => "blackberry" === e2.getBrowserName(true), describe: () => ({ type: C.mobile, vendor: "BlackBerry" }) }, { test: (e2) => "bada" === e2.getBrowserName(true), describe: () => ({ type: C.mobile }) }, { test: (e2) => "windows phone" === e2.getBrowserName(), describe: () => ({ type: C.mobile, vendor: "Microsoft" }) }, { test(e2) {
  const t2 = Number(String(e2.getOSVersion()).split(".")[0]);
  return "android" === e2.getOSName(true) && t2 >= 3;
}, describe: () => ({ type: C.tablet }) }, { test: (e2) => "android" === e2.getOSName(true), describe: () => ({ type: C.mobile }) }, { test: (e2) => "macos" === e2.getOSName(true), describe: () => ({ type: C.desktop, vendor: "Apple" }) }, { test: (e2) => "windows" === e2.getOSName(true), describe: () => ({ type: C.desktop }) }, { test: (e2) => "linux" === e2.getOSName(true), describe: () => ({ type: C.desktop }) }, { test: (e2) => "playstation 4" === e2.getOSName(true), describe: () => ({ type: C.tv }) }, { test: (e2) => "roku" === e2.getOSName(true), describe: () => ({ type: C.tv }) }];
var x = [{ test: (e2) => "microsoft edge" === e2.getBrowserName(true), describe(e2) {
  if (/\sedg\//i.test(e2)) return { name: T.Blink };
  const t2 = O.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e2);
  return { name: T.EdgeHTML, version: t2 };
} }, { test: [/trident/i], describe(e2) {
  const t2 = { name: T.Trident }, n2 = O.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: (e2) => e2.test(/presto/i), describe(e2) {
  const t2 = { name: T.Presto }, n2 = O.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test(e2) {
  const t2 = e2.test(/gecko/i), n2 = e2.test(/like gecko/i);
  return t2 && !n2;
}, describe(e2) {
  const t2 = { name: T.Gecko }, n2 = O.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/(apple)?webkit\/537\.36/i], describe: () => ({ name: T.Blink }) }, { test: [/(apple)?webkit/i], describe(e2) {
  const t2 = { name: T.WebKit }, n2 = O.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }];
var L = class {
  constructor(e2, t2 = false) {
    if (null == e2 || "" === e2) throw new Error("UserAgent parameter can't be empty");
    this._ua = e2, this.parsedResult = {}, true !== t2 && this.parse();
  }
  getUA() {
    return this._ua;
  }
  test(e2) {
    return e2.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const e2 = O.find(A, ((e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some(((e4) => this.test(e4)));
      throw new Error("Browser's test function is not valid");
    }));
    return e2 && (this.parsedResult.browser = e2.describe(this.getUA())), this.parsedResult.browser;
  }
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  getBrowserName(e2) {
    return e2 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const e2 = O.find(j, ((e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some(((e4) => this.test(e4)));
      throw new Error("Browser's test function is not valid");
    }));
    return e2 && (this.parsedResult.os = e2.describe(this.getUA())), this.parsedResult.os;
  }
  getOSName(e2) {
    const { name: t2 } = this.getOS();
    return e2 ? String(t2).toLowerCase() || "" : t2 || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  getPlatformType(e2 = false) {
    const { type: t2 } = this.getPlatform();
    return e2 ? String(t2).toLowerCase() || "" : t2 || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const e2 = O.find(I, ((e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some(((e4) => this.test(e4)));
      throw new Error("Browser's test function is not valid");
    }));
    return e2 && (this.parsedResult.platform = e2.describe(this.getUA())), this.parsedResult.platform;
  }
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  getEngineName(e2) {
    return e2 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const e2 = O.find(x, ((e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some(((e4) => this.test(e4)));
      throw new Error("Browser's test function is not valid");
    }));
    return e2 && (this.parsedResult.engine = e2.describe(this.getUA())), this.parsedResult.engine;
  }
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  getResult() {
    return O.assign({}, this.parsedResult);
  }
  satisfies(e2) {
    const t2 = {};
    let n2 = 0;
    const r3 = {};
    let i2 = 0;
    if (Object.keys(e2).forEach(((o2) => {
      const s2 = e2[o2];
      "string" == typeof s2 ? (r3[o2] = s2, i2 += 1) : "object" == typeof s2 && (t2[o2] = s2, n2 += 1);
    })), n2 > 0) {
      const e3 = Object.keys(t2), n3 = O.find(e3, ((e4) => this.isOS(e4)));
      if (n3) {
        const e4 = this.satisfies(t2[n3]);
        if (void 0 !== e4) return e4;
      }
      const r4 = O.find(e3, ((e4) => this.isPlatform(e4)));
      if (r4) {
        const e4 = this.satisfies(t2[r4]);
        if (void 0 !== e4) return e4;
      }
    }
    if (i2 > 0) {
      const e3 = Object.keys(r3), t3 = O.find(e3, ((e4) => this.isBrowser(e4, true)));
      if (void 0 !== t3) return this.compareVersion(r3[t3]);
    }
  }
  isBrowser(e2, t2 = false) {
    const n2 = this.getBrowserName().toLowerCase();
    let r3 = e2.toLowerCase();
    const i2 = O.getBrowserTypeByAlias(r3);
    return t2 && i2 && (r3 = i2.toLowerCase()), r3 === n2;
  }
  compareVersion(e2) {
    let t2 = [0], n2 = e2, r3 = false;
    const i2 = this.getBrowserVersion();
    if ("string" == typeof i2) return ">" === e2[0] || "<" === e2[0] ? (n2 = e2.substr(1), "=" === e2[1] ? (r3 = true, n2 = e2.substr(2)) : t2 = [], ">" === e2[0] ? t2.push(1) : t2.push(-1)) : "=" === e2[0] ? n2 = e2.substr(1) : "~" === e2[0] && (r3 = true, n2 = e2.substr(1)), t2.indexOf(O.compareVersions(i2, n2, r3)) > -1;
  }
  isOS(e2) {
    return this.getOSName(true) === String(e2).toLowerCase();
  }
  isPlatform(e2) {
    return this.getPlatformType(true) === String(e2).toLowerCase();
  }
  isEngine(e2) {
    return this.getEngineName(true) === String(e2).toLowerCase();
  }
  is(e2, t2 = false) {
    return this.isBrowser(e2, t2) || this.isOS(e2) || this.isPlatform(e2);
  }
  some(e2 = []) {
    return e2.some(((e3) => this.is(e3)));
  }
};
var D = class {
  static getParser(e2, t2 = false) {
    if ("string" != typeof e2) throw new Error("UserAgent should be a string");
    return new L(e2, t2);
  }
  static parse(e2) {
    return new L(e2).getResult();
  }
  static get BROWSER_MAP() {
    return M;
  }
  static get ENGINE_MAP() {
    return T;
  }
  static get OS_MAP() {
    return E;
  }
  static get PLATFORMS_MAP() {
    return C;
  }
};
function N() {
  return Date.now() + Math.random().toString();
}
function R() {
  throw new Error("Method must be implemented in subclass");
}
function F(e2, t2) {
  return null != t2 && t2.proxyUrl ? t2.proxyUrl + ("/" === t2.proxyUrl.slice(-1) ? "" : "/") + e2.substring(8) : e2;
}
function B(e2) {
  return null != e2 && e2.callObjectBundleUrlOverride ? e2.callObjectBundleUrlOverride : F("https://c.daily.co/call-machine/versioned/".concat("0.83.1", "/static/call-machine-object-bundle.js"), e2);
}
function U(e2) {
  try {
    new URL(e2);
  } catch (e3) {
    return false;
  }
  return true;
}
var V = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var J = "8.55.0";
var $ = globalThis;
function q(e2, t2, n2) {
  const r3 = n2 || $, i2 = r3.__SENTRY__ = r3.__SENTRY__ || {}, o2 = i2[J] = i2[J] || {};
  return o2[e2] || (o2[e2] = t2());
}
var z = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var W = ["debug", "info", "warn", "error", "log", "assert", "trace"];
var H = {};
function G(e2) {
  if (!("console" in $)) return e2();
  const t2 = $.console, n2 = {}, r3 = Object.keys(H);
  r3.forEach(((e3) => {
    const r4 = H[e3];
    n2[e3] = t2[e3], t2[e3] = r4;
  }));
  try {
    return e2();
  } finally {
    r3.forEach(((e3) => {
      t2[e3] = n2[e3];
    }));
  }
}
var Q = q("logger", (function() {
  let e2 = false;
  const t2 = { enable: () => {
    e2 = true;
  }, disable: () => {
    e2 = false;
  }, isEnabled: () => e2 };
  return z ? W.forEach(((n2) => {
    t2[n2] = (...t3) => {
      e2 && G((() => {
        $.console[n2](`Sentry Logger [${n2}]:`, ...t3);
      }));
    };
  })) : W.forEach(((e3) => {
    t2[e3] = () => {
    };
  })), t2;
}));
var K = "?";
var Y = /\(error: (.*)\)/;
var X = /captureMessage|captureException/;
function Z(e2) {
  return e2[e2.length - 1] || {};
}
var ee = "<anonymous>";
function te(e2) {
  try {
    return e2 && "function" == typeof e2 && e2.name || ee;
  } catch (e3) {
    return ee;
  }
}
function ne(e2) {
  const t2 = e2.exception;
  if (t2) {
    const e3 = [];
    try {
      return t2.values.forEach(((t3) => {
        t3.stacktrace.frames && e3.push(...t3.stacktrace.frames);
      })), e3;
    } catch (e4) {
      return;
    }
  }
}
var re = {};
var ie = {};
function oe(e2, t2) {
  re[e2] = re[e2] || [], re[e2].push(t2);
}
function se(e2, t2) {
  if (!ie[e2]) {
    ie[e2] = true;
    try {
      t2();
    } catch (t3) {
      z && Q.error(`Error while instrumenting ${e2}`, t3);
    }
  }
}
function ae(e2, t2) {
  const n2 = e2 && re[e2];
  if (n2) for (const r3 of n2) try {
    r3(t2);
  } catch (t3) {
    z && Q.error(`Error while triggering instrumentation handler.
Type: ${e2}
Name: ${te(r3)}
Error:`, t3);
  }
}
var ce = null;
function le() {
  ce = $.onerror, $.onerror = function(e2, t2, n2, r3, i2) {
    return ae("error", { column: r3, error: i2, line: n2, msg: e2, url: t2 }), !!ce && ce.apply(this, arguments);
  }, $.onerror.__SENTRY_INSTRUMENTED__ = true;
}
var ue = null;
function de() {
  ue = $.onunhandledrejection, $.onunhandledrejection = function(e2) {
    return ae("unhandledrejection", e2), !ue || ue.apply(this, arguments);
  }, $.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}
function pe() {
  return he($), $;
}
function he(e2) {
  const t2 = e2.__SENTRY__ = e2.__SENTRY__ || {};
  return t2.version = t2.version || J, t2[J] = t2[J] || {};
}
var fe = Object.prototype.toString;
function ve(e2) {
  switch (fe.call(e2)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return true;
    default:
      return Ce(e2, Error);
  }
}
function ge(e2, t2) {
  return fe.call(e2) === `[object ${t2}]`;
}
function me(e2) {
  return ge(e2, "ErrorEvent");
}
function ye(e2) {
  return ge(e2, "DOMError");
}
function be(e2) {
  return ge(e2, "String");
}
function _e(e2) {
  return "object" == typeof e2 && null !== e2 && "__sentry_template_string__" in e2 && "__sentry_template_values__" in e2;
}
function we(e2) {
  return null === e2 || _e(e2) || "object" != typeof e2 && "function" != typeof e2;
}
function Se(e2) {
  return ge(e2, "Object");
}
function ke(e2) {
  return "undefined" != typeof Event && Ce(e2, Event);
}
function Me(e2) {
  return Boolean(e2 && e2.then && "function" == typeof e2.then);
}
function Ce(e2, t2) {
  try {
    return e2 instanceof t2;
  } catch (e3) {
    return false;
  }
}
function Ee(e2) {
  return !("object" != typeof e2 || null === e2 || !e2.__isVue && !e2._isVue);
}
var Te = $;
function Oe(e2, t2 = {}) {
  if (!e2) return "<unknown>";
  try {
    let n2 = e2;
    const r3 = 5, i2 = [];
    let o2 = 0, s2 = 0;
    const a2 = " > ", c2 = a2.length;
    let l2;
    const u2 = Array.isArray(t2) ? t2 : t2.keyAttrs, d2 = !Array.isArray(t2) && t2.maxStringLength || 80;
    for (; n2 && o2++ < r3 && (l2 = Pe(n2, u2), !("html" === l2 || o2 > 1 && s2 + i2.length * c2 + l2.length >= d2)); ) i2.push(l2), s2 += l2.length, n2 = n2.parentNode;
    return i2.reverse().join(a2);
  } catch (e3) {
    return "<unknown>";
  }
}
function Pe(e2, t2) {
  const n2 = e2, r3 = [];
  if (!n2 || !n2.tagName) return "";
  if (Te.HTMLElement && n2 instanceof HTMLElement && n2.dataset) {
    if (n2.dataset.sentryComponent) return n2.dataset.sentryComponent;
    if (n2.dataset.sentryElement) return n2.dataset.sentryElement;
  }
  r3.push(n2.tagName.toLowerCase());
  const i2 = t2 && t2.length ? t2.filter(((e3) => n2.getAttribute(e3))).map(((e3) => [e3, n2.getAttribute(e3)])) : null;
  if (i2 && i2.length) i2.forEach(((e3) => {
    r3.push(`[${e3[0]}="${e3[1]}"]`);
  }));
  else {
    n2.id && r3.push(`#${n2.id}`);
    const e3 = n2.className;
    if (e3 && be(e3)) {
      const t3 = e3.split(/\s+/);
      for (const e4 of t3) r3.push(`.${e4}`);
    }
  }
  const o2 = ["aria-label", "type", "name", "title", "alt"];
  for (const e3 of o2) {
    const t3 = n2.getAttribute(e3);
    t3 && r3.push(`[${e3}="${t3}"]`);
  }
  return r3.join("");
}
function Ae(e2, t2 = 0) {
  return "string" != typeof e2 || 0 === t2 || e2.length <= t2 ? e2 : `${e2.slice(0, t2)}...`;
}
function je(e2, t2) {
  if (!Array.isArray(e2)) return "";
  const n2 = [];
  for (let t3 = 0; t3 < e2.length; t3++) {
    const r3 = e2[t3];
    try {
      Ee(r3) ? n2.push("[VueViewModel]") : n2.push(String(r3));
    } catch (e3) {
      n2.push("[value cannot be serialized]");
    }
  }
  return n2.join(t2);
}
function Ie(e2, t2, n2 = false) {
  return !!be(e2) && (ge(t2, "RegExp") ? t2.test(e2) : !!be(t2) && (n2 ? e2 === t2 : e2.includes(t2)));
}
function xe(e2, t2 = [], n2 = false) {
  return t2.some(((t3) => Ie(e2, t3, n2)));
}
function Le(e2, t2, n2) {
  if (!(t2 in e2)) return;
  const r3 = e2[t2], i2 = n2(r3);
  "function" == typeof i2 && Ne(i2, r3);
  try {
    e2[t2] = i2;
  } catch (n3) {
    z && Q.log(`Failed to replace method "${t2}" in object`, e2);
  }
}
function De(e2, t2, n2) {
  try {
    Object.defineProperty(e2, t2, { value: n2, writable: true, configurable: true });
  } catch (n3) {
    z && Q.log(`Failed to add non-enumerable property "${t2}" to object`, e2);
  }
}
function Ne(e2, t2) {
  try {
    const n2 = t2.prototype || {};
    e2.prototype = t2.prototype = n2, De(e2, "__sentry_original__", t2);
  } catch (e3) {
  }
}
function Re(e2) {
  return e2.__sentry_original__;
}
function Fe(e2) {
  if (ve(e2)) return { message: e2.message, name: e2.name, stack: e2.stack, ...Ue(e2) };
  if (ke(e2)) {
    const t2 = { type: e2.type, target: Be(e2.target), currentTarget: Be(e2.currentTarget), ...Ue(e2) };
    return "undefined" != typeof CustomEvent && Ce(e2, CustomEvent) && (t2.detail = e2.detail), t2;
  }
  return e2;
}
function Be(e2) {
  try {
    return t2 = e2, "undefined" != typeof Element && Ce(t2, Element) ? Oe(e2) : Object.prototype.toString.call(e2);
  } catch (e3) {
    return "<unknown>";
  }
  var t2;
}
function Ue(e2) {
  if ("object" == typeof e2 && null !== e2) {
    const t2 = {};
    for (const n2 in e2) Object.prototype.hasOwnProperty.call(e2, n2) && (t2[n2] = e2[n2]);
    return t2;
  }
  return {};
}
function Ve(e2) {
  return Je(e2, /* @__PURE__ */ new Map());
}
function Je(e2, t2) {
  if ((function(e3) {
    if (!Se(e3)) return false;
    try {
      const t3 = Object.getPrototypeOf(e3).constructor.name;
      return !t3 || "Object" === t3;
    } catch (e4) {
      return true;
    }
  })(e2)) {
    const n2 = t2.get(e2);
    if (void 0 !== n2) return n2;
    const r3 = {};
    t2.set(e2, r3);
    for (const n3 of Object.getOwnPropertyNames(e2)) void 0 !== e2[n3] && (r3[n3] = Je(e2[n3], t2));
    return r3;
  }
  if (Array.isArray(e2)) {
    const n2 = t2.get(e2);
    if (void 0 !== n2) return n2;
    const r3 = [];
    return t2.set(e2, r3), e2.forEach(((e3) => {
      r3.push(Je(e3, t2));
    })), r3;
  }
  return e2;
}
function $e() {
  return Date.now() / 1e3;
}
var qe = (function() {
  const { performance: e2 } = $;
  if (!e2 || !e2.now) return $e;
  const t2 = Date.now() - e2.now(), n2 = null == e2.timeOrigin ? t2 : e2.timeOrigin;
  return () => (n2 + e2.now()) / 1e3;
})();
function ze() {
  const e2 = $, t2 = e2.crypto || e2.msCrypto;
  let n2 = () => 16 * Math.random();
  try {
    if (t2 && t2.randomUUID) return t2.randomUUID().replace(/-/g, "");
    t2 && t2.getRandomValues && (n2 = () => {
      const e3 = new Uint8Array(1);
      return t2.getRandomValues(e3), e3[0];
    });
  } catch (e3) {
  }
  return ("10000000100040008000" + 1e11).replace(/[018]/g, ((e3) => (e3 ^ (15 & n2()) >> e3 / 4).toString(16)));
}
function We(e2) {
  return e2.exception && e2.exception.values ? e2.exception.values[0] : void 0;
}
function He(e2) {
  const { message: t2, event_id: n2 } = e2;
  if (t2) return t2;
  const r3 = We(e2);
  return r3 ? r3.type && r3.value ? `${r3.type}: ${r3.value}` : r3.type || r3.value || n2 || "<unknown>" : n2 || "<unknown>";
}
function Ge(e2, t2, n2) {
  const r3 = e2.exception = e2.exception || {}, i2 = r3.values = r3.values || [], o2 = i2[0] = i2[0] || {};
  o2.value || (o2.value = t2 || ""), o2.type || (o2.type = n2 || "Error");
}
function Qe(e2, t2) {
  const n2 = We(e2);
  if (!n2) return;
  const r3 = n2.mechanism;
  if (n2.mechanism = { type: "generic", handled: true, ...r3, ...t2 }, t2 && "data" in t2) {
    const e3 = { ...r3 && r3.data, ...t2.data };
    n2.mechanism.data = e3;
  }
}
function Ke(e2) {
  if ((function(e3) {
    try {
      return e3.__sentry_captured__;
    } catch (e4) {
    }
  })(e2)) return true;
  try {
    De(e2, "__sentry_captured__", true);
  } catch (e3) {
  }
  return false;
}
var Ye;
function Xe(e2) {
  return new et(((t2) => {
    t2(e2);
  }));
}
function Ze(e2) {
  return new et(((t2, n2) => {
    n2(e2);
  }));
}
(() => {
  const { performance: e2 } = $;
  if (!e2 || !e2.now) return;
  const t2 = 36e5, n2 = e2.now(), r3 = Date.now(), i2 = e2.timeOrigin ? Math.abs(e2.timeOrigin + n2 - r3) : t2, o2 = i2 < t2, s2 = e2.timing && e2.timing.navigationStart, a2 = "number" == typeof s2 ? Math.abs(s2 + n2 - r3) : t2;
  (o2 || a2 < t2) && (i2 <= a2 && e2.timeOrigin);
})(), (function(e2) {
  e2[e2.PENDING = 0] = "PENDING";
  e2[e2.RESOLVED = 1] = "RESOLVED";
  e2[e2.REJECTED = 2] = "REJECTED";
})(Ye || (Ye = {}));
var et = class _et {
  constructor(e2) {
    _et.prototype.__init.call(this), _et.prototype.__init2.call(this), _et.prototype.__init3.call(this), _et.prototype.__init4.call(this), this._state = Ye.PENDING, this._handlers = [];
    try {
      e2(this._resolve, this._reject);
    } catch (e3) {
      this._reject(e3);
    }
  }
  then(e2, t2) {
    return new _et(((n2, r3) => {
      this._handlers.push([false, (t3) => {
        if (e2) try {
          n2(e2(t3));
        } catch (e3) {
          r3(e3);
        }
        else n2(t3);
      }, (e3) => {
        if (t2) try {
          n2(t2(e3));
        } catch (e4) {
          r3(e4);
        }
        else r3(e3);
      }]), this._executeHandlers();
    }));
  }
  catch(e2) {
    return this.then(((e3) => e3), e2);
  }
  finally(e2) {
    return new _et(((t2, n2) => {
      let r3, i2;
      return this.then(((t3) => {
        i2 = false, r3 = t3, e2 && e2();
      }), ((t3) => {
        i2 = true, r3 = t3, e2 && e2();
      })).then((() => {
        i2 ? n2(r3) : t2(r3);
      }));
    }));
  }
  __init() {
    this._resolve = (e2) => {
      this._setResult(Ye.RESOLVED, e2);
    };
  }
  __init2() {
    this._reject = (e2) => {
      this._setResult(Ye.REJECTED, e2);
    };
  }
  __init3() {
    this._setResult = (e2, t2) => {
      this._state === Ye.PENDING && (Me(t2) ? t2.then(this._resolve, this._reject) : (this._state = e2, this._value = t2, this._executeHandlers()));
    };
  }
  __init4() {
    this._executeHandlers = () => {
      if (this._state === Ye.PENDING) return;
      const e2 = this._handlers.slice();
      this._handlers = [], e2.forEach(((e3) => {
        e3[0] || (this._state === Ye.RESOLVED && e3[1](this._value), this._state === Ye.REJECTED && e3[2](this._value), e3[0] = true);
      }));
    };
  }
};
function tt(e2) {
  const t2 = qe(), n2 = { sid: ze(), init: true, timestamp: t2, started: t2, duration: 0, status: "ok", errors: 0, ignoreDuration: false, toJSON: () => (function(e3) {
    return Ve({ sid: `${e3.sid}`, init: e3.init, started: new Date(1e3 * e3.started).toISOString(), timestamp: new Date(1e3 * e3.timestamp).toISOString(), status: e3.status, errors: e3.errors, did: "number" == typeof e3.did || "string" == typeof e3.did ? `${e3.did}` : void 0, duration: e3.duration, abnormal_mechanism: e3.abnormal_mechanism, attrs: { release: e3.release, environment: e3.environment, ip_address: e3.ipAddress, user_agent: e3.userAgent } });
  })(n2) };
  return e2 && nt(n2, e2), n2;
}
function nt(e2, t2 = {}) {
  if (t2.user && (!e2.ipAddress && t2.user.ip_address && (e2.ipAddress = t2.user.ip_address), e2.did || t2.did || (e2.did = t2.user.id || t2.user.email || t2.user.username)), e2.timestamp = t2.timestamp || qe(), t2.abnormal_mechanism && (e2.abnormal_mechanism = t2.abnormal_mechanism), t2.ignoreDuration && (e2.ignoreDuration = t2.ignoreDuration), t2.sid && (e2.sid = 32 === t2.sid.length ? t2.sid : ze()), void 0 !== t2.init && (e2.init = t2.init), !e2.did && t2.did && (e2.did = `${t2.did}`), "number" == typeof t2.started && (e2.started = t2.started), e2.ignoreDuration) e2.duration = void 0;
  else if ("number" == typeof t2.duration) e2.duration = t2.duration;
  else {
    const t3 = e2.timestamp - e2.started;
    e2.duration = t3 >= 0 ? t3 : 0;
  }
  t2.release && (e2.release = t2.release), t2.environment && (e2.environment = t2.environment), !e2.ipAddress && t2.ipAddress && (e2.ipAddress = t2.ipAddress), !e2.userAgent && t2.userAgent && (e2.userAgent = t2.userAgent), "number" == typeof t2.errors && (e2.errors = t2.errors), t2.status && (e2.status = t2.status);
}
function rt() {
  return ze();
}
function it() {
  return ze().substring(16);
}
function ot(e2, t2, n2 = 2) {
  if (!t2 || "object" != typeof t2 || n2 <= 0) return t2;
  if (e2 && t2 && 0 === Object.keys(t2).length) return e2;
  const r3 = { ...e2 };
  for (const e3 in t2) Object.prototype.hasOwnProperty.call(t2, e3) && (r3[e3] = ot(r3[e3], t2[e3], n2 - 1));
  return r3;
}
var st = "_sentrySpan";
function at(e2, t2) {
  t2 ? De(e2, st, t2) : delete e2[st];
}
function ct(e2) {
  return e2[st];
}
var lt = class _lt {
  constructor() {
    this._notifyingListeners = false, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = { traceId: rt(), spanId: it() };
  }
  clone() {
    const e2 = new _lt();
    return e2._breadcrumbs = [...this._breadcrumbs], e2._tags = { ...this._tags }, e2._extra = { ...this._extra }, e2._contexts = { ...this._contexts }, this._contexts.flags && (e2._contexts.flags = { values: [...this._contexts.flags.values] }), e2._user = this._user, e2._level = this._level, e2._session = this._session, e2._transactionName = this._transactionName, e2._fingerprint = this._fingerprint, e2._eventProcessors = [...this._eventProcessors], e2._requestSession = this._requestSession, e2._attachments = [...this._attachments], e2._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, e2._propagationContext = { ...this._propagationContext }, e2._client = this._client, e2._lastEventId = this._lastEventId, at(e2, ct(this)), e2;
  }
  setClient(e2) {
    this._client = e2;
  }
  setLastEventId(e2) {
    this._lastEventId = e2;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(e2) {
    this._scopeListeners.push(e2);
  }
  addEventProcessor(e2) {
    return this._eventProcessors.push(e2), this;
  }
  setUser(e2) {
    return this._user = e2 || { email: void 0, id: void 0, ip_address: void 0, username: void 0 }, this._session && nt(this._session, { user: e2 }), this._notifyScopeListeners(), this;
  }
  getUser() {
    return this._user;
  }
  getRequestSession() {
    return this._requestSession;
  }
  setRequestSession(e2) {
    return this._requestSession = e2, this;
  }
  setTags(e2) {
    return this._tags = { ...this._tags, ...e2 }, this._notifyScopeListeners(), this;
  }
  setTag(e2, t2) {
    return this._tags = { ...this._tags, [e2]: t2 }, this._notifyScopeListeners(), this;
  }
  setExtras(e2) {
    return this._extra = { ...this._extra, ...e2 }, this._notifyScopeListeners(), this;
  }
  setExtra(e2, t2) {
    return this._extra = { ...this._extra, [e2]: t2 }, this._notifyScopeListeners(), this;
  }
  setFingerprint(e2) {
    return this._fingerprint = e2, this._notifyScopeListeners(), this;
  }
  setLevel(e2) {
    return this._level = e2, this._notifyScopeListeners(), this;
  }
  setTransactionName(e2) {
    return this._transactionName = e2, this._notifyScopeListeners(), this;
  }
  setContext(e2, t2) {
    return null === t2 ? delete this._contexts[e2] : this._contexts[e2] = t2, this._notifyScopeListeners(), this;
  }
  setSession(e2) {
    return e2 ? this._session = e2 : delete this._session, this._notifyScopeListeners(), this;
  }
  getSession() {
    return this._session;
  }
  update(e2) {
    if (!e2) return this;
    const t2 = "function" == typeof e2 ? e2(this) : e2, [n2, r3] = t2 instanceof ut ? [t2.getScopeData(), t2.getRequestSession()] : Se(t2) ? [e2, e2.requestSession] : [], { tags: i2, extra: o2, user: s2, contexts: a2, level: c2, fingerprint: l2 = [], propagationContext: u2 } = n2 || {};
    return this._tags = { ...this._tags, ...i2 }, this._extra = { ...this._extra, ...o2 }, this._contexts = { ...this._contexts, ...a2 }, s2 && Object.keys(s2).length && (this._user = s2), c2 && (this._level = c2), l2.length && (this._fingerprint = l2), u2 && (this._propagationContext = u2), r3 && (this._requestSession = r3), this;
  }
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, at(this, void 0), this._attachments = [], this.setPropagationContext({ traceId: rt() }), this._notifyScopeListeners(), this;
  }
  addBreadcrumb(e2, t2) {
    const n2 = "number" == typeof t2 ? t2 : 100;
    if (n2 <= 0) return this;
    const r3 = { timestamp: $e(), ...e2 };
    return this._breadcrumbs.push(r3), this._breadcrumbs.length > n2 && (this._breadcrumbs = this._breadcrumbs.slice(-n2), this._client && this._client.recordDroppedEvent("buffer_overflow", "log_item")), this._notifyScopeListeners(), this;
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  addAttachment(e2) {
    return this._attachments.push(e2), this;
  }
  clearAttachments() {
    return this._attachments = [], this;
  }
  getScopeData() {
    return { breadcrumbs: this._breadcrumbs, attachments: this._attachments, contexts: this._contexts, tags: this._tags, extra: this._extra, user: this._user, level: this._level, fingerprint: this._fingerprint || [], eventProcessors: this._eventProcessors, propagationContext: this._propagationContext, sdkProcessingMetadata: this._sdkProcessingMetadata, transactionName: this._transactionName, span: ct(this) };
  }
  setSDKProcessingMetadata(e2) {
    return this._sdkProcessingMetadata = ot(this._sdkProcessingMetadata, e2, 2), this;
  }
  setPropagationContext(e2) {
    return this._propagationContext = { spanId: it(), ...e2 }, this;
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(e2, t2) {
    const n2 = t2 && t2.event_id ? t2.event_id : ze();
    if (!this._client) return Q.warn("No client configured on scope - will not capture exception!"), n2;
    const r3 = new Error("Sentry syntheticException");
    return this._client.captureException(e2, { originalException: e2, syntheticException: r3, ...t2, event_id: n2 }, this), n2;
  }
  captureMessage(e2, t2, n2) {
    const r3 = n2 && n2.event_id ? n2.event_id : ze();
    if (!this._client) return Q.warn("No client configured on scope - will not capture message!"), r3;
    const i2 = new Error(e2);
    return this._client.captureMessage(e2, t2, { originalException: e2, syntheticException: i2, ...n2, event_id: r3 }, this), r3;
  }
  captureEvent(e2, t2) {
    const n2 = t2 && t2.event_id ? t2.event_id : ze();
    return this._client ? (this._client.captureEvent(e2, { ...t2, event_id: n2 }, this), n2) : (Q.warn("No client configured on scope - will not capture event!"), n2);
  }
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = true, this._scopeListeners.forEach(((e2) => {
      e2(this);
    })), this._notifyingListeners = false);
  }
};
var ut = lt;
var dt = class {
  constructor(e2, t2) {
    let n2, r3;
    n2 = e2 || new ut(), r3 = t2 || new ut(), this._stack = [{ scope: n2 }], this._isolationScope = r3;
  }
  withScope(e2) {
    const t2 = this._pushScope();
    let n2;
    try {
      n2 = e2(t2);
    } catch (e3) {
      throw this._popScope(), e3;
    }
    return Me(n2) ? n2.then(((e3) => (this._popScope(), e3)), ((e3) => {
      throw this._popScope(), e3;
    })) : (this._popScope(), n2);
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const e2 = this.getScope().clone();
    return this._stack.push({ client: this.getClient(), scope: e2 }), e2;
  }
  _popScope() {
    return !(this._stack.length <= 1) && !!this._stack.pop();
  }
};
function pt() {
  const e2 = he(pe());
  return e2.stack = e2.stack || new dt(q("defaultCurrentScope", (() => new ut())), q("defaultIsolationScope", (() => new ut())));
}
function ht(e2) {
  return pt().withScope(e2);
}
function ft(e2, t2) {
  const n2 = pt();
  return n2.withScope((() => (n2.getStackTop().scope = e2, t2(e2))));
}
function vt(e2) {
  return pt().withScope((() => e2(pt().getIsolationScope())));
}
function gt(e2) {
  const t2 = he(e2);
  return t2.acs ? t2.acs : { withIsolationScope: vt, withScope: ht, withSetScope: ft, withSetIsolationScope: (e3, t3) => vt(t3), getCurrentScope: () => pt().getScope(), getIsolationScope: () => pt().getIsolationScope() };
}
function mt() {
  return gt(pe()).getCurrentScope();
}
function yt() {
  return gt(pe()).getIsolationScope();
}
function bt() {
  return mt().getClient();
}
function _t(e2) {
  const t2 = e2.getPropagationContext(), { traceId: n2, spanId: r3, parentSpanId: i2 } = t2;
  return Ve({ trace_id: n2, span_id: r3, parent_span_id: i2 });
}
function wt(e2) {
  const t2 = e2._sentryMetrics;
  if (!t2) return;
  const n2 = {};
  for (const [, [e3, r3]] of t2) {
    (n2[e3] || (n2[e3] = [])).push(Ve(r3));
  }
  return n2;
}
var St = /^sentry-/;
function kt(e2) {
  const t2 = (function(e3) {
    if (!e3 || !be(e3) && !Array.isArray(e3)) return;
    if (Array.isArray(e3)) return e3.reduce(((e4, t3) => {
      const n3 = Mt(t3);
      return Object.entries(n3).forEach((([t4, n4]) => {
        e4[t4] = n4;
      })), e4;
    }), {});
    return Mt(e3);
  })(e2);
  if (!t2) return;
  const n2 = Object.entries(t2).reduce(((e3, [t3, n3]) => {
    if (t3.match(St)) {
      e3[t3.slice(7)] = n3;
    }
    return e3;
  }), {});
  return Object.keys(n2).length > 0 ? n2 : void 0;
}
function Mt(e2) {
  return e2.split(",").map(((e3) => e3.split("=").map(((e4) => decodeURIComponent(e4.trim()))))).reduce(((e3, [t2, n2]) => (t2 && n2 && (e3[t2] = n2), e3)), {});
}
var Ct = false;
function Et(e2) {
  const { spanId: t2, traceId: n2, isRemote: r3 } = e2.spanContext();
  return Ve({ parent_span_id: r3 ? t2 : Pt(e2).parent_span_id, span_id: r3 ? it() : t2, trace_id: n2 });
}
function Tt(e2) {
  return "number" == typeof e2 ? Ot(e2) : Array.isArray(e2) ? e2[0] + e2[1] / 1e9 : e2 instanceof Date ? Ot(e2.getTime()) : qe();
}
function Ot(e2) {
  return e2 > 9999999999 ? e2 / 1e3 : e2;
}
function Pt(e2) {
  if ((function(e3) {
    return "function" == typeof e3.getSpanJSON;
  })(e2)) return e2.getSpanJSON();
  try {
    const { spanId: t2, traceId: n2 } = e2.spanContext();
    if ((function(e3) {
      const t3 = e3;
      return !!(t3.attributes && t3.startTime && t3.name && t3.endTime && t3.status);
    })(e2)) {
      const { attributes: r3, startTime: i2, name: o2, endTime: s2, parentSpanId: a2, status: c2 } = e2;
      return Ve({ span_id: t2, trace_id: n2, data: r3, description: o2, parent_span_id: a2, start_timestamp: Tt(i2), timestamp: Tt(s2) || void 0, status: At(c2), op: r3["sentry.op"], origin: r3["sentry.origin"], _metrics_summary: wt(e2) });
    }
    return { span_id: t2, trace_id: n2 };
  } catch (e3) {
    return {};
  }
}
function At(e2) {
  if (e2 && 0 !== e2.code) return 1 === e2.code ? "ok" : e2.message || "unknown_error";
}
function jt(e2) {
  return e2._sentryRootSpan || e2;
}
function It() {
  Ct || (G((() => {
    console.warn("[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly.");
  })), Ct = true);
}
var xt = "production";
function Lt(e2, t2) {
  const n2 = t2.getOptions(), { publicKey: r3 } = t2.getDsn() || {}, i2 = Ve({ environment: n2.environment || xt, release: n2.release, public_key: r3, trace_id: e2 });
  return t2.emit("createDsc", i2), i2;
}
function Dt(e2) {
  const t2 = bt();
  if (!t2) return {};
  const n2 = jt(e2), r3 = n2._frozenDsc;
  if (r3) return r3;
  const i2 = n2.spanContext().traceState, o2 = i2 && i2.get("sentry.dsc"), s2 = o2 && kt(o2);
  if (s2) return s2;
  const a2 = Lt(e2.spanContext().traceId, t2), c2 = Pt(n2), l2 = c2.data || {}, u2 = l2["sentry.sample_rate"];
  null != u2 && (a2.sample_rate = `${u2}`);
  const d2 = l2["sentry.source"], p2 = c2.description;
  return "url" !== d2 && p2 && (a2.transaction = p2), (function(e3) {
    if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return false;
    const t3 = bt(), n3 = e3 || t3 && t3.getOptions();
    return !!n3 && (n3.enableTracing || "tracesSampleRate" in n3 || "tracesSampler" in n3);
  })() && (a2.sampled = String((function(e3) {
    const { traceFlags: t3 } = e3.spanContext();
    return 1 === t3;
  })(n2))), t2.emit("createDsc", a2, n2), a2;
}
var Nt = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Rt(e2, t2 = false) {
  const { host: n2, path: r3, pass: i2, port: o2, projectId: s2, protocol: a2, publicKey: c2 } = e2;
  return `${a2}://${c2}${t2 && i2 ? `:${i2}` : ""}@${n2}${o2 ? `:${o2}` : ""}/${r3 ? `${r3}/` : r3}${s2}`;
}
function Ft(e2) {
  return { protocol: e2.protocol, publicKey: e2.publicKey || "", pass: e2.pass || "", host: e2.host, port: e2.port || "", path: e2.path || "", projectId: e2.projectId };
}
function Bt(e2) {
  const t2 = "string" == typeof e2 ? (function(e3) {
    const t3 = Nt.exec(e3);
    if (!t3) return void G((() => {
      console.error(`Invalid Sentry Dsn: ${e3}`);
    }));
    const [n2, r3, i2 = "", o2 = "", s2 = "", a2 = ""] = t3.slice(1);
    let c2 = "", l2 = a2;
    const u2 = l2.split("/");
    if (u2.length > 1 && (c2 = u2.slice(0, -1).join("/"), l2 = u2.pop()), l2) {
      const e4 = l2.match(/^\d+/);
      e4 && (l2 = e4[0]);
    }
    return Ft({ host: o2, pass: i2, path: c2, projectId: l2, port: s2, protocol: n2, publicKey: r3 });
  })(e2) : Ft(e2);
  if (t2 && (function(e3) {
    if (!z) return true;
    const { port: t3, projectId: n2, protocol: r3 } = e3;
    return !(["protocol", "publicKey", "host", "projectId"].find(((t4) => !e3[t4] && (Q.error(`Invalid Sentry Dsn: ${t4} missing`), true))) || (n2.match(/^\d+$/) ? /* @__PURE__ */ (function(e4) {
      return "http" === e4 || "https" === e4;
    })(r3) ? t3 && isNaN(parseInt(t3, 10)) && (Q.error(`Invalid Sentry Dsn: Invalid port ${t3}`), 1) : (Q.error(`Invalid Sentry Dsn: Invalid protocol ${r3}`), 1) : (Q.error(`Invalid Sentry Dsn: Invalid projectId ${n2}`), 1)));
  })(t2)) return t2;
}
function Ut(e2, t2 = 100, n2 = 1 / 0) {
  try {
    return Jt("", e2, t2, n2);
  } catch (e3) {
    return { ERROR: `**non-serializable** (${e3})` };
  }
}
function Vt(e2, t2 = 3, n2 = 102400) {
  const r3 = Ut(e2, t2);
  return i2 = r3, (function(e3) {
    return ~-encodeURI(e3).split(/%..|./).length;
  })(JSON.stringify(i2)) > n2 ? Vt(e2, t2 - 1, n2) : r3;
  var i2;
}
function Jt(e2, t2, n2 = 1 / 0, r3 = 1 / 0, i2 = /* @__PURE__ */ (function() {
  const e3 = "function" == typeof WeakSet, t3 = e3 ? /* @__PURE__ */ new WeakSet() : [];
  return [function(n3) {
    if (e3) return !!t3.has(n3) || (t3.add(n3), false);
    for (let e4 = 0; e4 < t3.length; e4++) if (t3[e4] === n3) return true;
    return t3.push(n3), false;
  }, function(n3) {
    if (e3) t3.delete(n3);
    else for (let e4 = 0; e4 < t3.length; e4++) if (t3[e4] === n3) {
      t3.splice(e4, 1);
      break;
    }
  }];
})()) {
  const [o2, s2] = i2;
  if (null == t2 || ["boolean", "string"].includes(typeof t2) || "number" == typeof t2 && Number.isFinite(t2)) return t2;
  const a2 = (function(e3, t3) {
    try {
      if ("domain" === e3 && t3 && "object" == typeof t3 && t3._events) return "[Domain]";
      if ("domainEmitter" === e3) return "[DomainEmitter]";
      if ("undefined" != typeof global && t3 === global) return "[Global]";
      if ("undefined" != typeof window && t3 === window) return "[Window]";
      if ("undefined" != typeof document && t3 === document) return "[Document]";
      if (Ee(t3)) return "[VueViewModel]";
      if (Se(n3 = t3) && "nativeEvent" in n3 && "preventDefault" in n3 && "stopPropagation" in n3) return "[SyntheticEvent]";
      if ("number" == typeof t3 && !Number.isFinite(t3)) return `[${t3}]`;
      if ("function" == typeof t3) return `[Function: ${te(t3)}]`;
      if ("symbol" == typeof t3) return `[${String(t3)}]`;
      if ("bigint" == typeof t3) return `[BigInt: ${String(t3)}]`;
      const r4 = (function(e4) {
        const t4 = Object.getPrototypeOf(e4);
        return t4 ? t4.constructor.name : "null prototype";
      })(t3);
      return /^HTML(\w*)Element$/.test(r4) ? `[HTMLElement: ${r4}]` : `[object ${r4}]`;
    } catch (e4) {
      return `**non-serializable** (${e4})`;
    }
    var n3;
  })(e2, t2);
  if (!a2.startsWith("[object ")) return a2;
  if (t2.__sentry_skip_normalization__) return t2;
  const c2 = "number" == typeof t2.__sentry_override_normalization_depth__ ? t2.__sentry_override_normalization_depth__ : n2;
  if (0 === c2) return a2.replace("object ", "");
  if (o2(t2)) return "[Circular ~]";
  const l2 = t2;
  if (l2 && "function" == typeof l2.toJSON) try {
    return Jt("", l2.toJSON(), c2 - 1, r3, i2);
  } catch (e3) {
  }
  const u2 = Array.isArray(t2) ? [] : {};
  let d2 = 0;
  const p2 = Fe(t2);
  for (const e3 in p2) {
    if (!Object.prototype.hasOwnProperty.call(p2, e3)) continue;
    if (d2 >= r3) {
      u2[e3] = "[MaxProperties ~]";
      break;
    }
    const t3 = p2[e3];
    u2[e3] = Jt(e3, t3, c2 - 1, r3, i2), d2++;
  }
  return s2(t2), u2;
}
function $t(e2, t2 = []) {
  return [e2, t2];
}
function qt(e2, t2) {
  const [n2, r3] = e2;
  return [n2, [...r3, t2]];
}
function zt(e2, t2) {
  const n2 = e2[1];
  for (const e3 of n2) {
    if (t2(e3, e3[0].type)) return true;
  }
  return false;
}
function Wt(e2) {
  return $.__SENTRY__ && $.__SENTRY__.encodePolyfill ? $.__SENTRY__.encodePolyfill(e2) : new TextEncoder().encode(e2);
}
function Ht(e2) {
  const [t2, n2] = e2;
  let r3 = JSON.stringify(t2);
  function i2(e3) {
    "string" == typeof r3 ? r3 = "string" == typeof e3 ? r3 + e3 : [Wt(r3), e3] : r3.push("string" == typeof e3 ? Wt(e3) : e3);
  }
  for (const e3 of n2) {
    const [t3, n3] = e3;
    if (i2(`
${JSON.stringify(t3)}
`), "string" == typeof n3 || n3 instanceof Uint8Array) i2(n3);
    else {
      let e4;
      try {
        e4 = JSON.stringify(n3);
      } catch (t4) {
        e4 = JSON.stringify(Ut(n3));
      }
      i2(e4);
    }
  }
  return "string" == typeof r3 ? r3 : (function(e3) {
    const t3 = e3.reduce(((e4, t4) => e4 + t4.length), 0), n3 = new Uint8Array(t3);
    let r4 = 0;
    for (const t4 of e3) n3.set(t4, r4), r4 += t4.length;
    return n3;
  })(r3);
}
function Gt(e2) {
  const t2 = "string" == typeof e2.data ? Wt(e2.data) : e2.data;
  return [Ve({ type: "attachment", length: t2.length, filename: e2.filename, content_type: e2.contentType, attachment_type: e2.attachmentType }), t2];
}
var Qt = { session: "session", sessions: "session", attachment: "attachment", transaction: "transaction", event: "error", client_report: "internal", user_report: "default", profile: "profile", profile_chunk: "profile", replay_event: "replay", replay_recording: "replay", check_in: "monitor", feedback: "feedback", span: "span", statsd: "metric_bucket", raw_security: "security" };
function Kt(e2) {
  return Qt[e2];
}
function Yt(e2) {
  if (!e2 || !e2.sdk) return;
  const { name: t2, version: n2 } = e2.sdk;
  return { name: t2, version: n2 };
}
function Xt(e2, t2, n2, r3) {
  const i2 = Yt(n2), o2 = e2.type && "replay_event" !== e2.type ? e2.type : "event";
  !(function(e3, t3) {
    t3 && (e3.sdk = e3.sdk || {}, e3.sdk.name = e3.sdk.name || t3.name, e3.sdk.version = e3.sdk.version || t3.version, e3.sdk.integrations = [...e3.sdk.integrations || [], ...t3.integrations || []], e3.sdk.packages = [...e3.sdk.packages || [], ...t3.packages || []]);
  })(e2, n2 && n2.sdk);
  const s2 = (function(e3, t3, n3, r4) {
    const i3 = e3.sdkProcessingMetadata && e3.sdkProcessingMetadata.dynamicSamplingContext;
    return { event_id: e3.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t3 && { sdk: t3 }, ...!!n3 && r4 && { dsn: Rt(r4) }, ...i3 && { trace: Ve({ ...i3 }) } };
  })(e2, i2, r3, t2);
  delete e2.sdkProcessingMetadata;
  return $t(s2, [[{ type: o2 }, e2]]);
}
function Zt(e2, t2, n2, r3 = 0) {
  return new et(((i2, o2) => {
    const s2 = e2[r3];
    if (null === t2 || "function" != typeof s2) i2(t2);
    else {
      const a2 = s2({ ...t2 }, n2);
      V && s2.id && null === a2 && Q.log(`Event processor "${s2.id}" dropped event`), Me(a2) ? a2.then(((t3) => Zt(e2, t3, n2, r3 + 1).then(i2))).then(null, o2) : Zt(e2, a2, n2, r3 + 1).then(i2).then(null, o2);
    }
  }));
}
var en;
var tn;
var nn;
function rn(e2, t2) {
  const { fingerprint: n2, span: r3, breadcrumbs: i2, sdkProcessingMetadata: o2 } = t2;
  !(function(e3, t3) {
    const { extra: n3, tags: r4, user: i3, contexts: o3, level: s2, transactionName: a2 } = t3, c2 = Ve(n3);
    c2 && Object.keys(c2).length && (e3.extra = { ...c2, ...e3.extra });
    const l2 = Ve(r4);
    l2 && Object.keys(l2).length && (e3.tags = { ...l2, ...e3.tags });
    const u2 = Ve(i3);
    u2 && Object.keys(u2).length && (e3.user = { ...u2, ...e3.user });
    const d2 = Ve(o3);
    d2 && Object.keys(d2).length && (e3.contexts = { ...d2, ...e3.contexts });
    s2 && (e3.level = s2);
    a2 && "transaction" !== e3.type && (e3.transaction = a2);
  })(e2, t2), r3 && (function(e3, t3) {
    e3.contexts = { trace: Et(t3), ...e3.contexts }, e3.sdkProcessingMetadata = { dynamicSamplingContext: Dt(t3), ...e3.sdkProcessingMetadata };
    const n3 = jt(t3), r4 = Pt(n3).description;
    r4 && !e3.transaction && "transaction" === e3.type && (e3.transaction = r4);
  })(e2, r3), (function(e3, t3) {
    e3.fingerprint = e3.fingerprint ? Array.isArray(e3.fingerprint) ? e3.fingerprint : [e3.fingerprint] : [], t3 && (e3.fingerprint = e3.fingerprint.concat(t3));
    e3.fingerprint && !e3.fingerprint.length && delete e3.fingerprint;
  })(e2, n2), (function(e3, t3) {
    const n3 = [...e3.breadcrumbs || [], ...t3];
    e3.breadcrumbs = n3.length ? n3 : void 0;
  })(e2, i2), (function(e3, t3) {
    e3.sdkProcessingMetadata = { ...e3.sdkProcessingMetadata, ...t3 };
  })(e2, o2);
}
function on(e2, t2) {
  const { extra: n2, tags: r3, user: i2, contexts: o2, level: s2, sdkProcessingMetadata: a2, breadcrumbs: c2, fingerprint: l2, eventProcessors: u2, attachments: d2, propagationContext: p2, transactionName: h3, span: f2 } = t2;
  sn(e2, "extra", n2), sn(e2, "tags", r3), sn(e2, "user", i2), sn(e2, "contexts", o2), e2.sdkProcessingMetadata = ot(e2.sdkProcessingMetadata, a2, 2), s2 && (e2.level = s2), h3 && (e2.transactionName = h3), f2 && (e2.span = f2), c2.length && (e2.breadcrumbs = [...e2.breadcrumbs, ...c2]), l2.length && (e2.fingerprint = [...e2.fingerprint, ...l2]), u2.length && (e2.eventProcessors = [...e2.eventProcessors, ...u2]), d2.length && (e2.attachments = [...e2.attachments, ...d2]), e2.propagationContext = { ...e2.propagationContext, ...p2 };
}
function sn(e2, t2, n2) {
  e2[t2] = ot(e2[t2], n2, 1);
}
function an(e2, t2, n2, r3, i2, o2) {
  const { normalizeDepth: s2 = 3, normalizeMaxBreadth: a2 = 1e3 } = e2, c2 = { ...t2, event_id: t2.event_id || n2.event_id || ze(), timestamp: t2.timestamp || $e() }, l2 = n2.integrations || e2.integrations.map(((e3) => e3.name));
  !(function(e3, t3) {
    const { environment: n3, release: r4, dist: i3, maxValueLength: o3 = 250 } = t3;
    e3.environment = e3.environment || n3 || xt, !e3.release && r4 && (e3.release = r4);
    !e3.dist && i3 && (e3.dist = i3);
    e3.message && (e3.message = Ae(e3.message, o3));
    const s3 = e3.exception && e3.exception.values && e3.exception.values[0];
    s3 && s3.value && (s3.value = Ae(s3.value, o3));
    const a3 = e3.request;
    a3 && a3.url && (a3.url = Ae(a3.url, o3));
  })(c2, e2), (function(e3, t3) {
    t3.length > 0 && (e3.sdk = e3.sdk || {}, e3.sdk.integrations = [...e3.sdk.integrations || [], ...t3]);
  })(c2, l2), i2 && i2.emit("applyFrameMetadata", t2), void 0 === t2.type && (function(e3, t3) {
    const n3 = (function(e4) {
      const t4 = $._sentryDebugIds;
      if (!t4) return {};
      const n4 = Object.keys(t4);
      return nn && n4.length === tn || (tn = n4.length, nn = n4.reduce(((n5, r4) => {
        en || (en = {});
        const i3 = en[r4];
        if (i3) n5[i3[0]] = i3[1];
        else {
          const i4 = e4(r4);
          for (let e5 = i4.length - 1; e5 >= 0; e5--) {
            const o3 = i4[e5], s3 = o3 && o3.filename, a3 = t4[r4];
            if (s3 && a3) {
              n5[s3] = a3, en[r4] = [s3, a3];
              break;
            }
          }
        }
        return n5;
      }), {})), nn;
    })(t3);
    try {
      e3.exception.values.forEach(((e4) => {
        e4.stacktrace.frames.forEach(((e5) => {
          n3 && e5.filename && (e5.debug_id = n3[e5.filename]);
        }));
      }));
    } catch (e4) {
    }
  })(c2, e2.stackParser);
  const u2 = (function(e3, t3) {
    if (!t3) return e3;
    const n3 = e3 ? e3.clone() : new ut();
    return n3.update(t3), n3;
  })(r3, n2.captureContext);
  n2.mechanism && Qe(c2, n2.mechanism);
  const d2 = i2 ? i2.getEventProcessors() : [], p2 = q("globalScope", (() => new ut())).getScopeData();
  if (o2) {
    on(p2, o2.getScopeData());
  }
  if (u2) {
    on(p2, u2.getScopeData());
  }
  const h3 = [...n2.attachments || [], ...p2.attachments];
  h3.length && (n2.attachments = h3), rn(c2, p2);
  return Zt([...d2, ...p2.eventProcessors], c2, n2).then(((e3) => (e3 && (function(e4) {
    const t3 = {};
    try {
      e4.exception.values.forEach(((e5) => {
        e5.stacktrace.frames.forEach(((e6) => {
          e6.debug_id && (e6.abs_path ? t3[e6.abs_path] = e6.debug_id : e6.filename && (t3[e6.filename] = e6.debug_id), delete e6.debug_id);
        }));
      }));
    } catch (e5) {
    }
    if (0 === Object.keys(t3).length) return;
    e4.debug_meta = e4.debug_meta || {}, e4.debug_meta.images = e4.debug_meta.images || [];
    const n3 = e4.debug_meta.images;
    Object.entries(t3).forEach((([e5, t4]) => {
      n3.push({ type: "sourcemap", code_file: e5, debug_id: t4 });
    }));
  })(e3), "number" == typeof s2 && s2 > 0 ? (function(e4, t3, n3) {
    if (!e4) return null;
    const r4 = { ...e4, ...e4.breadcrumbs && { breadcrumbs: e4.breadcrumbs.map(((e5) => ({ ...e5, ...e5.data && { data: Ut(e5.data, t3, n3) } }))) }, ...e4.user && { user: Ut(e4.user, t3, n3) }, ...e4.contexts && { contexts: Ut(e4.contexts, t3, n3) }, ...e4.extra && { extra: Ut(e4.extra, t3, n3) } };
    e4.contexts && e4.contexts.trace && r4.contexts && (r4.contexts.trace = e4.contexts.trace, e4.contexts.trace.data && (r4.contexts.trace.data = Ut(e4.contexts.trace.data, t3, n3)));
    e4.spans && (r4.spans = e4.spans.map(((e5) => ({ ...e5, ...e5.data && { data: Ut(e5.data, t3, n3) } }))));
    e4.contexts && e4.contexts.flags && r4.contexts && (r4.contexts.flags = Ut(e4.contexts.flags, 3, n3));
    return r4;
  })(e3, s2, a2) : e3)));
}
function cn2(e2) {
  if (e2) return (function(e3) {
    return e3 instanceof ut || "function" == typeof e3;
  })(e2) || (function(e3) {
    return Object.keys(e3).some(((e4) => ln.includes(e4)));
  })(e2) ? { captureContext: e2 } : e2;
}
var ln = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
function un(e2, t2) {
  return mt().captureEvent(e2, t2);
}
function dn(e2) {
  const t2 = bt(), n2 = yt(), r3 = mt(), { release: i2, environment: o2 = xt } = t2 && t2.getOptions() || {}, { userAgent: s2 } = $.navigator || {}, a2 = tt({ release: i2, environment: o2, user: r3.getUser() || n2.getUser(), ...s2 && { userAgent: s2 }, ...e2 }), c2 = n2.getSession();
  return c2 && "ok" === c2.status && nt(c2, { status: "exited" }), pn(), n2.setSession(a2), r3.setSession(a2), a2;
}
function pn() {
  const e2 = yt(), t2 = mt(), n2 = t2.getSession() || e2.getSession();
  n2 && (function(e3, t3) {
    let n3 = {};
    t3 ? n3 = { status: t3 } : "ok" === e3.status && (n3 = { status: "exited" }), nt(e3, n3);
  })(n2), hn(), e2.setSession(), t2.setSession();
}
function hn() {
  const e2 = yt(), t2 = mt(), n2 = bt(), r3 = t2.getSession() || e2.getSession();
  r3 && n2 && n2.captureSession(r3);
}
function fn(e2 = false) {
  e2 ? pn() : hn();
}
function vn(e2, t2, n2) {
  return t2 || `${(function(e3) {
    return `${(function(e4) {
      const t3 = e4.protocol ? `${e4.protocol}:` : "", n3 = e4.port ? `:${e4.port}` : "";
      return `${t3}//${e4.host}${n3}${e4.path ? `/${e4.path}` : ""}/api/`;
    })(e3)}${e3.projectId}/envelope/`;
  })(e2)}?${(function(e3, t3) {
    const n3 = { sentry_version: "7" };
    return e3.publicKey && (n3.sentry_key = e3.publicKey), t3 && (n3.sentry_client = `${t3.name}/${t3.version}`), new URLSearchParams(n3).toString();
  })(e2, n2)}`;
}
var gn = [];
function mn(e2, t2) {
  for (const n2 of t2) n2 && n2.afterAllSetup && n2.afterAllSetup(e2);
}
function yn(e2, t2, n2) {
  if (n2[t2.name]) V && Q.log(`Integration skipped because it was already installed: ${t2.name}`);
  else {
    if (n2[t2.name] = t2, -1 === gn.indexOf(t2.name) && "function" == typeof t2.setupOnce && (t2.setupOnce(), gn.push(t2.name)), t2.setup && "function" == typeof t2.setup && t2.setup(e2), "function" == typeof t2.preprocessEvent) {
      const n3 = t2.preprocessEvent.bind(t2);
      e2.on("preprocessEvent", ((t3, r3) => n3(t3, r3, e2)));
    }
    if ("function" == typeof t2.processEvent) {
      const n3 = t2.processEvent.bind(t2), r3 = Object.assign(((t3, r4) => n3(t3, r4, e2)), { id: t2.name });
      e2.addEventProcessor(r3);
    }
    V && Q.log(`Integration installed: ${t2.name}`);
  }
}
var bn = class extends Error {
  constructor(e2, t2 = "warn") {
    super(e2), this.message = e2, this.logLevel = t2;
  }
};
var _n = "Not capturing exception because it's already been captured.";
var wn = class {
  constructor(e2) {
    if (this._options = e2, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e2.dsn ? this._dsn = Bt(e2.dsn) : V && Q.warn("No DSN provided, client will not send events."), this._dsn) {
      const t3 = vn(this._dsn, e2.tunnel, e2._metadata ? e2._metadata.sdk : void 0);
      this._transport = e2.transport({ tunnel: this._options.tunnel, recordDroppedEvent: this.recordDroppedEvent.bind(this), ...e2.transportOptions, url: t3 });
    }
    const t2 = ["enableTracing", "tracesSampleRate", "tracesSampler"].find(((t3) => t3 in e2 && null == e2[t3]));
    t2 && G((() => {
      console.warn(`[Sentry] Deprecation warning: \`${t2}\` is set to undefined, which leads to tracing being enabled. In v9, a value of \`undefined\` will result in tracing being disabled.`);
    }));
  }
  captureException(e2, t2, n2) {
    const r3 = ze();
    if (Ke(e2)) return V && Q.log(_n), r3;
    const i2 = { event_id: r3, ...t2 };
    return this._process(this.eventFromException(e2, i2).then(((e3) => this._captureEvent(e3, i2, n2)))), i2.event_id;
  }
  captureMessage(e2, t2, n2, r3) {
    const i2 = { event_id: ze(), ...n2 }, o2 = _e(e2) ? e2 : String(e2), s2 = we(e2) ? this.eventFromMessage(o2, t2, i2) : this.eventFromException(e2, i2);
    return this._process(s2.then(((e3) => this._captureEvent(e3, i2, r3)))), i2.event_id;
  }
  captureEvent(e2, t2, n2) {
    const r3 = ze();
    if (t2 && t2.originalException && Ke(t2.originalException)) return V && Q.log(_n), r3;
    const i2 = { event_id: r3, ...t2 }, o2 = (e2.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(e2, i2, o2 || n2)), i2.event_id;
  }
  captureSession(e2) {
    "string" != typeof e2.release ? V && Q.warn("Discarded session because of missing or non-string release") : (this.sendSession(e2), nt(e2, { init: false }));
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  flush(e2) {
    const t2 = this._transport;
    return t2 ? (this.emit("flush"), this._isClientDoneProcessing(e2).then(((n2) => t2.flush(e2).then(((e3) => n2 && e3))))) : Xe(true);
  }
  close(e2) {
    return this.flush(e2).then(((e3) => (this.getOptions().enabled = false, this.emit("close"), e3)));
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(e2) {
    this._eventProcessors.push(e2);
  }
  init() {
    (this._isEnabled() || this._options.integrations.some((({ name: e2 }) => e2.startsWith("Spotlight")))) && this._setupIntegrations();
  }
  getIntegrationByName(e2) {
    return this._integrations[e2];
  }
  addIntegration(e2) {
    const t2 = this._integrations[e2.name];
    yn(this, e2, this._integrations), t2 || mn(this, [e2]);
  }
  sendEvent(e2, t2 = {}) {
    this.emit("beforeSendEvent", e2, t2);
    let n2 = Xt(e2, this._dsn, this._options._metadata, this._options.tunnel);
    for (const e3 of t2.attachments || []) n2 = qt(n2, Gt(e3));
    const r3 = this.sendEnvelope(n2);
    r3 && r3.then(((t3) => this.emit("afterSendEvent", e2, t3)), null);
  }
  sendSession(e2) {
    const t2 = (function(e3, t3, n2, r3) {
      const i2 = Yt(n2);
      return $t({ sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...i2 && { sdk: i2 }, ...!!r3 && t3 && { dsn: Rt(t3) } }, ["aggregates" in e3 ? [{ type: "sessions" }, e3] : [{ type: "session" }, e3.toJSON()]]);
    })(e2, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(t2);
  }
  recordDroppedEvent(e2, t2, n2) {
    if (this._options.sendClientReports) {
      const r3 = "number" == typeof n2 ? n2 : 1, i2 = `${e2}:${t2}`;
      V && Q.log(`Recording outcome: "${i2}"${r3 > 1 ? ` (${r3} times)` : ""}`), this._outcomes[i2] = (this._outcomes[i2] || 0) + r3;
    }
  }
  on(e2, t2) {
    const n2 = this._hooks[e2] = this._hooks[e2] || [];
    return n2.push(t2), () => {
      const e3 = n2.indexOf(t2);
      e3 > -1 && n2.splice(e3, 1);
    };
  }
  emit(e2, ...t2) {
    const n2 = this._hooks[e2];
    n2 && n2.forEach(((e3) => e3(...t2)));
  }
  sendEnvelope(e2) {
    return this.emit("beforeEnvelope", e2), this._isEnabled() && this._transport ? this._transport.send(e2).then(null, ((e3) => (V && Q.error("Error while sending envelope:", e3), e3))) : (V && Q.error("Transport disabled"), Xe({}));
  }
  _setupIntegrations() {
    const { integrations: e2 } = this._options;
    this._integrations = (function(e3, t2) {
      const n2 = {};
      return t2.forEach(((t3) => {
        t3 && yn(e3, t3, n2);
      })), n2;
    })(this, e2), mn(this, e2);
  }
  _updateSessionFromEvent(e2, t2) {
    let n2 = "fatal" === t2.level, r3 = false;
    const i2 = t2.exception && t2.exception.values;
    if (i2) {
      r3 = true;
      for (const e3 of i2) {
        const t3 = e3.mechanism;
        if (t3 && false === t3.handled) {
          n2 = true;
          break;
        }
      }
    }
    const o2 = "ok" === e2.status;
    (o2 && 0 === e2.errors || o2 && n2) && (nt(e2, { ...n2 && { status: "crashed" }, errors: e2.errors || Number(r3 || n2) }), this.captureSession(e2));
  }
  _isClientDoneProcessing(e2) {
    return new et(((t2) => {
      let n2 = 0;
      const r3 = setInterval((() => {
        0 == this._numProcessing ? (clearInterval(r3), t2(true)) : (n2 += 1, e2 && n2 >= e2 && (clearInterval(r3), t2(false)));
      }), 1);
    }));
  }
  _isEnabled() {
    return false !== this.getOptions().enabled && void 0 !== this._transport;
  }
  _prepareEvent(e2, t2, n2 = mt(), r3 = yt()) {
    const i2 = this.getOptions(), o2 = Object.keys(this._integrations);
    return !t2.integrations && o2.length > 0 && (t2.integrations = o2), this.emit("preprocessEvent", e2, t2), e2.type || r3.setLastEventId(e2.event_id || t2.event_id), an(i2, e2, t2, n2, this, r3).then(((e3) => {
      if (null === e3) return e3;
      e3.contexts = { trace: _t(n2), ...e3.contexts };
      const t3 = (function(e4, t4) {
        const n3 = t4.getPropagationContext();
        return n3.dsc || Lt(n3.traceId, e4);
      })(this, n2);
      return e3.sdkProcessingMetadata = { dynamicSamplingContext: t3, ...e3.sdkProcessingMetadata }, e3;
    }));
  }
  _captureEvent(e2, t2 = {}, n2) {
    return this._processEvent(e2, t2, n2).then(((e3) => e3.event_id), ((e3) => {
      V && (e3 instanceof bn && "log" === e3.logLevel ? Q.log(e3.message) : Q.warn(e3));
    }));
  }
  _processEvent(e2, t2, n2) {
    const r3 = this.getOptions(), { sampleRate: i2 } = r3, o2 = kn(e2), s2 = Sn(e2), a2 = e2.type || "error", c2 = `before send for type \`${a2}\``, l2 = void 0 === i2 ? void 0 : (function(e3) {
      if ("boolean" == typeof e3) return Number(e3);
      const t3 = "string" == typeof e3 ? parseFloat(e3) : e3;
      if (!("number" != typeof t3 || isNaN(t3) || t3 < 0 || t3 > 1)) return t3;
      V && Q.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e3)} of type ${JSON.stringify(typeof e3)}.`);
    })(i2);
    if (s2 && "number" == typeof l2 && Math.random() > l2) return this.recordDroppedEvent("sample_rate", "error", e2), Ze(new bn(`Discarding event because it's not included in the random sample (sampling rate = ${i2})`, "log"));
    const u2 = "replay_event" === a2 ? "replay" : a2, d2 = (e2.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(e2, t2, n2, d2).then(((n3) => {
      if (null === n3) throw this.recordDroppedEvent("event_processor", u2, e2), new bn("An event processor returned `null`, will not send event.", "log");
      if (t2.data && true === t2.data.__sentry__) return n3;
      const i3 = (function(e3, t3, n4, r4) {
        const { beforeSend: i4, beforeSendTransaction: o3, beforeSendSpan: s3 } = t3;
        if (Sn(n4) && i4) return i4(n4, r4);
        if (kn(n4)) {
          if (n4.spans && s3) {
            const t4 = [];
            for (const r5 of n4.spans) {
              const n5 = s3(r5);
              n5 ? t4.push(n5) : (It(), e3.recordDroppedEvent("before_send", "span"));
            }
            n4.spans = t4;
          }
          if (o3) {
            if (n4.spans) {
              const e4 = n4.spans.length;
              n4.sdkProcessingMetadata = { ...n4.sdkProcessingMetadata, spanCountBeforeProcessing: e4 };
            }
            return o3(n4, r4);
          }
        }
        return n4;
      })(this, r3, n3, t2);
      return (function(e3, t3) {
        const n4 = `${t3} must return \`null\` or a valid event.`;
        if (Me(e3)) return e3.then(((e4) => {
          if (!Se(e4) && null !== e4) throw new bn(n4);
          return e4;
        }), ((e4) => {
          throw new bn(`${t3} rejected with ${e4}`);
        }));
        if (!Se(e3) && null !== e3) throw new bn(n4);
        return e3;
      })(i3, c2);
    })).then(((r4) => {
      if (null === r4) {
        if (this.recordDroppedEvent("before_send", u2, e2), o2) {
          const t3 = 1 + (e2.spans || []).length;
          this.recordDroppedEvent("before_send", "span", t3);
        }
        throw new bn(`${c2} returned \`null\`, will not send event.`, "log");
      }
      const i3 = n2 && n2.getSession();
      if (!o2 && i3 && this._updateSessionFromEvent(i3, r4), o2) {
        const e3 = (r4.sdkProcessingMetadata && r4.sdkProcessingMetadata.spanCountBeforeProcessing || 0) - (r4.spans ? r4.spans.length : 0);
        e3 > 0 && this.recordDroppedEvent("before_send", "span", e3);
      }
      const s3 = r4.transaction_info;
      if (o2 && s3 && r4.transaction !== e2.transaction) {
        const e3 = "custom";
        r4.transaction_info = { ...s3, source: e3 };
      }
      return this.sendEvent(r4, t2), r4;
    })).then(null, ((e3) => {
      if (e3 instanceof bn) throw e3;
      throw this.captureException(e3, { data: { __sentry__: true }, originalException: e3 }), new bn(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${e3}`);
    }));
  }
  _process(e2) {
    this._numProcessing++, e2.then(((e3) => (this._numProcessing--, e3)), ((e3) => (this._numProcessing--, e3)));
  }
  _clearOutcomes() {
    const e2 = this._outcomes;
    return this._outcomes = {}, Object.entries(e2).map((([e3, t2]) => {
      const [n2, r3] = e3.split(":");
      return { reason: n2, category: r3, quantity: t2 };
    }));
  }
  _flushOutcomes() {
    V && Q.log("Flushing outcomes...");
    const e2 = this._clearOutcomes();
    if (0 === e2.length) return void (V && Q.log("No outcomes to send"));
    if (!this._dsn) return void (V && Q.log("No dsn provided, will not send outcomes"));
    V && Q.log("Sending outcomes:", e2);
    const t2 = (n2 = e2, $t((r3 = this._options.tunnel && Rt(this._dsn)) ? { dsn: r3 } : {}, [[{ type: "client_report" }, { timestamp: i2 || $e(), discarded_events: n2 }]]));
    var n2, r3, i2;
    this.sendEnvelope(t2);
  }
};
function Sn(e2) {
  return void 0 === e2.type;
}
function kn(e2) {
  return "transaction" === e2.type;
}
function Mn(e2) {
  const t2 = [];
  function n2(e3) {
    return t2.splice(t2.indexOf(e3), 1)[0] || Promise.resolve(void 0);
  }
  return { $: t2, add: function(r3) {
    if (!(void 0 === e2 || t2.length < e2)) return Ze(new bn("Not adding Promise because buffer limit was reached."));
    const i2 = r3();
    return -1 === t2.indexOf(i2) && t2.push(i2), i2.then((() => n2(i2))).then(null, (() => n2(i2).then(null, (() => {
    })))), i2;
  }, drain: function(e3) {
    return new et(((n3, r3) => {
      let i2 = t2.length;
      if (!i2) return n3(true);
      const o2 = setTimeout((() => {
        e3 && e3 > 0 && n3(false);
      }), e3);
      t2.forEach(((e4) => {
        Xe(e4).then((() => {
          --i2 || (clearTimeout(o2), n3(true));
        }), r3);
      }));
    }));
  } };
}
function Cn(e2, { statusCode: t2, headers: n2 }, r3 = Date.now()) {
  const i2 = { ...e2 }, o2 = n2 && n2["x-sentry-rate-limits"], s2 = n2 && n2["retry-after"];
  if (o2) for (const e3 of o2.trim().split(",")) {
    const [t3, n3, , , o3] = e3.split(":", 5), s3 = parseInt(t3, 10), a2 = 1e3 * (isNaN(s3) ? 60 : s3);
    if (n3) for (const e4 of n3.split(";")) "metric_bucket" === e4 && o3 && !o3.split(";").includes("custom") || (i2[e4] = r3 + a2);
    else i2.all = r3 + a2;
  }
  else s2 ? i2.all = r3 + (function(e3, t3 = Date.now()) {
    const n3 = parseInt(`${e3}`, 10);
    if (!isNaN(n3)) return 1e3 * n3;
    const r4 = Date.parse(`${e3}`);
    return isNaN(r4) ? 6e4 : r4 - t3;
  })(s2, r3) : 429 === t2 && (i2.all = r3 + 6e4);
  return i2;
}
function En(e2, t2, n2 = Mn(e2.bufferSize || 64)) {
  let r3 = {};
  return { send: function(i2) {
    const o2 = [];
    if (zt(i2, ((t3, n3) => {
      const i3 = Kt(n3);
      if ((function(e3, t4, n4 = Date.now()) {
        return (function(e4, t5) {
          return e4[t5] || e4.all || 0;
        })(e3, t4) > n4;
      })(r3, i3)) {
        const r4 = Tn(t3, n3);
        e2.recordDroppedEvent("ratelimit_backoff", i3, r4);
      } else o2.push(t3);
    })), 0 === o2.length) return Xe({});
    const s2 = $t(i2[0], o2), a2 = (t3) => {
      zt(s2, ((n3, r4) => {
        const i3 = Tn(n3, r4);
        e2.recordDroppedEvent(t3, Kt(r4), i3);
      }));
    };
    return n2.add((() => t2({ body: Ht(s2) }).then(((e3) => (void 0 !== e3.statusCode && (e3.statusCode < 200 || e3.statusCode >= 300) && V && Q.warn(`Sentry responded with status code ${e3.statusCode} to sent event.`), r3 = Cn(r3, e3), e3)), ((e3) => {
      throw a2("network_error"), e3;
    })))).then(((e3) => e3), ((e3) => {
      if (e3 instanceof bn) return V && Q.error("Skipped sending event because buffer is full."), a2("queue_overflow"), Xe({});
      throw e3;
    }));
  }, flush: (e3) => n2.drain(e3) };
}
function Tn(e2, t2) {
  if ("event" === t2 || "transaction" === t2) return Array.isArray(e2) ? e2[1] : void 0;
}
var On = 100;
function Pn(e2, t2) {
  const n2 = bt(), r3 = yt();
  if (!n2) return;
  const { beforeBreadcrumb: i2 = null, maxBreadcrumbs: o2 = On } = n2.getOptions();
  if (o2 <= 0) return;
  const s2 = { timestamp: $e(), ...e2 }, a2 = i2 ? G((() => i2(s2, t2))) : s2;
  null !== a2 && (n2.emit && n2.emit("beforeAddBreadcrumb", a2, t2), r3.addBreadcrumb(a2, o2));
}
var An;
var jn = /* @__PURE__ */ new WeakMap();
var In = () => ({ name: "FunctionToString", setupOnce() {
  An = Function.prototype.toString;
  try {
    Function.prototype.toString = function(...e2) {
      const t2 = Re(this), n2 = jn.has(bt()) && void 0 !== t2 ? t2 : this;
      return An.apply(n2, e2);
    };
  } catch (e2) {
  }
}, setup(e2) {
  jn.set(e2, true);
} });
var xn = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/];
var Ln = (e2 = {}) => ({ name: "InboundFilters", processEvent(t2, n2, r3) {
  const i2 = r3.getOptions(), o2 = (function(e3 = {}, t3 = {}) {
    return { allowUrls: [...e3.allowUrls || [], ...t3.allowUrls || []], denyUrls: [...e3.denyUrls || [], ...t3.denyUrls || []], ignoreErrors: [...e3.ignoreErrors || [], ...t3.ignoreErrors || [], ...e3.disableErrorDefaults ? [] : xn], ignoreTransactions: [...e3.ignoreTransactions || [], ...t3.ignoreTransactions || []], ignoreInternal: void 0 === e3.ignoreInternal || e3.ignoreInternal };
  })(e2, i2);
  return (function(e3, t3) {
    if (t3.ignoreInternal && (function(e4) {
      try {
        return "SentryError" === e4.exception.values[0].type;
      } catch (e5) {
      }
      return false;
    })(e3)) return V && Q.warn(`Event dropped due to being internal Sentry Error.
Event: ${He(e3)}`), true;
    if ((function(e4, t4) {
      if (e4.type || !t4 || !t4.length) return false;
      return (function(e5) {
        const t5 = [];
        e5.message && t5.push(e5.message);
        let n3;
        try {
          n3 = e5.exception.values[e5.exception.values.length - 1];
        } catch (e6) {
        }
        n3 && n3.value && (t5.push(n3.value), n3.type && t5.push(`${n3.type}: ${n3.value}`));
        return t5;
      })(e4).some(((e5) => xe(e5, t4)));
    })(e3, t3.ignoreErrors)) return V && Q.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${He(e3)}`), true;
    if ((function(e4) {
      if (e4.type) return false;
      if (!e4.exception || !e4.exception.values || 0 === e4.exception.values.length) return false;
      return !e4.message && !e4.exception.values.some(((e5) => e5.stacktrace || e5.type && "Error" !== e5.type || e5.value));
    })(e3)) return V && Q.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${He(e3)}`), true;
    if ((function(e4, t4) {
      if ("transaction" !== e4.type || !t4 || !t4.length) return false;
      const n3 = e4.transaction;
      return !!n3 && xe(n3, t4);
    })(e3, t3.ignoreTransactions)) return V && Q.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${He(e3)}`), true;
    if ((function(e4, t4) {
      if (!t4 || !t4.length) return false;
      const n3 = Dn(e4);
      return !!n3 && xe(n3, t4);
    })(e3, t3.denyUrls)) return V && Q.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${He(e3)}.
Url: ${Dn(e3)}`), true;
    if (!(function(e4, t4) {
      if (!t4 || !t4.length) return true;
      const n3 = Dn(e4);
      return !n3 || xe(n3, t4);
    })(e3, t3.allowUrls)) return V && Q.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${He(e3)}.
Url: ${Dn(e3)}`), true;
    return false;
  })(t2, o2) ? null : t2;
} });
function Dn(e2) {
  try {
    let t2;
    try {
      t2 = e2.exception.values[0].stacktrace.frames;
    } catch (e3) {
    }
    return t2 ? (function(e3 = []) {
      for (let t3 = e3.length - 1; t3 >= 0; t3--) {
        const n2 = e3[t3];
        if (n2 && "<anonymous>" !== n2.filename && "[native code]" !== n2.filename) return n2.filename || null;
      }
      return null;
    })(t2) : null;
  } catch (t2) {
    return V && Q.error(`Cannot extract url for event ${He(e2)}`), null;
  }
}
function Nn(e2, t2, n2 = 250, r3, i2, o2, s2) {
  if (!(o2.exception && o2.exception.values && s2 && Ce(s2.originalException, Error))) return;
  const a2 = o2.exception.values.length > 0 ? o2.exception.values[o2.exception.values.length - 1] : void 0;
  var c2, l2;
  a2 && (o2.exception.values = (c2 = Rn(e2, t2, i2, s2.originalException, r3, o2.exception.values, a2, 0), l2 = n2, c2.map(((e3) => (e3.value && (e3.value = Ae(e3.value, l2)), e3)))));
}
function Rn(e2, t2, n2, r3, i2, o2, s2, a2) {
  if (o2.length >= n2 + 1) return o2;
  let c2 = [...o2];
  if (Ce(r3[i2], Error)) {
    Fn(s2, a2);
    const o3 = e2(t2, r3[i2]), l2 = c2.length;
    Bn(o3, i2, l2, a2), c2 = Rn(e2, t2, n2, r3[i2], i2, [o3, ...c2], o3, l2);
  }
  return Array.isArray(r3.errors) && r3.errors.forEach(((r4, o3) => {
    if (Ce(r4, Error)) {
      Fn(s2, a2);
      const l2 = e2(t2, r4), u2 = c2.length;
      Bn(l2, `errors[${o3}]`, u2, a2), c2 = Rn(e2, t2, n2, r4, i2, [l2, ...c2], l2, u2);
    }
  })), c2;
}
function Fn(e2, t2) {
  e2.mechanism = e2.mechanism || { type: "generic", handled: true }, e2.mechanism = { ...e2.mechanism, ..."AggregateError" === e2.type && { is_exception_group: true }, exception_id: t2 };
}
function Bn(e2, t2, n2, r3) {
  e2.mechanism = e2.mechanism || { type: "generic", handled: true }, e2.mechanism = { ...e2.mechanism, type: "chained", source: t2, exception_id: n2, parent_id: r3 };
}
function Un(e2) {
  if (!e2) return {};
  const t2 = e2.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t2) return {};
  const n2 = t2[6] || "", r3 = t2[8] || "";
  return { host: t2[4], path: t2[5], protocol: t2[2], search: n2, hash: r3, relative: t2[5] + n2 + r3 };
}
function Vn() {
  "console" in $ && W.forEach((function(e2) {
    e2 in $.console && Le($.console, e2, (function(t2) {
      return H[e2] = t2, function(...t3) {
        ae("console", { args: t3, level: e2 });
        const n2 = H[e2];
        n2 && n2.apply($.console, t3);
      };
    }));
  }));
}
function Jn(e2) {
  return "warn" === e2 ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(e2) ? e2 : "log";
}
var $n = () => {
  let e2;
  return { name: "Dedupe", processEvent(t2) {
    if (t2.type) return t2;
    try {
      if ((function(e3, t3) {
        if (!t3) return false;
        if ((function(e4, t4) {
          const n2 = e4.message, r3 = t4.message;
          if (!n2 && !r3) return false;
          if (n2 && !r3 || !n2 && r3) return false;
          if (n2 !== r3) return false;
          if (!zn(e4, t4)) return false;
          if (!qn(e4, t4)) return false;
          return true;
        })(e3, t3)) return true;
        if ((function(e4, t4) {
          const n2 = Wn(t4), r3 = Wn(e4);
          if (!n2 || !r3) return false;
          if (n2.type !== r3.type || n2.value !== r3.value) return false;
          if (!zn(e4, t4)) return false;
          if (!qn(e4, t4)) return false;
          return true;
        })(e3, t3)) return true;
        return false;
      })(t2, e2)) return V && Q.warn("Event dropped due to being a duplicate of previously captured event."), null;
    } catch (e3) {
    }
    return e2 = t2;
  } };
};
function qn(e2, t2) {
  let n2 = ne(e2), r3 = ne(t2);
  if (!n2 && !r3) return true;
  if (n2 && !r3 || !n2 && r3) return false;
  if (r3.length !== n2.length) return false;
  for (let e3 = 0; e3 < r3.length; e3++) {
    const t3 = r3[e3], i2 = n2[e3];
    if (t3.filename !== i2.filename || t3.lineno !== i2.lineno || t3.colno !== i2.colno || t3.function !== i2.function) return false;
  }
  return true;
}
function zn(e2, t2) {
  let n2 = e2.fingerprint, r3 = t2.fingerprint;
  if (!n2 && !r3) return true;
  if (n2 && !r3 || !n2 && r3) return false;
  try {
    return !(n2.join("") !== r3.join(""));
  } catch (e3) {
    return false;
  }
}
function Wn(e2) {
  return e2.exception && e2.exception.values && e2.exception.values[0];
}
function Hn(e2) {
  return void 0 === e2 ? void 0 : e2 >= 400 && e2 < 500 ? "warning" : e2 >= 500 ? "error" : void 0;
}
var Gn = $;
function Qn(e2) {
  return e2 && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e2.toString());
}
function Kn() {
  if ("string" == typeof EdgeRuntime) return true;
  if (!(function() {
    if (!("fetch" in Gn)) return false;
    try {
      return new Headers(), new Request("http://www.example.com"), new Response(), true;
    } catch (e3) {
      return false;
    }
  })()) return false;
  if (Qn(Gn.fetch)) return true;
  let e2 = false;
  const t2 = Gn.document;
  if (t2 && "function" == typeof t2.createElement) try {
    const n2 = t2.createElement("iframe");
    n2.hidden = true, t2.head.appendChild(n2), n2.contentWindow && n2.contentWindow.fetch && (e2 = Qn(n2.contentWindow.fetch)), t2.head.removeChild(n2);
  } catch (e3) {
    z && Q.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e3);
  }
  return e2;
}
function Yn(e2, t2) {
  const n2 = "fetch";
  oe(n2, e2), se(n2, (() => (function(e3, t3 = false) {
    if (t3 && !Kn()) return;
    Le($, "fetch", (function(t4) {
      return function(...n3) {
        const r3 = new Error(), { method: i2, url: o2 } = (function(e4) {
          if (0 === e4.length) return { method: "GET", url: "" };
          if (2 === e4.length) {
            const [t6, n4] = e4;
            return { url: Zn(t6), method: Xn(n4, "method") ? String(n4.method).toUpperCase() : "GET" };
          }
          const t5 = e4[0];
          return { url: Zn(t5), method: Xn(t5, "method") ? String(t5.method).toUpperCase() : "GET" };
        })(n3), s2 = { args: n3, fetchData: { method: i2, url: o2 }, startTimestamp: 1e3 * qe(), virtualError: r3 };
        return e3 || ae("fetch", { ...s2 }), t4.apply($, n3).then((async (t5) => (e3 ? e3(t5) : ae("fetch", { ...s2, endTimestamp: 1e3 * qe(), response: t5 }), t5)), ((e4) => {
          throw ae("fetch", { ...s2, endTimestamp: 1e3 * qe(), error: e4 }), ve(e4) && void 0 === e4.stack && (e4.stack = r3.stack, De(e4, "framesToPop", 1)), e4;
        }));
      };
    }));
  })(void 0, t2)));
}
function Xn(e2, t2) {
  return !!e2 && "object" == typeof e2 && !!e2[t2];
}
function Zn(e2) {
  return "string" == typeof e2 ? e2 : e2 ? Xn(e2, "url") ? e2.url : e2.toString ? e2.toString() : "" : "";
}
var er = $;
var tr = $;
var nr = 0;
function rr() {
  return nr > 0;
}
function ir(e2, t2 = {}) {
  if (!/* @__PURE__ */ (function(e3) {
    return "function" == typeof e3;
  })(e2)) return e2;
  try {
    const t3 = e2.__sentry_wrapped__;
    if (t3) return "function" == typeof t3 ? t3 : e2;
    if (Re(e2)) return e2;
  } catch (t3) {
    return e2;
  }
  const n2 = function(...n3) {
    try {
      const r3 = n3.map(((e3) => ir(e3, t2)));
      return e2.apply(this, r3);
    } catch (e3) {
      throw nr++, setTimeout((() => {
        nr--;
      })), (function(...e4) {
        const t3 = gt(pe());
        if (2 === e4.length) {
          const [n4, r3] = e4;
          return n4 ? t3.withSetScope(n4, r3) : t3.withScope(r3);
        }
        t3.withScope(e4[0]);
      })(((r3) => {
        var i2, o2;
        r3.addEventProcessor(((e4) => (t2.mechanism && (Ge(e4, void 0, void 0), Qe(e4, t2.mechanism)), e4.extra = { ...e4.extra, arguments: n3 }, e4))), i2 = e3, mt().captureException(i2, cn2(o2));
      })), e3;
    }
  };
  try {
    for (const t3 in e2) Object.prototype.hasOwnProperty.call(e2, t3) && (n2[t3] = e2[t3]);
  } catch (e3) {
  }
  Ne(n2, e2), De(e2, "__sentry_wrapped__", n2);
  try {
    Object.getOwnPropertyDescriptor(n2, "name").configurable && Object.defineProperty(n2, "name", { get: () => e2.name });
  } catch (e3) {
  }
  return n2;
}
var or = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
function sr(e2, t2) {
  const n2 = lr(e2, t2), r3 = { type: pr(t2), value: hr(t2) };
  return n2.length && (r3.stacktrace = { frames: n2 }), void 0 === r3.type && "" === r3.value && (r3.value = "Unrecoverable error caught"), r3;
}
function ar(e2, t2, n2, r3) {
  const i2 = bt(), o2 = i2 && i2.getOptions().normalizeDepth, s2 = (function(e3) {
    for (const t3 in e3) if (Object.prototype.hasOwnProperty.call(e3, t3)) {
      const n3 = e3[t3];
      if (n3 instanceof Error) return n3;
    }
    return;
  })(t2), a2 = { __serialized__: Vt(t2, o2) };
  if (s2) return { exception: { values: [sr(e2, s2)] }, extra: a2 };
  const c2 = { exception: { values: [{ type: ke(t2) ? t2.constructor.name : r3 ? "UnhandledRejection" : "Error", value: gr(t2, { isUnhandledRejection: r3 }) }] }, extra: a2 };
  if (n2) {
    const t3 = lr(e2, n2);
    t3.length && (c2.exception.values[0].stacktrace = { frames: t3 });
  }
  return c2;
}
function cr(e2, t2) {
  return { exception: { values: [sr(e2, t2)] } };
}
function lr(e2, t2) {
  const n2 = t2.stacktrace || t2.stack || "", r3 = (function(e3) {
    if (e3 && ur.test(e3.message)) return 1;
    return 0;
  })(t2), i2 = (function(e3) {
    if ("number" == typeof e3.framesToPop) return e3.framesToPop;
    return 0;
  })(t2);
  try {
    return e2(n2, r3, i2);
  } catch (e3) {
  }
  return [];
}
var ur = /Minified React error #\d+;/i;
function dr(e2) {
  return "undefined" != typeof WebAssembly && void 0 !== WebAssembly.Exception && e2 instanceof WebAssembly.Exception;
}
function pr(e2) {
  const t2 = e2 && e2.name;
  if (!t2 && dr(e2)) {
    return e2.message && Array.isArray(e2.message) && 2 == e2.message.length ? e2.message[0] : "WebAssembly.Exception";
  }
  return t2;
}
function hr(e2) {
  const t2 = e2 && e2.message;
  return t2 ? t2.error && "string" == typeof t2.error.message ? t2.error.message : dr(e2) && Array.isArray(e2.message) && 2 == e2.message.length ? e2.message[1] : t2 : "No error message";
}
function fr(e2, t2, n2, r3, i2) {
  let o2;
  if (me(t2) && t2.error) {
    return cr(e2, t2.error);
  }
  if (ye(t2) || ge(t2, "DOMException")) {
    const i3 = t2;
    if ("stack" in t2) o2 = cr(e2, t2);
    else {
      const t3 = i3.name || (ye(i3) ? "DOMError" : "DOMException"), s2 = i3.message ? `${t3}: ${i3.message}` : t3;
      o2 = vr(e2, s2, n2, r3), Ge(o2, s2);
    }
    return "code" in i3 && (o2.tags = { ...o2.tags, "DOMException.code": `${i3.code}` }), o2;
  }
  if (ve(t2)) return cr(e2, t2);
  if (Se(t2) || ke(t2)) {
    return o2 = ar(e2, t2, n2, i2), Qe(o2, { synthetic: true }), o2;
  }
  return o2 = vr(e2, t2, n2, r3), Ge(o2, `${t2}`, void 0), Qe(o2, { synthetic: true }), o2;
}
function vr(e2, t2, n2, r3) {
  const i2 = {};
  if (r3 && n2) {
    const r4 = lr(e2, n2);
    r4.length && (i2.exception = { values: [{ value: t2, stacktrace: { frames: r4 } }] }), Qe(i2, { synthetic: true });
  }
  if (_e(t2)) {
    const { __sentry_template_string__: e3, __sentry_template_values__: n3 } = t2;
    return i2.logentry = { message: e3, params: n3 }, i2;
  }
  return i2.message = t2, i2;
}
function gr(e2, { isUnhandledRejection: t2 }) {
  const n2 = (function(e3, t3 = 40) {
    const n3 = Object.keys(Fe(e3));
    n3.sort();
    const r4 = n3[0];
    if (!r4) return "[object has no keys]";
    if (r4.length >= t3) return Ae(r4, t3);
    for (let e4 = n3.length; e4 > 0; e4--) {
      const r5 = n3.slice(0, e4).join(", ");
      if (!(r5.length > t3)) return e4 === n3.length ? r5 : Ae(r5, t3);
    }
    return "";
  })(e2), r3 = t2 ? "promise rejection" : "exception";
  if (me(e2)) return `Event \`ErrorEvent\` captured as ${r3} with message \`${e2.message}\``;
  if (ke(e2)) {
    return `Event \`${(function(e3) {
      try {
        const t3 = Object.getPrototypeOf(e3);
        return t3 ? t3.constructor.name : void 0;
      } catch (e4) {
      }
    })(e2)}\` (type=${e2.type}) captured as ${r3}`;
  }
  return `Object captured as ${r3} with keys: ${n2}`;
}
var mr = class extends wn {
  constructor(e2) {
    const t2 = { parentSpanIsAlwaysRootSpan: true, ...e2 };
    !(function(e3, t3, n2 = [t3], r3 = "npm") {
      const i2 = e3._metadata || {};
      i2.sdk || (i2.sdk = { name: `sentry.javascript.${t3}`, packages: n2.map(((e4) => ({ name: `${r3}:@sentry/${e4}`, version: J }))), version: J }), e3._metadata = i2;
    })(t2, "browser", ["browser"], tr.SENTRY_SDK_SOURCE || "npm"), super(t2), t2.sendClientReports && tr.document && tr.document.addEventListener("visibilitychange", (() => {
      "hidden" === tr.document.visibilityState && this._flushOutcomes();
    }));
  }
  eventFromException(e2, t2) {
    return (function(e3, t3, n2, r3) {
      const i2 = fr(e3, t3, n2 && n2.syntheticException || void 0, r3);
      return Qe(i2), i2.level = "error", n2 && n2.event_id && (i2.event_id = n2.event_id), Xe(i2);
    })(this._options.stackParser, e2, t2, this._options.attachStacktrace);
  }
  eventFromMessage(e2, t2 = "info", n2) {
    return (function(e3, t3, n3 = "info", r3, i2) {
      const o2 = vr(e3, t3, r3 && r3.syntheticException || void 0, i2);
      return o2.level = n3, r3 && r3.event_id && (o2.event_id = r3.event_id), Xe(o2);
    })(this._options.stackParser, e2, t2, n2, this._options.attachStacktrace);
  }
  captureUserFeedback(e2) {
    if (!this._isEnabled()) return void (or && Q.warn("SDK not enabled, will not capture user feedback."));
    const t2 = (function(e3, { metadata: t3, tunnel: n2, dsn: r3 }) {
      const i2 = { event_id: e3.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t3 && t3.sdk && { sdk: { name: t3.sdk.name, version: t3.sdk.version } }, ...!!n2 && !!r3 && { dsn: Rt(r3) } }, o2 = /* @__PURE__ */ (function(e4) {
        return [{ type: "user_report" }, e4];
      })(e3);
      return $t(i2, [o2]);
    })(e2, { metadata: this.getSdkMetadata(), dsn: this.getDsn(), tunnel: this.getOptions().tunnel });
    this.sendEnvelope(t2);
  }
  _prepareEvent(e2, t2, n2) {
    return e2.platform = e2.platform || "javascript", super._prepareEvent(e2, t2, n2);
  }
};
var yr = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var br = $;
var _r;
var wr;
var Sr;
var kr;
function Mr() {
  if (!br.document) return;
  const e2 = ae.bind(null, "dom"), t2 = Cr(e2, true);
  br.document.addEventListener("click", t2, false), br.document.addEventListener("keypress", t2, false), ["EventTarget", "Node"].forEach(((t3) => {
    const n2 = br[t3], r3 = n2 && n2.prototype;
    r3 && r3.hasOwnProperty && r3.hasOwnProperty("addEventListener") && (Le(r3, "addEventListener", (function(t4) {
      return function(n3, r4, i2) {
        if ("click" === n3 || "keypress" == n3) try {
          const r5 = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}, o2 = r5[n3] = r5[n3] || { refCount: 0 };
          if (!o2.handler) {
            const r6 = Cr(e2);
            o2.handler = r6, t4.call(this, n3, r6, i2);
          }
          o2.refCount++;
        } catch (e3) {
        }
        return t4.call(this, n3, r4, i2);
      };
    })), Le(r3, "removeEventListener", (function(e3) {
      return function(t4, n3, r4) {
        if ("click" === t4 || "keypress" == t4) try {
          const n4 = this.__sentry_instrumentation_handlers__ || {}, i2 = n4[t4];
          i2 && (i2.refCount--, i2.refCount <= 0 && (e3.call(this, t4, i2.handler, r4), i2.handler = void 0, delete n4[t4]), 0 === Object.keys(n4).length && delete this.__sentry_instrumentation_handlers__);
        } catch (e4) {
        }
        return e3.call(this, t4, n3, r4);
      };
    })));
  }));
}
function Cr(e2, t2 = false) {
  return (n2) => {
    if (!n2 || n2._sentryCaptured) return;
    const r3 = (function(e3) {
      try {
        return e3.target;
      } catch (e4) {
        return null;
      }
    })(n2);
    if ((function(e3, t3) {
      return "keypress" === e3 && (!t3 || !t3.tagName || "INPUT" !== t3.tagName && "TEXTAREA" !== t3.tagName && !t3.isContentEditable);
    })(n2.type, r3)) return;
    De(n2, "_sentryCaptured", true), r3 && !r3._sentryId && De(r3, "_sentryId", ze());
    const i2 = "keypress" === n2.type ? "input" : n2.type;
    if (!(function(e3) {
      if (e3.type !== wr) return false;
      try {
        if (!e3.target || e3.target._sentryId !== Sr) return false;
      } catch (e4) {
      }
      return true;
    })(n2)) {
      e2({ event: n2, name: i2, global: t2 }), wr = n2.type, Sr = r3 ? r3._sentryId : void 0;
    }
    clearTimeout(_r), _r = br.setTimeout((() => {
      Sr = void 0, wr = void 0;
    }), 1e3);
  };
}
function Er(e2) {
  const t2 = "history";
  oe(t2, e2), se(t2, Tr);
}
function Tr() {
  if (!(function() {
    const e3 = er.chrome, t3 = e3 && e3.app && e3.app.runtime, n2 = "history" in er && !!er.history.pushState && !!er.history.replaceState;
    return !t3 && n2;
  })()) return;
  const e2 = br.onpopstate;
  function t2(e3) {
    return function(...t3) {
      const n2 = t3.length > 2 ? t3[2] : void 0;
      if (n2) {
        const e4 = kr, t4 = String(n2);
        kr = t4;
        ae("history", { from: e4, to: t4 });
      }
      return e3.apply(this, t3);
    };
  }
  br.onpopstate = function(...t3) {
    const n2 = br.location.href, r3 = kr;
    kr = n2;
    if (ae("history", { from: r3, to: n2 }), e2) try {
      return e2.apply(this, t3);
    } catch (e3) {
    }
  }, Le(br.history, "pushState", t2), Le(br.history, "replaceState", t2);
}
var Or = {};
function Pr(e2) {
  Or[e2] = void 0;
}
var Ar = "__sentry_xhr_v3__";
function jr() {
  if (!br.XMLHttpRequest) return;
  const e2 = XMLHttpRequest.prototype;
  e2.open = new Proxy(e2.open, { apply(e3, t2, n2) {
    const r3 = new Error(), i2 = 1e3 * qe(), o2 = be(n2[0]) ? n2[0].toUpperCase() : void 0, s2 = (function(e4) {
      if (be(e4)) return e4;
      try {
        return e4.toString();
      } catch (e5) {
      }
      return;
    })(n2[1]);
    if (!o2 || !s2) return e3.apply(t2, n2);
    t2[Ar] = { method: o2, url: s2, request_headers: {} }, "POST" === o2 && s2.match(/sentry_key/) && (t2.__sentry_own_request__ = true);
    const a2 = () => {
      const e4 = t2[Ar];
      if (e4 && 4 === t2.readyState) {
        try {
          e4.status_code = t2.status;
        } catch (e5) {
        }
        ae("xhr", { endTimestamp: 1e3 * qe(), startTimestamp: i2, xhr: t2, virtualError: r3 });
      }
    };
    return "onreadystatechange" in t2 && "function" == typeof t2.onreadystatechange ? t2.onreadystatechange = new Proxy(t2.onreadystatechange, { apply: (e4, t3, n3) => (a2(), e4.apply(t3, n3)) }) : t2.addEventListener("readystatechange", a2), t2.setRequestHeader = new Proxy(t2.setRequestHeader, { apply(e4, t3, n3) {
      const [r4, i3] = n3, o3 = t3[Ar];
      return o3 && be(r4) && be(i3) && (o3.request_headers[r4.toLowerCase()] = i3), e4.apply(t3, n3);
    } }), e3.apply(t2, n2);
  } }), e2.send = new Proxy(e2.send, { apply(e3, t2, n2) {
    const r3 = t2[Ar];
    if (!r3) return e3.apply(t2, n2);
    void 0 !== n2[0] && (r3.body = n2[0]);
    return ae("xhr", { startTimestamp: 1e3 * qe(), xhr: t2 }), e3.apply(t2, n2);
  } });
}
function Ir(e2, t2 = (function(e3) {
  const t3 = Or[e3];
  if (t3) return t3;
  let n2 = br[e3];
  if (Qn(n2)) return Or[e3] = n2.bind(br);
  const r3 = br.document;
  if (r3 && "function" == typeof r3.createElement) try {
    const t4 = r3.createElement("iframe");
    t4.hidden = true, r3.head.appendChild(t4);
    const i2 = t4.contentWindow;
    i2 && i2[e3] && (n2 = i2[e3]), r3.head.removeChild(t4);
  } catch (t4) {
    yr && Q.warn(`Could not create sandbox iframe for ${e3} check, bailing to window.${e3}: `, t4);
  }
  return n2 ? Or[e3] = n2.bind(br) : n2;
})("fetch")) {
  let n2 = 0, r3 = 0;
  return En(e2, (function(i2) {
    const o2 = i2.body.length;
    n2 += o2, r3++;
    const s2 = { body: i2.body, method: "POST", referrerPolicy: "origin", headers: e2.headers, keepalive: n2 <= 6e4 && r3 < 15, ...e2.fetchOptions };
    if (!t2) return Pr("fetch"), Ze("No fetch implementation available");
    try {
      return t2(e2.url, s2).then(((e3) => (n2 -= o2, r3--, { statusCode: e3.status, headers: { "x-sentry-rate-limits": e3.headers.get("X-Sentry-Rate-Limits"), "retry-after": e3.headers.get("Retry-After") } })));
    } catch (e3) {
      return Pr("fetch"), n2 -= o2, r3--, Ze(e3);
    }
  }));
}
function xr(e2, t2, n2, r3) {
  const i2 = { filename: e2, function: "<anonymous>" === t2 ? K : t2, in_app: true };
  return void 0 !== n2 && (i2.lineno = n2), void 0 !== r3 && (i2.colno = r3), i2;
}
var Lr = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;
var Dr = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var Nr = /\((\S*)(?::(\d+))(?::(\d+))\)/;
var Rr = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var Fr = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var Br = (function(...e2) {
  const t2 = e2.sort(((e3, t3) => e3[0] - t3[0])).map(((e3) => e3[1]));
  return (e3, n2 = 0, r3 = 0) => {
    const i2 = [], o2 = e3.split("\n");
    for (let e4 = n2; e4 < o2.length; e4++) {
      const n3 = o2[e4];
      if (n3.length > 1024) continue;
      const s2 = Y.test(n3) ? n3.replace(Y, "$1") : n3;
      if (!s2.match(/\S*Error: /)) {
        for (const e5 of t2) {
          const t3 = e5(s2);
          if (t3) {
            i2.push(t3);
            break;
          }
        }
        if (i2.length >= 50 + r3) break;
      }
    }
    return (function(e4) {
      if (!e4.length) return [];
      const t3 = Array.from(e4);
      /sentryWrapped/.test(Z(t3).function || "") && t3.pop();
      t3.reverse(), X.test(Z(t3).function || "") && (t3.pop(), X.test(Z(t3).function || "") && t3.pop());
      return t3.slice(0, 50).map(((e5) => ({ ...e5, filename: e5.filename || Z(t3).filename, function: e5.function || K })));
    })(i2.slice(r3));
  };
})(...[[30, (e2) => {
  const t2 = Lr.exec(e2);
  if (t2) {
    const [, e3, n3, r3] = t2;
    return xr(e3, K, +n3, +r3);
  }
  const n2 = Dr.exec(e2);
  if (n2) {
    if (n2[2] && 0 === n2[2].indexOf("eval")) {
      const e4 = Nr.exec(n2[2]);
      e4 && (n2[2] = e4[1], n2[3] = e4[2], n2[4] = e4[3]);
    }
    const [e3, t3] = Ur(n2[1] || K, n2[2]);
    return xr(t3, e3, n2[3] ? +n2[3] : void 0, n2[4] ? +n2[4] : void 0);
  }
}], [50, (e2) => {
  const t2 = Rr.exec(e2);
  if (t2) {
    if (t2[3] && t2[3].indexOf(" > eval") > -1) {
      const e4 = Fr.exec(t2[3]);
      e4 && (t2[1] = t2[1] || "eval", t2[3] = e4[1], t2[4] = e4[2], t2[5] = "");
    }
    let e3 = t2[3], n2 = t2[1] || K;
    return [n2, e3] = Ur(n2, e3), xr(e3, n2, t2[4] ? +t2[4] : void 0, t2[5] ? +t2[5] : void 0);
  }
}]]);
var Ur = (e2, t2) => {
  const n2 = -1 !== e2.indexOf("safari-extension"), r3 = -1 !== e2.indexOf("safari-web-extension");
  return n2 || r3 ? [-1 !== e2.indexOf("@") ? e2.split("@")[0] : K, n2 ? `safari-extension:${t2}` : `safari-web-extension:${t2}`] : [e2, t2];
};
var Vr = 1024;
var Jr = (e2 = {}) => {
  const t2 = { console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true, ...e2 };
  return { name: "Breadcrumbs", setup(e3) {
    var n2;
    t2.console && (function(e4) {
      const t3 = "console";
      oe(t3, e4), se(t3, Vn);
    })(/* @__PURE__ */ (function(e4) {
      return function(t3) {
        if (bt() !== e4) return;
        const n3 = { category: "console", data: { arguments: t3.args, logger: "console" }, level: Jn(t3.level), message: je(t3.args, " ") };
        if ("assert" === t3.level) {
          if (false !== t3.args[0]) return;
          n3.message = `Assertion failed: ${je(t3.args.slice(1), " ") || "console.assert"}`, n3.data.arguments = t3.args.slice(1);
        }
        Pn(n3, { input: t3.args, level: t3.level });
      };
    })(e3)), t2.dom && (n2 = /* @__PURE__ */ (function(e4, t3) {
      return function(n3) {
        if (bt() !== e4) return;
        let r3, i2, o2 = "object" == typeof t3 ? t3.serializeAttribute : void 0, s2 = "object" == typeof t3 && "number" == typeof t3.maxStringLength ? t3.maxStringLength : void 0;
        s2 && s2 > Vr && (or && Q.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${s2} was configured. Sentry will use 1024 instead.`), s2 = Vr), "string" == typeof o2 && (o2 = [o2]);
        try {
          const e5 = n3.event, t4 = (function(e6) {
            return !!e6 && !!e6.target;
          })(e5) ? e5.target : e5;
          r3 = Oe(t4, { keyAttrs: o2, maxStringLength: s2 }), i2 = (function(e6) {
            if (!Te.HTMLElement) return null;
            let t5 = e6;
            for (let e7 = 0; e7 < 5; e7++) {
              if (!t5) return null;
              if (t5 instanceof HTMLElement) {
                if (t5.dataset.sentryComponent) return t5.dataset.sentryComponent;
                if (t5.dataset.sentryElement) return t5.dataset.sentryElement;
              }
              t5 = t5.parentNode;
            }
            return null;
          })(t4);
        } catch (e5) {
          r3 = "<unknown>";
        }
        if (0 === r3.length) return;
        const a2 = { category: `ui.${n3.name}`, message: r3 };
        i2 && (a2.data = { "ui.component_name": i2 }), Pn(a2, { event: n3.event, name: n3.name, global: n3.global });
      };
    })(e3, t2.dom), oe("dom", n2), se("dom", Mr)), t2.xhr && (function(e4) {
      oe("xhr", e4), se("xhr", jr);
    })(/* @__PURE__ */ (function(e4) {
      return function(t3) {
        if (bt() !== e4) return;
        const { startTimestamp: n3, endTimestamp: r3 } = t3, i2 = t3.xhr[Ar];
        if (!n3 || !r3 || !i2) return;
        const { method: o2, url: s2, status_code: a2, body: c2 } = i2, l2 = { method: o2, url: s2, status_code: a2 }, u2 = { xhr: t3.xhr, input: c2, startTimestamp: n3, endTimestamp: r3 };
        Pn({ category: "xhr", data: l2, type: "http", level: Hn(a2) }, u2);
      };
    })(e3)), t2.fetch && Yn(/* @__PURE__ */ (function(e4) {
      return function(t3) {
        if (bt() !== e4) return;
        const { startTimestamp: n3, endTimestamp: r3 } = t3;
        if (r3 && (!t3.fetchData.url.match(/sentry_key/) || "POST" !== t3.fetchData.method)) if (t3.error) {
          Pn({ category: "fetch", data: t3.fetchData, level: "error", type: "http" }, { data: t3.error, input: t3.args, startTimestamp: n3, endTimestamp: r3 });
        } else {
          const e5 = t3.response, i2 = { ...t3.fetchData, status_code: e5 && e5.status }, o2 = { input: t3.args, response: e5, startTimestamp: n3, endTimestamp: r3 };
          Pn({ category: "fetch", data: i2, type: "http", level: Hn(i2.status_code) }, o2);
        }
      };
    })(e3)), t2.history && Er(/* @__PURE__ */ (function(e4) {
      return function(t3) {
        if (bt() !== e4) return;
        let n3 = t3.from, r3 = t3.to;
        const i2 = Un(tr.location.href);
        let o2 = n3 ? Un(n3) : void 0;
        const s2 = Un(r3);
        o2 && o2.path || (o2 = i2), i2.protocol === s2.protocol && i2.host === s2.host && (r3 = s2.relative), i2.protocol === o2.protocol && i2.host === o2.host && (n3 = o2.relative), Pn({ category: "navigation", data: { from: n3, to: r3 } });
      };
    })(e3)), t2.sentry && e3.on("beforeSendEvent", /* @__PURE__ */ (function(e4) {
      return function(t3) {
        bt() === e4 && Pn({ category: "sentry." + ("transaction" === t3.type ? "transaction" : "event"), event_id: t3.event_id, level: t3.level, message: He(t3) }, { event: t3 });
      };
    })(e3));
  } };
};
var $r = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
var qr = (e2 = {}) => {
  const t2 = { XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true, ...e2 };
  return { name: "BrowserApiErrors", setupOnce() {
    t2.setTimeout && Le(tr, "setTimeout", zr), t2.setInterval && Le(tr, "setInterval", zr), t2.requestAnimationFrame && Le(tr, "requestAnimationFrame", Wr), t2.XMLHttpRequest && "XMLHttpRequest" in tr && Le(XMLHttpRequest.prototype, "send", Hr);
    const e3 = t2.eventTarget;
    if (e3) {
      (Array.isArray(e3) ? e3 : $r).forEach(Gr);
    }
  } };
};
function zr(e2) {
  return function(...t2) {
    const n2 = t2[0];
    return t2[0] = ir(n2, { mechanism: { data: { function: te(e2) }, handled: false, type: "instrument" } }), e2.apply(this, t2);
  };
}
function Wr(e2) {
  return function(t2) {
    return e2.apply(this, [ir(t2, { mechanism: { data: { function: "requestAnimationFrame", handler: te(e2) }, handled: false, type: "instrument" } })]);
  };
}
function Hr(e2) {
  return function(...t2) {
    const n2 = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(((e3) => {
      e3 in n2 && "function" == typeof n2[e3] && Le(n2, e3, (function(t3) {
        const n3 = { mechanism: { data: { function: e3, handler: te(t3) }, handled: false, type: "instrument" } }, r3 = Re(t3);
        return r3 && (n3.mechanism.data.handler = te(r3)), ir(t3, n3);
      }));
    })), e2.apply(this, t2);
  };
}
function Gr(e2) {
  const t2 = tr[e2], n2 = t2 && t2.prototype;
  n2 && n2.hasOwnProperty && n2.hasOwnProperty("addEventListener") && (Le(n2, "addEventListener", (function(t3) {
    return function(n3, r3, i2) {
      try {
        "function" == typeof r3.handleEvent && (r3.handleEvent = ir(r3.handleEvent, { mechanism: { data: { function: "handleEvent", handler: te(r3), target: e2 }, handled: false, type: "instrument" } }));
      } catch (e3) {
      }
      return t3.apply(this, [n3, ir(r3, { mechanism: { data: { function: "addEventListener", handler: te(r3), target: e2 }, handled: false, type: "instrument" } }), i2]);
    };
  })), Le(n2, "removeEventListener", (function(e3) {
    return function(t3, n3, r3) {
      try {
        const i2 = n3.__sentry_wrapped__;
        i2 && e3.call(this, t3, i2, r3);
      } catch (e4) {
      }
      return e3.call(this, t3, n3, r3);
    };
  })));
}
var Qr = () => ({ name: "BrowserSession", setupOnce() {
  void 0 !== tr.document ? (dn({ ignoreDuration: true }), fn(), Er((({ from: e2, to: t2 }) => {
    void 0 !== e2 && e2 !== t2 && (dn({ ignoreDuration: true }), fn());
  }))) : or && Q.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
} });
var Kr = (e2 = {}) => {
  const t2 = { onerror: true, onunhandledrejection: true, ...e2 };
  return { name: "GlobalHandlers", setupOnce() {
    Error.stackTraceLimit = 50;
  }, setup(e3) {
    t2.onerror && (!(function(e4) {
      !(function(e5) {
        const t3 = "error";
        oe(t3, e5), se(t3, le);
      })(((t3) => {
        const { stackParser: n2, attachStacktrace: r3 } = Xr();
        if (bt() !== e4 || rr()) return;
        const { msg: i2, url: o2, line: s2, column: a2, error: c2 } = t3, l2 = (function(e5, t4, n3, r4) {
          const i3 = e5.exception = e5.exception || {}, o3 = i3.values = i3.values || [], s3 = o3[0] = o3[0] || {}, a3 = s3.stacktrace = s3.stacktrace || {}, c3 = a3.frames = a3.frames || [], l3 = r4, u2 = n3, d2 = be(t4) && t4.length > 0 ? t4 : (function() {
            try {
              return Te.document.location.href;
            } catch (e6) {
              return "";
            }
          })();
          0 === c3.length && c3.push({ colno: l3, filename: d2, function: K, in_app: true, lineno: u2 });
          return e5;
        })(fr(n2, c2 || i2, void 0, r3, false), o2, s2, a2);
        l2.level = "error", un(l2, { originalException: c2, mechanism: { handled: false, type: "onerror" } });
      }));
    })(e3), Yr("onerror")), t2.onunhandledrejection && (!(function(e4) {
      !(function(e5) {
        const t3 = "unhandledrejection";
        oe(t3, e5), se(t3, de);
      })(((t3) => {
        const { stackParser: n2, attachStacktrace: r3 } = Xr();
        if (bt() !== e4 || rr()) return;
        const i2 = (function(e5) {
          if (we(e5)) return e5;
          try {
            if ("reason" in e5) return e5.reason;
            if ("detail" in e5 && "reason" in e5.detail) return e5.detail.reason;
          } catch (e6) {
          }
          return e5;
        })(t3), o2 = we(i2) ? { exception: { values: [{ type: "UnhandledRejection", value: `Non-Error promise rejection captured with value: ${String(i2)}` }] } } : fr(n2, i2, void 0, r3, true);
        o2.level = "error", un(o2, { originalException: i2, mechanism: { handled: false, type: "onunhandledrejection" } });
      }));
    })(e3), Yr("onunhandledrejection"));
  } };
};
function Yr(e2) {
  or && Q.log(`Global Handler attached: ${e2}`);
}
function Xr() {
  const e2 = bt();
  return e2 && e2.getOptions() || { stackParser: () => [], attachStacktrace: false };
}
var Zr = () => ({ name: "HttpContext", preprocessEvent(e2) {
  if (!tr.navigator && !tr.location && !tr.document) return;
  const t2 = e2.request && e2.request.url || tr.location && tr.location.href, { referrer: n2 } = tr.document || {}, { userAgent: r3 } = tr.navigator || {}, i2 = { ...e2.request && e2.request.headers, ...n2 && { Referer: n2 }, ...r3 && { "User-Agent": r3 } }, o2 = { ...e2.request, ...t2 && { url: t2 }, headers: i2 };
  e2.request = o2;
} });
var ei = (e2 = {}) => {
  const t2 = e2.limit || 5, n2 = e2.key || "cause";
  return { name: "LinkedErrors", preprocessEvent(e3, r3, i2) {
    const o2 = i2.getOptions();
    Nn(sr, o2.stackParser, o2.maxValueLength, n2, t2, e3, r3);
  } };
};
var ti = "new";
var ni = "loading";
var ri = "loaded";
var ii = "joining-meeting";
var oi = "joined-meeting";
var si = "left-meeting";
var ai = "error";
var hi = "playable";
var fi = "unknown";
var vi = "full";
var yi = "base";
var Ci = "no-room";
var Ti = "end-of-life";
var Pi = "connection-error";
var Fi = "iframe-ready-for-launch-config";
var Bi = "iframe-launch-config";
var Ui = "theme-updated";
var Vi = "loading";
var Ji = "load-attempt-failed";
var $i = "loaded";
var qi = "started-camera";
var zi = "camera-error";
var Wi = "joining-meeting";
var Hi = "joined-meeting";
var Gi = "left-meeting";
var Qi = "participant-joined";
var Ki = "participant-updated";
var Yi = "participant-left";
var Xi = "participant-counts-updated";
var Zi = "access-state-updated";
var eo = "meeting-session-summary-updated";
var to2 = "meeting-session-state-updated";
var ro = "waiting-participant-added";
var io = "waiting-participant-updated";
var oo = "waiting-participant-removed";
var so = "track-started";
var ao = "track-stopped";
var co = "transcription-started";
var lo = "transcription-stopped";
var uo = "transcription-error";
var po = "recording-started";
var ho = "recording-stopped";
var fo = "recording-stats";
var vo = "recording-error";
var go = "recording-upload-completed";
var mo = "recording-data";
var yo = "app-message";
var bo = "transcription-message";
var _o = "remote-media-player-started";
var wo = "remote-media-player-updated";
var So = "remote-media-player-stopped";
var ko = "local-screen-share-started";
var Mo = "local-screen-share-stopped";
var Co = "local-screen-share-canceled";
var Eo = "active-speaker-change";
var To = "active-speaker-mode-change";
var Oo = "network-quality-change";
var Po = "network-connection";
var Ao = "cpu-load-change";
var jo = "face-counts-updated";
var Io = "fullscreen";
var xo = "exited-fullscreen";
var Lo = "live-streaming-started";
var Do = "live-streaming-updated";
var No = "live-streaming-stopped";
var Ro = "live-streaming-error";
var Fo = "lang-updated";
var Bo = "receive-settings-updated";
var Uo = "input-settings-updated";
var Vo = "nonfatal-error";
var Jo = "error";
var $o = 4096;
var qo = 102400;
var zo = "iframe-call-message";
var Wo = "local-screen-start";
var Ho = "daily-method-update-live-streaming-endpoints";
var Go = "transmit-log";
var Qo = "daily-custom-track";
var Ko = { NONE: "none", BGBLUR: "background-blur", BGIMAGE: "background-image", FACE_DETECTION: "face-detection" };
var Yo = { NONE: "none", NOISE_CANCELLATION: "noise-cancellation" };
var Xo = { PLAY: "play", PAUSE: "pause" };
var Zo = ["jpg", "png", "jpeg"];
var es = "add-endpoints";
var ts = "remove-endpoints";
var ns = "sip-call-transfer";
function rs() {
  return !is() && "undefined" != typeof window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : "";
}
function is() {
  return "undefined" != typeof navigator && navigator.product && "ReactNative" === navigator.product;
}
function os() {
  return navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
}
function ss() {
  return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && ((function(e2, t2) {
    if (!e2 || !t2) return true;
    switch (e2) {
      case "Chrome":
        return t2.major >= 75;
      case "Safari":
        return RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") && !(13 === t2.major && 0 === t2.minor && 0 === t2.point);
      case "Firefox":
        return t2.major >= 67;
    }
    return true;
  })(ms(), ys()) || is());
}
function as() {
  if (is()) return false;
  if (!document) return false;
  var e2 = document.createElement("iframe");
  return !!e2.requestFullscreen || !!e2.webkitRequestFullscreen;
}
var cs = "none";
var ls = "software";
var us = "hardware";
var ds = (function() {
  try {
    var e2, t2 = document.createElement("canvas"), n2 = false;
    (e2 = t2.getContext("webgl2", { failIfMajorPerformanceCaveat: true })) || (n2 = true, e2 = t2.getContext("webgl2"));
    var r3 = null != e2;
    return t2.remove(), r3 ? n2 ? ls : us : cs;
  } catch (e3) {
    return cs;
  }
})();
function ps() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
  return !is() && (ds !== cs && (e2 ? (function() {
    if (gs()) return false;
    return ["Chrome", "Firefox"].includes(ms());
  })() : (function() {
    if (gs()) return false;
    var e3 = ms();
    if ("Safari" === e3) {
      var t2 = Ss();
      if (t2.major < 15 || 15 === t2.major && t2.minor < 4) return false;
    }
    if ("Chrome" === e3) {
      return bs().major >= 77;
    }
    if ("Firefox" === e3) {
      return ks().major >= 97;
    }
    return ["Chrome", "Firefox", "Safari"].includes(e3);
  })()));
}
function hs() {
  if (is()) return false;
  if (vs()) return false;
  if ("undefined" == typeof AudioWorkletNode) return false;
  switch (ms()) {
    case "Chrome":
    case "Firefox":
      return true;
    case "Safari":
      var e2 = ys();
      return e2.major > 17 || 17 === e2.major && e2.minor >= 4;
  }
  return false;
}
function fs() {
  return os() && !(function() {
    var e2, t2 = ms();
    if (!rs()) return true;
    switch (t2) {
      case "Chrome":
        return (e2 = bs()).major && e2.major > 0 && e2.major < 75;
      case "Firefox":
        return (e2 = ks()).major < 91;
      case "Safari":
        return (e2 = Ss()).major < 13 || 13 === e2.major && e2.minor < 1;
      default:
        return true;
    }
  })();
}
function vs() {
  return rs().match(/Linux; Android/);
}
function gs() {
  var e2, t2 = rs(), n2 = t2.match(/Mac/) && (!is() && "undefined" != typeof window && null !== (e2 = window) && void 0 !== e2 && null !== (e2 = e2.navigator) && void 0 !== e2 && e2.maxTouchPoints ? window.navigator.maxTouchPoints : 0) >= 5;
  return !!(t2.match(/Mobi/) || t2.match(/Android/) || n2) || (!!rs().match(/DailyAnd\//) || void 0);
}
function ms() {
  if ("undefined" != typeof window) {
    var e2 = rs();
    return _s() ? "Safari" : e2.indexOf("Edge") > -1 ? "Edge" : e2.match(/Chrome\//) ? "Chrome" : e2.indexOf("Safari") > -1 || ws() ? "Safari" : e2.indexOf("Firefox") > -1 ? "Firefox" : e2.indexOf("MSIE") > -1 || e2.indexOf(".NET") > -1 ? "IE" : "Unknown Browser";
  }
}
function ys() {
  switch (ms()) {
    case "Chrome":
      return bs();
    case "Safari":
      return Ss();
    case "Firefox":
      return ks();
    case "Edge":
      return (function() {
        var e2 = 0, t2 = 0;
        if ("undefined" != typeof window) {
          var n2 = rs().match(/Edge\/(\d+).(\d+)/);
          if (n2) try {
            e2 = parseInt(n2[1]), t2 = parseInt(n2[2]);
          } catch (e3) {
          }
        }
        return { major: e2, minor: t2 };
      })();
  }
}
function bs() {
  var e2 = 0, t2 = 0, n2 = 0, r3 = 0, i2 = false;
  if ("undefined" != typeof window) {
    var o2 = rs(), s2 = o2.match(/Chrome\/(\d+).(\d+).(\d+).(\d+)/);
    if (s2) try {
      e2 = parseInt(s2[1]), t2 = parseInt(s2[2]), n2 = parseInt(s2[3]), r3 = parseInt(s2[4]), i2 = o2.indexOf("OPR/") > -1;
    } catch (e3) {
    }
  }
  return { major: e2, minor: t2, build: n2, patch: r3, opera: i2 };
}
function _s() {
  return !!rs().match(/iPad|iPhone|iPod/i) && os();
}
function ws() {
  return rs().indexOf("AppleWebKit/605.1.15") > -1;
}
function Ss() {
  var e2 = 0, t2 = 0, n2 = 0;
  if ("undefined" != typeof window) {
    var r3 = rs().match(/Version\/(\d+).(\d+)(.(\d+))?/);
    if (r3) try {
      e2 = parseInt(r3[1]), t2 = parseInt(r3[2]), n2 = parseInt(r3[4]);
    } catch (e3) {
    }
    else (_s() || ws()) && (e2 = 14, t2 = 0, n2 = 3);
  }
  return { major: e2, minor: t2, point: n2 };
}
function ks() {
  var e2 = 0, t2 = 0;
  if ("undefined" != typeof window) {
    var n2 = rs().match(/Firefox\/(\d+).(\d+)/);
    if (n2) try {
      e2 = parseInt(n2[1]), t2 = parseInt(n2[2]);
    } catch (e3) {
    }
  }
  return { major: e2, minor: t2 };
}
var Ms = (function() {
  return o((function e2() {
    t(this, e2);
  }), [{ key: "addListenerForMessagesFromCallMachine", value: function(e2, t2, n2) {
    R();
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e2, t2, n2) {
    R();
  } }, { key: "sendMessageToCallMachine", value: function(e2, t2, n2, r3) {
    R();
  } }, { key: "sendMessageToDailyJs", value: function(e2, t2) {
    R();
  } }, { key: "removeListener", value: function(e2) {
    R();
  } }]);
})();
function Cs(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r3 = Object.getOwnPropertySymbols(e2);
    t2 && (r3 = r3.filter((function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    }))), n2.push.apply(n2, r3);
  }
  return n2;
}
function Es(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? Cs(Object(n2), true).forEach((function(t3) {
      u(e2, t3, n2[t3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : Cs(Object(n2)).forEach((function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
    }));
  }
  return e2;
}
function Ts() {
  try {
    var e2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
    })));
  } catch (e3) {
  }
  return (Ts = function() {
    return !!e2;
  })();
}
var Os = (function() {
  function e2() {
    var n2, r3, i2, o2;
    return t(this, e2), r3 = this, i2 = a(i2 = e2), (n2 = s(r3, Ts() ? Reflect.construct(i2, o2 || [], a(r3).constructor) : i2.apply(r3, o2)))._wrappedListeners = {}, n2._messageCallbacks = {}, n2;
  }
  return l(e2, Ms), o(e2, [{ key: "addListenerForMessagesFromCallMachine", value: function(e3, t2, n2) {
    var r3 = this, i2 = function(i3) {
      if (i3.data && "iframe-call-message" === i3.data.what && (!i3.data.callClientId || i3.data.callClientId === t2) && (!i3.data.from || "module" !== i3.data.from)) {
        var o2 = Es({}, i3.data);
        if (delete o2.from, o2.callbackStamp && r3._messageCallbacks[o2.callbackStamp]) {
          var s2 = o2.callbackStamp;
          r3._messageCallbacks[s2].call(n2, o2), delete r3._messageCallbacks[s2];
        }
        delete o2.what, delete o2.callbackStamp, e3.call(n2, o2);
      }
    };
    this._wrappedListeners[e3] = i2, window.addEventListener("message", i2);
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e3, t2, n2) {
    var r3 = function(r4) {
      var i2;
      if (!(!r4.data || r4.data.what !== zo || !r4.data.action || r4.data.from && "module" !== r4.data.from || r4.data.callClientId && t2 && r4.data.callClientId !== t2 || null != r4 && null !== (i2 = r4.data) && void 0 !== i2 && i2.callFrameId)) {
        var o2 = r4.data;
        e3.call(n2, o2);
      }
    };
    this._wrappedListeners[e3] = r3, window.addEventListener("message", r3);
  } }, { key: "sendMessageToCallMachine", value: function(e3, t2, n2, r3) {
    if (!n2) throw new Error("undefined callClientId. Are you trying to use a DailyCall instance previously destroyed?");
    var i2 = Es({}, e3);
    if (i2.what = zo, i2.from = "module", i2.callClientId = n2, t2) {
      var o2 = N();
      this._messageCallbacks[o2] = t2, i2.callbackStamp = o2;
    }
    var s2 = r3 ? r3.contentWindow : window, a2 = this._callMachineTargetOrigin(r3);
    a2 && s2.postMessage(i2, a2);
  } }, { key: "sendMessageToDailyJs", value: function(e3, t2) {
    e3.what = zo, e3.callClientId = t2, e3.from = "embedded", window.postMessage(e3, this._targetOriginFromWindowLocation());
  } }, { key: "removeListener", value: function(e3) {
    var t2 = this._wrappedListeners[e3];
    t2 && (window.removeEventListener("message", t2), delete this._wrappedListeners[e3]);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e3, t2, n2) {
    var r3 = Es({}, e3);
    r3.callClientId = n2;
    var i2 = t2 ? t2.contentWindow : window, o2 = this._callMachineTargetOrigin(t2);
    o2 && i2.postMessage(r3, o2);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e3, t2) {
    var n2 = function(n3) {
      if (n3.data && "iframe-call-message" === n3.data.what && (!n3.data.callClientId || n3.data.callClientId === t2) && (!n3.data.from || "module" !== n3.data.from)) {
        var r3 = n3.data;
        e3(r3);
      }
    };
    return this._wrappedListeners[e3] = n2, window.addEventListener("message", n2), e3;
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e3) {
    var t2 = this._wrappedListeners[e3];
    t2 && (window.removeEventListener("message", t2), delete this._wrappedListeners[e3]);
  } }, { key: "_callMachineTargetOrigin", value: function(e3) {
    return e3 ? e3.src ? new URL(e3.src).origin : void 0 : this._targetOriginFromWindowLocation();
  } }, { key: "_targetOriginFromWindowLocation", value: function() {
    return "file:" === window.location.protocol ? "*" : window.location.origin;
  } }]);
})();
function Ps(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r3 = Object.getOwnPropertySymbols(e2);
    t2 && (r3 = r3.filter((function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    }))), n2.push.apply(n2, r3);
  }
  return n2;
}
function As() {
  try {
    var e2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
    })));
  } catch (e3) {
  }
  return (As = function() {
    return !!e2;
  })();
}
var js = (function() {
  function e2() {
    var n2, r3, i2, o2;
    return t(this, e2), r3 = this, i2 = a(i2 = e2), n2 = s(r3, As() ? Reflect.construct(i2, o2 || [], a(r3).constructor) : i2.apply(r3, o2)), global.callMachineToDailyJsEmitter = global.callMachineToDailyJsEmitter || new y.EventEmitter(), global.dailyJsToCallMachineEmitter = global.dailyJsToCallMachineEmitter || new y.EventEmitter(), n2._wrappedListeners = {}, n2._messageCallbacks = {}, n2;
  }
  return l(e2, Ms), o(e2, [{ key: "addListenerForMessagesFromCallMachine", value: function(e3, t2, n2) {
    this._addListener(e3, global.callMachineToDailyJsEmitter, t2, n2, "received call machine message");
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e3, t2, n2) {
    this._addListener(e3, global.dailyJsToCallMachineEmitter, t2, n2, "received daily-js message");
  } }, { key: "sendMessageToCallMachine", value: function(e3, t2, n2) {
    this._sendMessage(e3, global.dailyJsToCallMachineEmitter, n2, t2, "sending message to call machine");
  } }, { key: "sendMessageToDailyJs", value: function(e3, t2) {
    this._sendMessage(e3, global.callMachineToDailyJsEmitter, t2, null, "sending message to daily-js");
  } }, { key: "removeListener", value: function(e3) {
    var t2 = this._wrappedListeners[e3];
    t2 && (global.callMachineToDailyJsEmitter.removeListener("message", t2), global.dailyJsToCallMachineEmitter.removeListener("message", t2), delete this._wrappedListeners[e3]);
  } }, { key: "_addListener", value: function(e3, t2, n2, r3, i2) {
    var o2 = this, s2 = function(t3) {
      if (t3.callClientId === n2) {
        if (t3.callbackStamp && o2._messageCallbacks[t3.callbackStamp]) {
          var i3 = t3.callbackStamp;
          o2._messageCallbacks[i3].call(r3, t3), delete o2._messageCallbacks[i3];
        }
        e3.call(r3, t3);
      }
    };
    this._wrappedListeners[e3] = s2, t2.addListener("message", s2);
  } }, { key: "_sendMessage", value: function(e3, t2, n2, r3, i2) {
    var o2 = (function(e4) {
      for (var t3 = 1; t3 < arguments.length; t3++) {
        var n3 = null != arguments[t3] ? arguments[t3] : {};
        t3 % 2 ? Ps(Object(n3), true).forEach((function(t4) {
          u(e4, t4, n3[t4]);
        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : Ps(Object(n3)).forEach((function(t4) {
          Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
        }));
      }
      return e4;
    })({}, e3);
    if (o2.callClientId = n2, r3) {
      var s2 = N();
      this._messageCallbacks[s2] = r3, o2.callbackStamp = s2;
    }
    t2.emit("message", o2);
  } }]);
})();
var Is = "replace";
var xs = "shallow-merge";
var Ls = [Is, xs];
var Ds = (function() {
  function e2() {
    var n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = n2.data, i2 = n2.mergeStrategy, o2 = void 0 === i2 ? Is : i2;
    t(this, e2), e2._validateMergeStrategy(o2), e2._validateData(r3, o2), this.mergeStrategy = o2, this.data = r3;
  }
  return o(e2, [{ key: "isNoOp", value: function() {
    return e2.isNoOpUpdate(this.data, this.mergeStrategy);
  } }], [{ key: "isNoOpUpdate", value: function(e3, t2) {
    return 0 === Object.keys(e3).length && t2 === xs;
  } }, { key: "_validateMergeStrategy", value: function(e3) {
    if (!Ls.includes(e3)) throw Error("Unrecognized mergeStrategy provided. Options are: [".concat(Ls, "]"));
  } }, { key: "_validateData", value: function(e3, t2) {
    if (!(function(e4) {
      if (null == e4 || "object" !== n(e4)) return false;
      var t3 = Object.getPrototypeOf(e4);
      return null == t3 || t3 === Object.prototype;
    })(e3)) throw Error("Meeting session data must be a plain (map-like) object");
    var r3;
    try {
      if (r3 = JSON.stringify(e3), t2 === Is) {
        var i2 = JSON.parse(r3);
        S(i2, e3) || console.warn("The meeting session data provided will be modified when serialized.", i2, e3);
      } else if (t2 === xs) {
        for (var o2 in e3) if (Object.hasOwnProperty.call(e3, o2) && void 0 !== e3[o2]) {
          var s2 = JSON.parse(JSON.stringify(e3[o2]));
          S(e3[o2], s2) || console.warn("At least one key in the meeting session data provided will be modified when serialized.", s2, e3[o2]);
        }
      }
    } catch (e4) {
      throw Error("Meeting session data must be serializable to JSON: ".concat(e4));
    }
    if (r3.length > qo) throw Error("Meeting session data is too large (".concat(r3.length, " characters). Maximum size suppported is ").concat(qo, "."));
  } }]);
})();
function Ns() {
  try {
    var e2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
    })));
  } catch (e3) {
  }
  return (Ns = function() {
    return !!e2;
  })();
}
function Rs(e2) {
  var t2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return Rs = function(e3) {
    if (null === e3 || !(function(e4) {
      try {
        return -1 !== Function.toString.call(e4).indexOf("[native code]");
      } catch (t3) {
        return "function" == typeof e4;
      }
    })(e3)) return e3;
    if ("function" != typeof e3) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== t2) {
      if (t2.has(e3)) return t2.get(e3);
      t2.set(e3, n2);
    }
    function n2() {
      return (function(e4, t3, n3) {
        if (Ns()) return Reflect.construct.apply(null, arguments);
        var r3 = [null];
        r3.push.apply(r3, t3);
        var i2 = new (e4.bind.apply(e4, r3))();
        return n3 && c(i2, n3.prototype), i2;
      })(e3, arguments, a(this).constructor);
    }
    return n2.prototype = Object.create(e3.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } }), c(n2, e3);
  }, Rs(e2);
}
function Fs() {
  try {
    var e2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
    })));
  } catch (e3) {
  }
  return (Fs = function() {
    return !!e2;
  })();
}
function Bs(e2) {
  var t2, n2 = null === (t2 = window._daily) || void 0 === t2 ? void 0 : t2.pendings;
  if (n2) {
    var r3 = n2.indexOf(e2);
    -1 !== r3 && n2.splice(r3, 1);
  }
}
var Us = (function() {
  return o((function e2(n2) {
    t(this, e2), this._currentLoad = null, this._callClientId = n2;
  }), [{ key: "load", value: function() {
    var e2, t2 = this, n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = arguments.length > 1 ? arguments[1] : void 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
    if (this.loaded) return window._daily.instances[this._callClientId].callMachine.reset(), void r3(true);
    e2 = this._callClientId, window._daily.pendings.push(e2), this._currentLoad && this._currentLoad.cancel(), this._currentLoad = new Vs(n2, (function() {
      r3(false);
    }), (function(e3, n3) {
      n3 || Bs(t2._callClientId), i2(e3, n3);
    })), this._currentLoad.start();
  } }, { key: "cancel", value: function() {
    this._currentLoad && this._currentLoad.cancel(), Bs(this._callClientId);
  } }, { key: "loaded", get: function() {
    return this._currentLoad && this._currentLoad.succeeded;
  } }]);
})();
var Vs = (function() {
  return o((function e2() {
    var n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = arguments.length > 1 ? arguments[1] : void 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
    t(this, e2), this._attemptsRemaining = 3, this._currentAttempt = null, this._dailyConfig = n2, this._successCallback = r3, this._failureCallback = i2;
  }), [{ key: "start", value: function() {
    var e2 = this;
    if (!this._currentAttempt) {
      var t2 = function(n2) {
        e2._currentAttempt.cancelled || (e2._attemptsRemaining--, e2._failureCallback(n2, e2._attemptsRemaining > 0), e2._attemptsRemaining <= 0 || setTimeout((function() {
          e2._currentAttempt.cancelled || (e2._currentAttempt = new qs(e2._dailyConfig, e2._successCallback, t2), e2._currentAttempt.start());
        }), 3e3));
      };
      this._currentAttempt = new qs(this._dailyConfig, this._successCallback, t2), this._currentAttempt.start();
    }
  } }, { key: "cancel", value: function() {
    this._currentAttempt && this._currentAttempt.cancel();
  } }, { key: "cancelled", get: function() {
    return this._currentAttempt && this._currentAttempt.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._currentAttempt && this._currentAttempt.succeeded;
  } }]);
})();
var Js = (function() {
  function e2() {
    return t(this, e2), n2 = this, i2 = arguments, r3 = a(r3 = e2), s(n2, Fs() ? Reflect.construct(r3, i2 || [], a(n2).constructor) : r3.apply(n2, i2));
    var n2, r3, i2;
  }
  return l(e2, Rs(Error)), o(e2);
})();
var $s = 2e4;
var qs = (function() {
  return o((function e3(n2, r3, i2) {
    t(this, e3), this._loadAttemptImpl = is() || !n2.avoidEval ? new zs(n2, r3, i2) : new Ws(n2, r3, i2);
  }), [{ key: "start", value: (e2 = p((function* () {
    return this._loadAttemptImpl.start();
  })), function() {
    return e2.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    this._loadAttemptImpl.cancel();
  } }, { key: "cancelled", get: function() {
    return this._loadAttemptImpl.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._loadAttemptImpl.succeeded;
  } }]);
  var e2;
})();
var zs = (function() {
  return o((function e3(n3, r4, i3) {
    t(this, e3), this.cancelled = false, this.succeeded = false, this._networkTimedOut = false, this._networkTimeout = null, this._iosCache = "undefined" != typeof iOSCallObjectBundleCache && iOSCallObjectBundleCache, this._refetchHeaders = null, this._dailyConfig = n3, this._successCallback = r4, this._failureCallback = i3;
  }), [{ key: "start", value: (i2 = p((function* () {
    var e3 = B(this._dailyConfig);
    !(yield this._tryLoadFromIOSCache(e3)) && this._loadFromNetwork(e3);
  })), function() {
    return i2.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    clearTimeout(this._networkTimeout), this.cancelled = true;
  } }, { key: "_tryLoadFromIOSCache", value: (r3 = p((function* (e3) {
    if (!this._iosCache) return false;
    try {
      var t2 = yield this._iosCache.get(e3);
      return !!this.cancelled || !!t2 && (t2.code ? (Function('"use strict";' + t2.code)(), this.succeeded = true, this._successCallback(), true) : (this._refetchHeaders = t2.refetchHeaders, false));
    } catch (e4) {
      return false;
    }
  })), function(e3) {
    return r3.apply(this, arguments);
  }) }, { key: "_loadFromNetwork", value: (n2 = p((function* (e3) {
    var t2 = this;
    this._networkTimeout = setTimeout((function() {
      t2._networkTimedOut = true, t2._failureCallback({ msg: "Timed out (>".concat($s, " ms) when loading call object bundle ").concat(e3), type: "timeout" });
    }), $s);
    try {
      var n3 = this._refetchHeaders ? { headers: this._refetchHeaders } : {}, r4 = yield fetch(e3, n3);
      if (clearTimeout(this._networkTimeout), this.cancelled || this._networkTimedOut) throw new Js();
      var i3 = yield this._getBundleCodeFromResponse(e3, r4);
      if (this.cancelled) throw new Js();
      Function('"use strict";' + i3)(), this._iosCache && this._iosCache.set(e3, i3, r4.headers), this.succeeded = true, this._successCallback();
    } catch (t3) {
      if (clearTimeout(this._networkTimeout), t3 instanceof Js || this.cancelled || this._networkTimedOut) return;
      this._failureCallback({ msg: "Failed to load call object bundle ".concat(e3, ": ").concat(t3), type: t3.message });
    }
  })), function(e3) {
    return n2.apply(this, arguments);
  }) }, { key: "_getBundleCodeFromResponse", value: (e2 = p((function* (e3, t2) {
    if (t2.ok) return yield t2.text();
    if (this._iosCache && 304 === t2.status) return (yield this._iosCache.renew(e3, t2.headers)).code;
    throw new Error("Received ".concat(t2.status, " response"));
  })), function(t2, n3) {
    return e2.apply(this, arguments);
  }) }]);
  var e2, n2, r3, i2;
})();
var Ws = (function() {
  return o((function e2(n2, r3, i2) {
    t(this, e2), this.cancelled = false, this.succeeded = false, this._dailyConfig = n2, this._successCallback = r3, this._failureCallback = i2, this._attemptId = N(), this._networkTimeout = null, this._scriptElement = null;
  }), [{ key: "start", value: function() {
    window._dailyCallMachineLoadWaitlist || (window._dailyCallMachineLoadWaitlist = /* @__PURE__ */ new Set());
    var e2 = B(this._dailyConfig);
    "object" === ("undefined" == typeof document ? "undefined" : n(document)) ? this._startLoading(e2) : this._failureCallback({ msg: "Call object bundle must be loaded in a DOM/web context", type: "missing context" });
  } }, { key: "cancel", value: function() {
    this._stopLoading(), this.cancelled = true;
  } }, { key: "_startLoading", value: function(e2) {
    var t2 = this;
    this._signUpForCallMachineLoadWaitlist(), this._networkTimeout = setTimeout((function() {
      t2._stopLoading(), t2._failureCallback({ msg: "Timed out (>".concat($s, " ms) when loading call object bundle ").concat(e2), type: "timeout" });
    }), $s);
    var n2 = document.getElementsByTagName("head")[0], r3 = document.createElement("script");
    this._scriptElement = r3, r3.onload = function() {
      t2._stopLoading(), t2.succeeded = true, t2._successCallback();
    }, r3.onerror = function(e3) {
      t2._stopLoading(), t2._failureCallback({ msg: "Failed to load call object bundle ".concat(e3.target.src), type: e3.message });
    }, r3.src = e2, n2.appendChild(r3);
  } }, { key: "_stopLoading", value: function() {
    this._withdrawFromCallMachineLoadWaitlist(), clearTimeout(this._networkTimeout), this._scriptElement && (this._scriptElement.onload = null, this._scriptElement.onerror = null);
  } }, { key: "_signUpForCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.add(this._attemptId);
  } }, { key: "_withdrawFromCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.delete(this._attemptId);
  } }]);
})();
var Hs = function(e2, t2, n2) {
  return true === Ks(e2.local, t2, n2);
};
var Gs = function(e2, t2, n2) {
  return e2.local.streams && e2.local.streams[t2] && e2.local.streams[t2].stream && e2.local.streams[t2].stream["get".concat("video" === n2 ? "Video" : "Audio", "Tracks")]()[0];
};
var Qs = function(e2, t2, n2, r3) {
  var i2 = Ys(e2, t2, n2, r3);
  return i2 && i2.pendingTrack;
};
var Ks = function(e2, t2, n2) {
  if (!e2) return false;
  var r3 = function(e3) {
    switch (e3) {
      case "avatar":
        return true;
      case "staged":
        return e3;
      default:
        return !!e3;
    }
  }, i2 = e2.public.subscribedTracks;
  return i2 && i2[t2] ? -1 === ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo"].indexOf(n2) && i2[t2].custom ? [true, "staged"].includes(i2[t2].custom) ? r3(i2[t2].custom) : r3(i2[t2].custom[n2]) : r3(i2[t2][n2]) : !i2 || r3(i2.ALL);
};
var Ys = function(e2, t2, n2, r3) {
  var i2 = Object.values(e2.streams || {}).filter((function(e3) {
    return e3.participantId === t2 && e3.type === n2 && e3.pendingTrack && e3.pendingTrack.kind === r3;
  })).sort((function(e3, t3) {
    return new Date(t3.starttime) - new Date(e3.starttime);
  }));
  return i2 && i2[0];
};
var Xs = function(e2, t2) {
  var n2 = e2.local.public.customTracks;
  if (n2 && n2[t2]) return n2[t2].track;
};
function Zs(e2, t2) {
  for (var n2 = t2.getState(), r3 = 0, i2 = ["cam", "screen"]; r3 < i2.length; r3++) for (var o2 = i2[r3], s2 = 0, a2 = ["video", "audio"]; s2 < a2.length; s2++) {
    var c2 = a2[s2], l2 = "cam" === o2 ? c2 : "screen".concat(c2.charAt(0).toUpperCase() + c2.slice(1)), u2 = e2.tracks[l2];
    if (u2) {
      var d2 = e2.local ? Gs(n2, o2, c2) : Qs(n2, e2.session_id, o2, c2);
      "playable" === u2.state && (u2.track = d2), u2.persistentTrack = d2;
    }
  }
}
function ea(e2, t2) {
  try {
    var n2 = t2.getState();
    for (var r3 in e2.tracks) if (!ta(r3)) {
      var i2 = e2.tracks[r3].kind;
      if (i2) {
        var o2 = e2.tracks[r3];
        if (o2) {
          var s2 = e2.local ? Xs(n2, r3) : Qs(n2, e2.session_id, r3, i2);
          "playable" === o2.state && (e2.tracks[r3].track = s2), o2.persistentTrack = s2;
        }
      } else console.error("unknown type for custom track");
    }
  } catch (e3) {
    console.error(e3);
  }
}
function ta(e2) {
  return ["video", "audio", "screenVideo", "screenAudio"].includes(e2);
}
function na(e2, t2, n2) {
  var r3 = n2.getState();
  if (e2.local) {
    if (e2.audio) try {
      e2.audioTrack = r3.local.streams.cam.stream.getAudioTracks()[0], e2.audioTrack || (e2.audio = false);
    } catch (e3) {
    }
    if (e2.video) try {
      e2.videoTrack = r3.local.streams.cam.stream.getVideoTracks()[0], e2.videoTrack || (e2.video = false);
    } catch (e3) {
    }
    if (e2.screen) try {
      e2.screenVideoTrack = r3.local.streams.screen.stream.getVideoTracks()[0], e2.screenAudioTrack = r3.local.streams.screen.stream.getAudioTracks()[0], e2.screenVideoTrack || e2.screenAudioTrack || (e2.screen = false);
    } catch (e3) {
    }
  } else {
    var i2 = true;
    try {
      var o2 = r3.participants[e2.session_id];
      o2 && o2.public && o2.public.rtcType && "peer-to-peer" === o2.public.rtcType.impl && o2.private && !["connected", "completed"].includes(o2.private.peeringState) && (i2 = false);
    } catch (e3) {
      console.error(e3);
    }
    if (!i2) return e2.audio = false, e2.audioTrack = false, e2.video = false, e2.videoTrack = false, e2.screen = false, void (e2.screenTrack = false);
    try {
      r3.streams;
      if (e2.audio && Hs(r3, e2.session_id, "cam-audio")) {
        var s2 = Qs(r3, e2.session_id, "cam", "audio");
        s2 && (t2 && t2.audioTrack && t2.audioTrack.id === s2.id ? e2.audioTrack = s2 : s2.muted || (e2.audioTrack = s2)), e2.audioTrack || (e2.audio = false);
      }
      if (e2.video && Hs(r3, e2.session_id, "cam-video")) {
        var a2 = Qs(r3, e2.session_id, "cam", "video");
        a2 && (t2 && t2.videoTrack && t2.videoTrack.id === a2.id ? e2.videoTrack = a2 : a2.muted || (e2.videoTrack = a2)), e2.videoTrack || (e2.video = false);
      }
      if (e2.screen && Hs(r3, e2.session_id, "screen-audio")) {
        var c2 = Qs(r3, e2.session_id, "screen", "audio");
        c2 && (t2 && t2.screenAudioTrack && t2.screenAudioTrack.id === c2.id ? e2.screenAudioTrack = c2 : c2.muted || (e2.screenAudioTrack = c2));
      }
      if (e2.screen && Hs(r3, e2.session_id, "screen-video")) {
        var l2 = Qs(r3, e2.session_id, "screen", "video");
        l2 && (t2 && t2.screenVideoTrack && t2.screenVideoTrack.id === l2.id ? e2.screenVideoTrack = l2 : l2.muted || (e2.screenVideoTrack = l2));
      }
      e2.screenVideoTrack || e2.screenAudioTrack || (e2.screen = false);
    } catch (e3) {
      console.error("unexpected error matching up tracks", e3);
    }
  }
}
function ra(e2, t2) {
  var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
  if (!n2) {
    if (Array.isArray(e2) || (n2 = (function(e3, t3) {
      if (e3) {
        if ("string" == typeof e3) return ia(e3, t3);
        var n3 = {}.toString.call(e3).slice(8, -1);
        return "Object" === n3 && e3.constructor && (n3 = e3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? ia(e3, t3) : void 0;
      }
    })(e2)) || t2 && e2 && "number" == typeof e2.length) {
      n2 && (e2 = n2);
      var r3 = 0, i2 = function() {
      };
      return { s: i2, n: function() {
        return r3 >= e2.length ? { done: true } : { done: false, value: e2[r3++] };
      }, e: function(e3) {
        throw e3;
      }, f: i2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, s2 = true, a2 = false;
  return { s: function() {
    n2 = n2.call(e2);
  }, n: function() {
    var e3 = n2.next();
    return s2 = e3.done, e3;
  }, e: function(e3) {
    a2 = true, o2 = e3;
  }, f: function() {
    try {
      s2 || null == n2.return || n2.return();
    } finally {
      if (a2) throw o2;
    }
  } };
}
function ia(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r3 = Array(t2); n2 < t2; n2++) r3[n2] = e2[n2];
  return r3;
}
var oa = /* @__PURE__ */ new Map();
var sa = null;
function aa(e2, t2) {
  var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
  if (!n2) {
    if (Array.isArray(e2) || (n2 = (function(e3, t3) {
      if (e3) {
        if ("string" == typeof e3) return ca(e3, t3);
        var n3 = {}.toString.call(e3).slice(8, -1);
        return "Object" === n3 && e3.constructor && (n3 = e3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? ca(e3, t3) : void 0;
      }
    })(e2)) || t2 && e2 && "number" == typeof e2.length) {
      n2 && (e2 = n2);
      var r3 = 0, i2 = function() {
      };
      return { s: i2, n: function() {
        return r3 >= e2.length ? { done: true } : { done: false, value: e2[r3++] };
      }, e: function(e3) {
        throw e3;
      }, f: i2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, s2 = true, a2 = false;
  return { s: function() {
    n2 = n2.call(e2);
  }, n: function() {
    var e3 = n2.next();
    return s2 = e3.done, e3;
  }, e: function(e3) {
    a2 = true, o2 = e3;
  }, f: function() {
    try {
      s2 || null == n2.return || n2.return();
    } finally {
      if (a2) throw o2;
    }
  } };
}
function ca(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r3 = Array(t2); n2 < t2; n2++) r3[n2] = e2[n2];
  return r3;
}
var la = /* @__PURE__ */ new Map();
var ua = null;
function da(e2) {
  ha() ? (function(e3) {
    oa.has(e3) || (oa.set(e3, {}), navigator.mediaDevices.enumerateDevices().then((function(t2) {
      oa.has(e3) && (oa.get(e3).lastDevicesString = JSON.stringify(t2), sa || (sa = (function() {
        var e4 = p((function* () {
          var e5, t3 = yield navigator.mediaDevices.enumerateDevices(), n2 = ra(oa.keys());
          try {
            for (n2.s(); !(e5 = n2.n()).done; ) {
              var r3 = e5.value, i2 = JSON.stringify(t3);
              i2 !== oa.get(r3).lastDevicesString && (oa.get(r3).lastDevicesString = i2, r3(t3));
            }
          } catch (e6) {
            n2.e(e6);
          } finally {
            n2.f();
          }
        }));
        return function() {
          return e4.apply(this, arguments);
        };
      })(), navigator.mediaDevices.addEventListener("devicechange", sa)));
    })).catch((function() {
    })));
  })(e2) : (function(e3) {
    la.has(e3) || (la.set(e3, {}), navigator.mediaDevices.enumerateDevices().then((function(t2) {
      la.has(e3) && (la.get(e3).lastDevicesString = JSON.stringify(t2), ua || (ua = setInterval(p((function* () {
        var e4, t3 = yield navigator.mediaDevices.enumerateDevices(), n2 = aa(la.keys());
        try {
          for (n2.s(); !(e4 = n2.n()).done; ) {
            var r3 = e4.value, i2 = JSON.stringify(t3);
            i2 !== la.get(r3).lastDevicesString && (la.get(r3).lastDevicesString = i2, r3(t3));
          }
        } catch (e5) {
          n2.e(e5);
        } finally {
          n2.f();
        }
      })), 3e3)));
    })));
  })(e2);
}
function pa(e2) {
  ha() ? (function(e3) {
    oa.has(e3) && (oa.delete(e3), 0 === oa.size && sa && (navigator.mediaDevices.removeEventListener("devicechange", sa), sa = null));
  })(e2) : (function(e3) {
    la.has(e3) && (la.delete(e3), 0 === la.size && ua && (clearInterval(ua), ua = null));
  })(e2);
}
function ha() {
  var e2;
  return is() || void 0 !== (null === (e2 = navigator.mediaDevices) || void 0 === e2 ? void 0 : e2.ondevicechange);
}
var fa = /* @__PURE__ */ new Set();
function va(e2, t2) {
  var n2 = t2.isLocalScreenVideo;
  return e2 && "live" === e2.readyState && !(function(e3, t3) {
    return (!t3.isLocalScreenVideo || "Chrome" !== ms()) && e3.muted && !fa.has(e3.id);
  })(e2, { isLocalScreenVideo: n2 });
}
function ga(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r3 = Object.getOwnPropertySymbols(e2);
    t2 && (r3 = r3.filter((function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    }))), n2.push.apply(n2, r3);
  }
  return n2;
}
function ma(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? ga(Object(n2), true).forEach((function(t3) {
      u(e2, t3, n2[t3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : ga(Object(n2)).forEach((function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
    }));
  }
  return e2;
}
var ya = Object.freeze({ VIDEO: "video", AUDIO: "audio", SCREEN_VIDEO: "screenVideo", SCREEN_AUDIO: "screenAudio", CUSTOM_VIDEO: "customVideo", CUSTOM_AUDIO: "customAudio" });
var ba = Object.freeze({ PARTICIPANTS: "participants", STREAMING: "streaming", TRANSCRIPTION: "transcription" });
var _a2 = Object.values(ya);
var wa = ["v", "a", "sv", "sa", "cv", "ca"];
Object.freeze(_a2.reduce((function(e2, t2, n2) {
  return e2[t2] = wa[n2], e2;
}), {})), Object.freeze(wa.reduce((function(e2, t2, n2) {
  return e2[t2] = _a2[n2], e2;
}), {}));
var Sa = [ya.VIDEO, ya.AUDIO, ya.SCREEN_VIDEO, ya.SCREEN_AUDIO];
var ka = Object.values(ba);
var Ma = ["p", "s", "t"];
Object.freeze(ka.reduce((function(e2, t2, n2) {
  return e2[t2] = Ma[n2], e2;
}), {})), Object.freeze(Ma.reduce((function(e2, t2, n2) {
  return e2[t2] = ka[n2], e2;
}), {}));
var Ca = (function() {
  function e2() {
    var n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = n2.base, i2 = n2.byUserId, o2 = n2.byParticipantId;
    t(this, e2), this.base = r3, this.byUserId = i2, this.byParticipantId = o2;
  }
  return o(e2, [{ key: "clone", value: function() {
    var t2 = new e2();
    if (this.base instanceof Ea ? t2.base = this.base.clone() : t2.base = this.base, void 0 !== this.byUserId) for (var n2 in t2.byUserId = {}, this.byUserId) {
      var r3 = this.byUserId[n2];
      t2.byUserId[n2] = r3 instanceof Ea ? r3.clone() : r3;
    }
    if (void 0 !== this.byParticipantId) for (var i2 in t2.byParticipantId = {}, this.byParticipantId) {
      var o2 = this.byParticipantId[i2];
      t2.byParticipantId[i2] = o2 instanceof Ea ? o2.clone() : o2;
    }
    return t2;
  } }, { key: "toJSONObject", value: function() {
    var e3 = {};
    if ("boolean" == typeof this.base ? e3.base = this.base : this.base instanceof Ea && (e3.base = this.base.toJSONObject()), void 0 !== this.byUserId) for (var t2 in e3.byUserId = {}, this.byUserId) {
      var n2 = this.byUserId[t2];
      e3.byUserId[t2] = n2 instanceof Ea ? n2.toJSONObject() : n2;
    }
    if (void 0 !== this.byParticipantId) for (var r3 in e3.byParticipantId = {}, this.byParticipantId) {
      var i2 = this.byParticipantId[r3];
      e3.byParticipantId[r3] = i2 instanceof Ea ? i2.toJSONObject() : i2;
    }
    return e3;
  } }, { key: "toMinifiedJSONObject", value: function() {
    var e3 = {};
    if (void 0 !== this.base && ("boolean" == typeof this.base ? e3.b = this.base : e3.b = this.base.toMinifiedJSONObject()), void 0 !== this.byUserId) for (var t2 in e3.u = {}, this.byUserId) {
      var n2 = this.byUserId[t2];
      e3.u[t2] = "boolean" == typeof n2 ? n2 : n2.toMinifiedJSONObject();
    }
    if (void 0 !== this.byParticipantId) for (var r3 in e3.p = {}, this.byParticipantId) {
      var i2 = this.byParticipantId[r3];
      e3.p[r3] = "boolean" == typeof i2 ? i2 : i2.toMinifiedJSONObject();
    }
    return e3;
  } }, { key: "normalize", value: function() {
    return this.base instanceof Ea && (this.base = this.base.normalize()), this.byUserId && (this.byUserId = Object.fromEntries(Object.entries(this.byUserId).map((function(e3) {
      var t2 = f(e3, 2), n2 = t2[0], r3 = t2[1];
      return [n2, r3 instanceof Ea ? r3.normalize() : r3];
    })))), this.byParticipantId && (this.byParticipantId = Object.fromEntries(Object.entries(this.byParticipantId).map((function(e3) {
      var t2 = f(e3, 2), n2 = t2[0], r3 = t2[1];
      return [n2, r3 instanceof Ea ? r3.normalize() : r3];
    })))), this;
  } }], [{ key: "fromJSONObject", value: function(t2) {
    var n2, r3, i2;
    if (void 0 !== t2.base && (n2 = "boolean" == typeof t2.base ? t2.base : Ea.fromJSONObject(t2.base)), void 0 !== t2.byUserId) for (var o2 in r3 = {}, t2.byUserId) {
      var s2 = t2.byUserId[o2];
      r3[o2] = "boolean" == typeof s2 ? s2 : Ea.fromJSONObject(s2);
    }
    if (void 0 !== t2.byParticipantId) for (var a2 in i2 = {}, t2.byParticipantId) {
      var c2 = t2.byParticipantId[a2];
      i2[a2] = "boolean" == typeof c2 ? c2 : Ea.fromJSONObject(c2);
    }
    return new e2({ base: n2, byUserId: r3, byParticipantId: i2 });
  } }, { key: "fromMinifiedJSONObject", value: function(t2) {
    var n2, r3, i2;
    if (void 0 !== t2.b && (n2 = "boolean" == typeof t2.b ? t2.b : Ea.fromMinifiedJSONObject(t2.b)), void 0 !== t2.u) for (var o2 in r3 = {}, t2.u) {
      var s2 = t2.u[o2];
      r3[o2] = "boolean" == typeof s2 ? s2 : Ea.fromMinifiedJSONObject(s2);
    }
    if (void 0 !== t2.p) for (var a2 in i2 = {}, t2.p) {
      var c2 = t2.p[a2];
      i2[a2] = "boolean" == typeof c2 ? c2 : Ea.fromMinifiedJSONObject(c2);
    }
    return new e2({ base: n2, byUserId: r3, byParticipantId: i2 });
  } }, { key: "validateJSONObject", value: function(e3) {
    if ("object" !== n(e3)) return [false, "canReceive must be an object"];
    for (var t2 = ["base", "byUserId", "byParticipantId"], r3 = 0, i2 = Object.keys(e3); r3 < i2.length; r3++) {
      var o2 = i2[r3];
      if (!t2.includes(o2)) return [false, "canReceive can only contain keys (".concat(t2.join(", "), ")")];
      if ("base" === o2) {
        var s2 = f(Ea.validateJSONObject(e3.base, true), 2), a2 = s2[0], c2 = s2[1];
        if (!a2) return [false, c2];
      } else {
        if ("object" !== n(e3[o2])) return [false, "invalid (non-object) value for field '".concat(o2, "' in canReceive")];
        for (var l2 = 0, u2 = Object.values(e3[o2]); l2 < u2.length; l2++) {
          var d2 = u2[l2], p2 = f(Ea.validateJSONObject(d2), 2), h3 = p2[0], v2 = p2[1];
          if (!h3) return [false, v2];
        }
      }
    }
    return [true];
  } }]);
})();
var Ea = (function() {
  function e2() {
    var n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = n2.video, i2 = n2.audio, o2 = n2.screenVideo, s2 = n2.screenAudio, a2 = n2.customVideo, c2 = n2.customAudio;
    t(this, e2), this.video = r3, this.audio = i2, this.screenVideo = o2, this.screenAudio = s2, this.customVideo = a2, this.customAudio = c2;
  }
  return o(e2, [{ key: "clone", value: function() {
    var t2 = new e2();
    return void 0 !== this.video && (t2.video = this.video), void 0 !== this.audio && (t2.audio = this.audio), void 0 !== this.screenVideo && (t2.screenVideo = this.screenVideo), void 0 !== this.screenAudio && (t2.screenAudio = this.screenAudio), void 0 !== this.customVideo && (t2.customVideo = ma({}, this.customVideo)), void 0 !== this.customAudio && (t2.customAudio = ma({}, this.customAudio)), t2;
  } }, { key: "toJSONObject", value: function() {
    var e3 = {};
    return void 0 !== this.video && (e3.video = this.video), void 0 !== this.audio && (e3.audio = this.audio), void 0 !== this.screenVideo && (e3.screenVideo = this.screenVideo), void 0 !== this.screenAudio && (e3.screenAudio = this.screenAudio), void 0 !== this.customVideo && (e3.customVideo = ma({}, this.customVideo)), void 0 !== this.customAudio && (e3.customAudio = ma({}, this.customAudio)), e3;
  } }, { key: "toMinifiedJSONObject", value: function() {
    var e3 = {};
    return void 0 !== this.video && (e3.v = this.video), void 0 !== this.audio && (e3.a = this.audio), void 0 !== this.screenVideo && (e3.sv = this.screenVideo), void 0 !== this.screenAudio && (e3.sa = this.screenAudio), void 0 !== this.customVideo && (e3.cv = ma({}, this.customVideo)), void 0 !== this.customAudio && (e3.ca = ma({}, this.customAudio)), e3;
  } }, { key: "normalize", value: function() {
    function e3(e4, t2) {
      return e4 && 1 === Object.keys(e4).length && e4["*"] === t2;
    }
    return !(true !== this.video || true !== this.audio || true !== this.screenVideo || true !== this.screenAudio || !e3(this.customVideo, true) || !e3(this.customAudio, true)) || (false !== this.video || false !== this.audio || false !== this.screenVideo || false !== this.screenAudio || !e3(this.customVideo, false) || !e3(this.customAudio, false)) && this;
  } }], [{ key: "fromBoolean", value: function(t2) {
    return new e2({ video: t2, audio: t2, screenVideo: t2, screenAudio: t2, customVideo: { "*": t2 }, customAudio: { "*": t2 } });
  } }, { key: "fromJSONObject", value: function(t2) {
    return new e2({ video: t2.video, audio: t2.audio, screenVideo: t2.screenVideo, screenAudio: t2.screenAudio, customVideo: void 0 !== t2.customVideo ? ma({}, t2.customVideo) : void 0, customAudio: void 0 !== t2.customAudio ? ma({}, t2.customAudio) : void 0 });
  } }, { key: "fromMinifiedJSONObject", value: function(t2) {
    return new e2({ video: t2.v, audio: t2.a, screenVideo: t2.sv, screenAudio: t2.sa, customVideo: t2.cv, customAudio: t2.ca });
  } }, { key: "validateJSONObject", value: function(e3, t2) {
    if ("boolean" == typeof e3) return [true];
    if ("object" !== n(e3)) return [false, "invalid (non-object, non-boolean) value in canReceive"];
    for (var r3 = Object.keys(e3), i2 = 0, o2 = r3; i2 < o2.length; i2++) {
      var s2 = o2[i2];
      if (!_a2.includes(s2)) return [false, "invalid media type '".concat(s2, "' in canReceive")];
      if (Sa.includes(s2)) {
        if ("boolean" != typeof e3[s2]) return [false, "invalid (non-boolean) value for media type '".concat(s2, "' in canReceive")];
      } else {
        if ("object" !== n(e3[s2])) return [false, "invalid (non-object) value for media type '".concat(s2, "' in canReceive")];
        for (var a2 = 0, c2 = Object.values(e3[s2]); a2 < c2.length; a2++) {
          if ("boolean" != typeof c2[a2]) return [false, "invalid (non-boolean) value for entry within '".concat(s2, "' in canReceive")];
        }
        if (t2 && void 0 === e3[s2]["*"]) return [false, `canReceive "base" permission must specify "*" as an entry within '`.concat(s2, "'")];
      }
    }
    return t2 && r3.length !== _a2.length ? [false, 'canReceive "base" permission must specify all media types: '.concat(_a2.join(", "), " (or be set to a boolean shorthand)")] : [true];
  } }]);
})();
var Ta = ["result"];
var Oa = ["preserveIframe"];
function Pa(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r3 = Object.getOwnPropertySymbols(e2);
    t2 && (r3 = r3.filter((function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    }))), n2.push.apply(n2, r3);
  }
  return n2;
}
function Aa(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? Pa(Object(n2), true).forEach((function(t3) {
      u(e2, t3, n2[t3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : Pa(Object(n2)).forEach((function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
    }));
  }
  return e2;
}
function ja() {
  try {
    var e2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
    })));
  } catch (e3) {
  }
  return (ja = function() {
    return !!e2;
  })();
}
function Ia(e2, t2) {
  var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
  if (!n2) {
    if (Array.isArray(e2) || (n2 = (function(e3, t3) {
      if (e3) {
        if ("string" == typeof e3) return xa(e3, t3);
        var n3 = {}.toString.call(e3).slice(8, -1);
        return "Object" === n3 && e3.constructor && (n3 = e3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? xa(e3, t3) : void 0;
      }
    })(e2)) || t2 && e2 && "number" == typeof e2.length) {
      n2 && (e2 = n2);
      var r3 = 0, i2 = function() {
      };
      return { s: i2, n: function() {
        return r3 >= e2.length ? { done: true } : { done: false, value: e2[r3++] };
      }, e: function(e3) {
        throw e3;
      }, f: i2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, s2 = true, a2 = false;
  return { s: function() {
    n2 = n2.call(e2);
  }, n: function() {
    var e3 = n2.next();
    return s2 = e3.done, e3;
  }, e: function(e3) {
    a2 = true, o2 = e3;
  }, f: function() {
    try {
      s2 || null == n2.return || n2.return();
    } finally {
      if (a2) throw o2;
    }
  } };
}
function xa(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r3 = Array(t2); n2 < t2; n2++) r3[n2] = e2[n2];
  return r3;
}
var La = {};
var Da = "video";
var Na = "voice";
var Ra = is() ? { data: {} } : { data: {}, topology: "none" };
var Fa = { present: 0, hidden: 0 };
var Ba = { maxBitrate: { min: 1e5, max: 25e5 }, maxFramerate: { min: 1, max: 30 }, scaleResolutionDownBy: { min: 1, max: 8 } };
var Ua = Object.keys(Ba);
var Va = ["state", "volume", "simulcastEncodings"];
var Ja = { androidInCallNotification: { title: "string", subtitle: "string", iconName: "string", disableForCustomOverride: "boolean" }, disableAutoDeviceManagement: { audio: "boolean", video: "boolean" } };
var $a = { id: { iconPath: "string", iconPathDarkMode: "string", label: "string", tooltip: "string", visualState: "'default' | 'sidebar-open' | 'active'" } };
var qa = { id: { allow: "string", controlledBy: "'*' | 'owners' | string[]", csp: "string", iconURL: "string", label: "string", loading: "'eager' | 'lazy'", location: "'main' | 'sidebar'", name: "string", referrerPolicy: "string", sandbox: "string", src: "string", srcdoc: "string", shared: "string[] | 'owners' | boolean" } };
var za = { customIntegrations: { validate: vc, help: hc() }, customTrayButtons: { validate: fc, help: "customTrayButtons should be a dictionary of the type ".concat(JSON.stringify($a)) }, url: { validate: function(e2) {
  return "string" == typeof e2;
}, help: "url should be a string" }, baseUrl: { validate: function(e2) {
  return "string" == typeof e2;
}, help: "baseUrl should be a string" }, token: { validate: function(e2) {
  return "string" == typeof e2;
}, help: "token should be a string", queryString: "t" }, dailyConfig: { validate: function(e2, t2) {
  try {
    return t2.validateDailyConfig(e2), true;
  } catch (e3) {
    console.error("Failed to validate dailyConfig", e3);
  }
  return false;
}, help: "Unsupported dailyConfig. Check error logs for detailed info." }, reactNativeConfig: { validate: function(e2) {
  return gc(e2, Ja);
}, help: "reactNativeConfig should look like ".concat(JSON.stringify(Ja), ", all fields optional") }, lang: { validate: function(e2) {
  return ["da", "de", "en-us", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pl", "pt", "pt-BR", "ru", "sv", "tr", "user"].includes(e2);
}, help: "language not supported. Options are: da, de, en-us, en, es, fi, fr, it, jp, ka, nl, no, pl, pt, pt-BR, ru, sv, tr, user" }, userName: true, userData: { validate: function(e2) {
  try {
    return ic(e2), true;
  } catch (e3) {
    return console.error(e3), false;
  }
}, help: "invalid userData type provided" }, startVideoOff: true, startAudioOff: true, allowLocalVideo: true, allowLocalAudio: true, activeSpeakerMode: true, showLeaveButton: true, showLocalVideo: true, showParticipantsBar: true, showFullscreenButton: true, showUserNameChangeUI: true, iframeStyle: true, customLayout: true, cssFile: true, cssText: true, bodyClass: true, videoSource: { validate: function(e2, t2) {
  if ("boolean" == typeof e2) return t2._preloadCache.allowLocalVideo = e2, true;
  var n2;
  if (e2 instanceof MediaStreamTrack) t2._sharedTracks.videoTrack = e2, n2 = { customTrack: Qo };
  else {
    if (delete t2._sharedTracks.videoTrack, "string" != typeof e2) return console.error("videoSource must be a MediaStreamTrack, boolean, or a string"), false;
    n2 = { deviceId: e2 };
  }
  return t2._updatePreloadCacheInputSettings({ video: { settings: n2 } }, false), true;
} }, audioSource: { validate: function(e2, t2) {
  if ("boolean" == typeof e2) return t2._preloadCache.allowLocalAudio = e2, true;
  var n2;
  if (e2 instanceof MediaStreamTrack) t2._sharedTracks.audioTrack = e2, n2 = { customTrack: Qo };
  else {
    if (delete t2._sharedTracks.audioTrack, "string" != typeof e2) return console.error("audioSource must be a MediaStreamTrack, boolean, or a string"), false;
    n2 = { deviceId: e2 };
  }
  return t2._updatePreloadCacheInputSettings({ audio: { settings: n2 } }, false), true;
} }, subscribeToTracksAutomatically: { validate: function(e2, t2) {
  return t2._preloadCache.subscribeToTracksAutomatically = e2, true;
} }, theme: { validate: function(e2) {
  var t2 = ["accent", "accentText", "background", "backgroundAccent", "baseText", "border", "mainAreaBg", "mainAreaBgAccent", "mainAreaText", "supportiveText"], r3 = function(e3) {
    for (var n2 = 0, r4 = Object.keys(e3); n2 < r4.length; n2++) {
      var i2 = r4[n2];
      if (!t2.includes(i2)) return console.error('unsupported color "'.concat(i2, '". Valid colors: ').concat(t2.join(", "))), false;
      if (!e3[i2].match(/^#[0-9a-f]{6}|#[0-9a-f]{3}$/i)) return console.error("".concat(i2, ' theme color should be provided in valid hex color format. Received: "').concat(e3[i2], '"')), false;
    }
    return true;
  };
  return "object" === n(e2) && ("light" in e2 && "dark" in e2 || "colors" in e2) ? "light" in e2 && "dark" in e2 ? "colors" in e2.light ? "colors" in e2.dark ? r3(e2.light.colors) && r3(e2.dark.colors) : (console.error('Dark theme is missing "colors" property.', e2), false) : (console.error('Light theme is missing "colors" property.', e2), false) : r3(e2.colors) : (console.error('Theme must contain either both "light" and "dark" properties, or "colors".', e2), false);
}, help: "unsupported theme configuration. Check error logs for detailed info." }, layoutConfig: { validate: function(e2) {
  if ("grid" in e2) {
    var t2 = e2.grid;
    if ("maxTilesPerPage" in t2) {
      if (!Number.isInteger(t2.maxTilesPerPage)) return console.error("grid.maxTilesPerPage should be an integer. You passed ".concat(t2.maxTilesPerPage, ".")), false;
      if (t2.maxTilesPerPage > 49) return console.error("grid.maxTilesPerPage can't be larger than 49 without sacrificing browser performance. Please contact us at https://www.daily.co/contact to talk about your use case."), false;
    }
    if ("minTilesPerPage" in t2) {
      if (!Number.isInteger(t2.minTilesPerPage)) return console.error("grid.minTilesPerPage should be an integer. You passed ".concat(t2.minTilesPerPage, ".")), false;
      if (t2.minTilesPerPage < 1) return console.error("grid.minTilesPerPage can't be lower than 1."), false;
      if ("maxTilesPerPage" in t2 && t2.minTilesPerPage > t2.maxTilesPerPage) return console.error("grid.minTilesPerPage can't be higher than grid.maxTilesPerPage."), false;
    }
  }
  return true;
}, help: "unsupported layoutConfig. Check error logs for detailed info." }, receiveSettings: { validate: function(e2) {
  return oc(e2, { allowAllParticipantsKey: false });
}, help: pc({ allowAllParticipantsKey: false }) }, sendSettings: { validate: function(e2, t2) {
  return !!(function(e3, t3) {
    try {
      return t3.validateUpdateSendSettings(e3), true;
    } catch (e4) {
      return console.error("Failed to validate send settings", e4), false;
    }
  })(e2, t2) && (t2._preloadCache.sendSettings = e2, true);
}, help: "Invalid sendSettings provided. Check error logs for detailed info." }, inputSettings: { validate: function(e2, t2) {
  var n2;
  return !!sc(e2) && (t2._inputSettings || (t2._inputSettings = {}), ac(e2, null === (n2 = t2.properties) || void 0 === n2 ? void 0 : n2.dailyConfig, t2._sharedTracks), t2._updatePreloadCacheInputSettings(e2, true), true);
}, help: dc() }, layout: { validate: function(e2) {
  return "custom-v1" === e2 || "browser" === e2 || "none" === e2;
}, help: 'layout may only be set to "custom-v1"', queryString: "layout" }, emb: { queryString: "emb" }, embHref: { queryString: "embHref" }, dailyJsVersion: { queryString: "dailyJsVersion" }, proxy: { queryString: "proxy" }, strictMode: true, allowMultipleCallInstances: true };
var Wa = { styles: { validate: function(e2) {
  for (var t2 in e2) if ("cam" !== t2 && "screen" !== t2) return false;
  if (e2.cam) {
    for (var n2 in e2.cam) if ("div" !== n2 && "video" !== n2) return false;
  }
  if (e2.screen) {
    for (var r3 in e2.screen) if ("div" !== r3 && "video" !== r3) return false;
  }
  return true;
}, help: "styles format should be a subset of: { cam: {div: {}, video: {}}, screen: {div: {}, video: {}} }" }, setSubscribedTracks: { validate: function(e2, t2) {
  if (t2._preloadCache.subscribeToTracksAutomatically) return false;
  var n2 = [true, false, "staged"];
  if (n2.includes(e2) || !is() && "avatar" === e2) return true;
  var r3 = ["audio", "video", "screenAudio", "screenVideo", "rmpAudio", "rmpVideo"], i2 = function(e3) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    for (var o2 in e3) if ("custom" === o2) {
      if (!n2.includes(e3[o2]) && !i2(e3[o2], true)) return false;
    } else {
      var s2 = !t3 && !r3.includes(o2), a2 = !n2.includes(e3[o2]);
      if (s2 || a2) return false;
    }
    return true;
  };
  return i2(e2);
}, help: "setSubscribedTracks cannot be used when setSubscribeToTracksAutomatically is enabled, and should be of the form: " + "true".concat(is() ? "" : " | 'avatar'", " | false | 'staged' | { [audio: true|false|'staged'], [video: true|false|'staged'], [screenAudio: true|false|'staged'], [screenVideo: true|false|'staged'] }") }, setAudio: true, setVideo: true, setScreenShare: { validate: function(e2) {
  return false === e2;
}, help: "setScreenShare must be false, as it's only meant for stopping remote participants' screen shares" }, eject: true, updatePermissions: { validate: function(e2) {
  for (var t2 = 0, n2 = Object.entries(e2); t2 < n2.length; t2++) {
    var r3 = f(n2[t2], 2), i2 = r3[0], o2 = r3[1];
    switch (i2) {
      case "hasPresence":
        if ("boolean" != typeof o2) return false;
        break;
      case "canSend":
        if (o2 instanceof Set || o2 instanceof Array || Array.isArray(o2)) {
          var s2, a2 = ["video", "audio", "screenVideo", "screenAudio", "customVideo", "customAudio"], c2 = Ia(o2);
          try {
            for (c2.s(); !(s2 = c2.n()).done; ) {
              var l2 = s2.value;
              if (!a2.includes(l2)) return false;
            }
          } catch (e3) {
            c2.e(e3);
          } finally {
            c2.f();
          }
        } else if ("boolean" != typeof o2) return false;
        (o2 instanceof Array || Array.isArray(o2)) && (e2.canSend = new Set(o2));
        break;
      case "canReceive":
        var u2 = f(Ca.validateJSONObject(o2), 2), d2 = u2[0], p2 = u2[1];
        if (!d2) return console.error(p2), false;
        break;
      case "canAdmin":
        if (o2 instanceof Set || o2 instanceof Array || Array.isArray(o2)) {
          var h3, v2 = ["participants", "streaming", "transcription"], g2 = Ia(o2);
          try {
            for (g2.s(); !(h3 = g2.n()).done; ) {
              var m2 = h3.value;
              if (!v2.includes(m2)) return false;
            }
          } catch (e3) {
            g2.e(e3);
          } finally {
            g2.f();
          }
        } else if ("boolean" != typeof o2) return false;
        (o2 instanceof Array || Array.isArray(o2)) && (e2.canAdmin = new Set(o2));
        break;
      default:
        return false;
    }
  }
  return true;
}, help: "updatePermissions can take hasPresence, canSend, canReceive, and canAdmin permissions. hasPresence must be a boolean. canSend can be a boolean or an Array or Set of media types (video, audio, screenVideo, screenAudio, customVideo, customAudio). canReceive must be an object specifying base, byUserId, and/or byParticipantId fields (see documentation for more details). canAdmin can be a boolean or an Array or Set of admin types (participants, streaming, transcription)." } };
Promise.any || (Promise.any = (function() {
  var e2 = p((function* (e3) {
    return new Promise((function(t2, n2) {
      var r3 = [];
      e3.forEach((function(i2) {
        return Promise.resolve(i2).then((function(e4) {
          t2(e4);
        })).catch((function(t3) {
          r3.push(t3), r3.length === e3.length && n2(r3);
        }));
      }));
    }));
  }));
  return function(t2) {
    return e2.apply(this, arguments);
  };
})());
var Ha = (function() {
  function r3(e2) {
    var n2, i3, o2, c3, l2, d3, h4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (t(this, r3), o2 = this, c3 = a(c3 = r3), u(i3 = s(o2, ja() ? Reflect.construct(c3, l2 || [], a(o2).constructor) : c3.apply(o2, l2)), "startListeningForDeviceChanges", (function() {
      da(i3.handleDeviceChange);
    })), u(i3, "stopListeningForDeviceChanges", (function() {
      pa(i3.handleDeviceChange);
    })), u(i3, "handleDeviceChange", (function(e3) {
      e3 = e3.map((function(e4) {
        return JSON.parse(JSON.stringify(e4));
      })), i3.emitDailyJSEvent({ action: "available-devices-updated", availableDevices: e3 });
    })), u(i3, "handleNativeAppStateChange", (function() {
      var e3 = p((function* (e4) {
        if ("destroyed" === e4) return console.warn("App has been destroyed before leaving the meeting. Cleaning up all the resources!"), void (yield i3.destroy());
        var t2 = "active" === e4;
        i3.disableReactNativeAutoDeviceManagement("video") || (t2 ? i3.camUnmutedBeforeLosingNativeActiveState && i3.setLocalVideo(true) : (i3.camUnmutedBeforeLosingNativeActiveState = i3.localVideo(), i3.camUnmutedBeforeLosingNativeActiveState && i3.setLocalVideo(false)));
      }));
      return function(t2) {
        return e3.apply(this, arguments);
      };
    })()), u(i3, "handleNativeAudioFocusChange", (function(e3) {
      i3.disableReactNativeAutoDeviceManagement("audio") || (i3._hasNativeAudioFocus = e3, i3.toggleParticipantAudioBasedOnNativeAudioFocus(), i3._hasNativeAudioFocus ? i3.micUnmutedBeforeLosingNativeAudioFocus && i3.setLocalAudio(true) : (i3.micUnmutedBeforeLosingNativeAudioFocus = i3.localAudio(), i3.setLocalAudio(false)));
    })), u(i3, "handleNativeSystemScreenCaptureStop", (function() {
      i3.stopScreenShare();
    })), i3.strictMode = void 0 === h4.strictMode || h4.strictMode, i3.allowMultipleCallInstances = null !== (n2 = h4.allowMultipleCallInstances) && void 0 !== n2 && n2, Object.keys(La).length && (i3._logDuplicateInstanceAttempt(), !i3.allowMultipleCallInstances)) {
      if (i3.strictMode) throw new Error("Duplicate DailyIframe instances are not allowed");
      console.warn("Using strictMode: false to allow multiple call instances is now deprecated. Set `allowMultipleCallInstances: true`");
    }
    if (window._daily || (window._daily = { pendings: [], instances: {} }), i3.callClientId = N(), La[(d3 = i3).callClientId] = d3, window._daily.instances[i3.callClientId] = {}, i3._sharedTracks = {}, window._daily.instances[i3.callClientId].tracks = i3._sharedTracks, h4.dailyJsVersion = r3.version(), i3._iframe = e2, i3._callObjectMode = "none" === h4.layout && !i3._iframe, i3._preloadCache = { subscribeToTracksAutomatically: true, outputDeviceId: null, inputSettings: null, sendSettings: null, videoTrackForNetworkConnectivityTest: null, videoTrackForConnectionQualityTest: null }, void 0 !== h4.showLocalVideo ? i3._callObjectMode ? console.error("showLocalVideo is not available in call object mode") : i3._showLocalVideo = !!h4.showLocalVideo : i3._showLocalVideo = true, void 0 !== h4.showParticipantsBar ? i3._callObjectMode ? console.error("showParticipantsBar is not available in call object mode") : i3._showParticipantsBar = !!h4.showParticipantsBar : i3._showParticipantsBar = true, void 0 !== h4.customIntegrations ? i3._callObjectMode ? console.error("customIntegrations is not available in call object mode") : i3._customIntegrations = h4.customIntegrations : i3._customIntegrations = {}, void 0 !== h4.customTrayButtons ? i3._callObjectMode ? console.error("customTrayButtons is not available in call object mode") : i3._customTrayButtons = h4.customTrayButtons : i3._customTrayButtons = {}, void 0 !== h4.activeSpeakerMode ? i3._callObjectMode ? console.error("activeSpeakerMode is not available in call object mode") : i3._activeSpeakerMode = !!h4.activeSpeakerMode : i3._activeSpeakerMode = false, h4.receiveSettings ? i3._callObjectMode ? i3._receiveSettings = h4.receiveSettings : console.error("receiveSettings is only available in call object mode") : i3._receiveSettings = {}, i3.validateProperties(h4), i3.properties = Aa({}, h4), i3._inputSettings || (i3._inputSettings = {}), i3._callObjectLoader = i3._callObjectMode ? new Us(i3.callClientId) : null, i3._callState = ti, i3._isPreparingToJoin = false, i3._accessState = { access: fi }, i3._meetingSessionSummary = {}, i3._finalSummaryOfPrevSession = {}, i3._meetingSessionState = _c(Ra, i3._callObjectMode), i3._nativeInCallAudioMode = Da, i3._participants = {}, i3._isScreenSharing = false, i3._participantCounts = Fa, i3._rmpPlayerState = {}, i3._waitingParticipants = {}, i3._network = { threshold: "good", quality: 100, networkState: "unknown", stats: {} }, i3._activeSpeaker = {}, i3._localAudioLevel = 0, i3._isLocalAudioLevelObserverRunning = false, i3._remoteParticipantsAudioLevel = {}, i3._isRemoteParticipantsAudioLevelObserverRunning = false, i3._maxAppMessageSize = $o, i3._messageChannel = is() ? new js() : new Os(), i3._iframe && (i3._iframe.requestFullscreen ? i3._iframe.addEventListener("fullscreenchange", (function() {
      document.fullscreenElement === i3._iframe ? (i3.emitDailyJSEvent({ action: Io }), i3.sendMessageToCallMachine({ action: Io })) : (i3.emitDailyJSEvent({ action: xo }), i3.sendMessageToCallMachine({ action: xo }));
    })) : i3._iframe.webkitRequestFullscreen && i3._iframe.addEventListener("webkitfullscreenchange", (function() {
      document.webkitFullscreenElement === i3._iframe ? (i3.emitDailyJSEvent({ action: Io }), i3.sendMessageToCallMachine({ action: Io })) : (i3.emitDailyJSEvent({ action: xo }), i3.sendMessageToCallMachine({ action: xo }));
    }))), is()) {
      var f2 = i3.nativeUtils();
      f2.addAudioFocusChangeListener && f2.removeAudioFocusChangeListener && f2.addAppStateChangeListener && f2.removeAppStateChangeListener && f2.addSystemScreenCaptureStopListener && f2.removeSystemScreenCaptureStopListener || console.warn("expected (add|remove)(AudioFocusChange|AppActiveStateChange|SystemScreenCaptureStop)Listener to be available in React Native"), i3._hasNativeAudioFocus = true, f2.addAudioFocusChangeListener(i3.handleNativeAudioFocusChange), f2.addAppStateChangeListener(i3.handleNativeAppStateChange), f2.addSystemScreenCaptureStopListener(i3.handleNativeSystemScreenCaptureStop);
    }
    return i3._callObjectMode && i3.startListeningForDeviceChanges(), i3._messageChannel.addListenerForMessagesFromCallMachine(i3.handleMessageFromCallMachine, i3.callClientId, i3), i3;
  }
  return l(r3, b), o(r3, [{ key: "destroy", value: (ee2 = p((function* () {
    var e2;
    try {
      yield this.leave();
    } catch (e3) {
    }
    var t2 = this._iframe;
    if (t2) {
      var n2 = t2.parentElement;
      n2 && n2.removeChild(t2);
    }
    if (this._messageChannel.removeListener(this.handleMessageFromCallMachine), is()) {
      var r4 = this.nativeUtils();
      r4.removeAudioFocusChangeListener(this.handleNativeAudioFocusChange), r4.removeAppStateChangeListener(this.handleNativeAppStateChange), r4.removeSystemScreenCaptureStopListener(this.handleNativeSystemScreenCaptureStop);
    }
    this._callObjectMode && this.stopListeningForDeviceChanges(), this.resetMeetingDependentVars(), this._destroyed = true, this.emitDailyJSEvent({ action: "call-instance-destroyed" }), delete La[this.callClientId], (null === (e2 = window) || void 0 === e2 || null === (e2 = e2._daily) || void 0 === e2 ? void 0 : e2.instances) && delete window._daily.instances[this.callClientId], this.strictMode && (this.callClientId = void 0);
  })), function() {
    return ee2.apply(this, arguments);
  }) }, { key: "isDestroyed", value: function() {
    return !!this._destroyed;
  } }, { key: "loadCss", value: function(e2) {
    var t2 = e2.bodyClass, n2 = e2.cssFile, r4 = e2.cssText;
    return nc(), this.sendMessageToCallMachine({ action: "load-css", cssFile: this.absoluteUrl(n2), bodyClass: t2, cssText: r4 }), this;
  } }, { key: "iframe", value: function() {
    return nc(), this._iframe;
  } }, { key: "meetingState", value: function() {
    return this._callState;
  } }, { key: "accessState", value: function() {
    return ec(this._callObjectMode, "accessState()"), this._accessState;
  } }, { key: "participants", value: function() {
    return this._participants;
  } }, { key: "participantCounts", value: function() {
    return this._participantCounts;
  } }, { key: "waitingParticipants", value: function() {
    return ec(this._callObjectMode, "waitingParticipants()"), this._waitingParticipants;
  } }, { key: "validateParticipantProperties", value: function(e2, t2) {
    for (var n2 in t2) {
      if (!Wa[n2]) throw new Error("unrecognized updateParticipant property ".concat(n2));
      if (Wa[n2].validate && !Wa[n2].validate(t2[n2], this, this._participants[e2])) throw new Error(Wa[n2].help);
    }
  } }, { key: "updateParticipant", value: function(e2, t2) {
    return this._participants.local && this._participants.local.session_id === e2 && (e2 = "local"), e2 && t2 && (this.validateParticipantProperties(e2, t2), this.sendMessageToCallMachine({ action: "update-participant", id: e2, properties: t2 })), this;
  } }, { key: "updateParticipants", value: function(e2) {
    var t2 = this._participants.local && this._participants.local.session_id;
    for (var n2 in e2) n2 === t2 && (n2 = "local"), n2 && e2[n2] && this.validateParticipantProperties(n2, e2[n2]);
    return this.sendMessageToCallMachine({ action: "update-participants", participants: e2 }), this;
  } }, { key: "updateWaitingParticipant", value: (Z2 = p((function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (ec(this._callObjectMode, "updateWaitingParticipant()"), Qa(this._callState, "updateWaitingParticipant()"), "string" != typeof t2 || "object" !== n(r4)) throw new Error("updateWaitingParticipant() must take an id string and a updates object");
    return new Promise((function(n2, i3) {
      e2.sendMessageToCallMachine({ action: "daily-method-update-waiting-participant", id: t2, updates: r4 }, (function(e3) {
        e3.error && i3(e3.error), e3.id || i3(new Error("unknown error in updateWaitingParticipant()")), n2({ id: e3.id });
      }));
    }));
  })), function() {
    return Z2.apply(this, arguments);
  }) }, { key: "updateWaitingParticipants", value: (X3 = p((function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (ec(this._callObjectMode, "updateWaitingParticipants()"), Qa(this._callState, "updateWaitingParticipants()"), "object" !== n(t2)) throw new Error("updateWaitingParticipants() must take a mapping between ids and update objects");
    return new Promise((function(n2, r4) {
      e2.sendMessageToCallMachine({ action: "daily-method-update-waiting-participants", updatesById: t2 }, (function(e3) {
        e3.error && r4(e3.error), e3.ids || r4(new Error("unknown error in updateWaitingParticipants()")), n2({ ids: e3.ids });
      }));
    }));
  })), function() {
    return X3.apply(this, arguments);
  }) }, { key: "requestAccess", value: (Y2 = p((function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = t2.access, r4 = void 0 === n2 ? { level: vi } : n2, i3 = t2.name, o2 = void 0 === i3 ? "" : i3;
    return ec(this._callObjectMode, "requestAccess()"), Qa(this._callState, "requestAccess()"), new Promise((function(t3, n3) {
      e2.sendMessageToCallMachine({ action: "daily-method-request-access", access: r4, name: o2 }, (function(e3) {
        e3.error && n3(e3.error), e3.access || n3(new Error("unknown error in requestAccess()")), t3({ access: e3.access, granted: e3.granted });
      }));
    }));
  })), function() {
    return Y2.apply(this, arguments);
  }) }, { key: "localAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.audio.state) : null;
  } }, { key: "localVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.video.state) : null;
  } }, { key: "setLocalAudio", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return "forceDiscardTrack" in t2 && (is() ? (console.warn("forceDiscardTrack option not supported in React Native; ignoring"), t2 = {}) : e2 && (console.warn("forceDiscardTrack option only supported when calling setLocalAudio(false); ignoring"), t2 = {})), this.sendMessageToCallMachine({ action: "local-audio", state: e2, options: t2 }), this;
  } }, { key: "localScreenAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenAudio.state) : null;
  } }, { key: "localScreenVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenVideo.state) : null;
  } }, { key: "updateScreenShare", value: function(e2) {
    if (this._isScreenSharing) return this.sendMessageToCallMachine({ action: "local-screen-update", options: e2 }), this;
    console.warn("There is no screen share in progress. Try calling startScreenShare first.");
  } }, { key: "setLocalVideo", value: function(e2) {
    return this.sendMessageToCallMachine({ action: "local-video", state: e2 }), this;
  } }, { key: "_setAllowLocalAudio", value: function(e2) {
    if (this._preloadCache.allowLocalAudio = e2, this._callMachineInitialized) return this.sendMessageToCallMachine({ action: "set-allow-local-audio", state: e2 }), this;
  } }, { key: "_setAllowLocalVideo", value: function(e2) {
    if (this._preloadCache.allowLocalVideo = e2, this._callMachineInitialized) return this.sendMessageToCallMachine({ action: "set-allow-local-video", state: e2 }), this;
  } }, { key: "getReceiveSettings", value: (K2 = p((function* (e2) {
    var t2 = this, r4 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).showInheritedValues, i3 = void 0 !== r4 && r4;
    if (ec(this._callObjectMode, "getReceiveSettings()"), !this._callMachineInitialized) return this._receiveSettings;
    switch (n(e2)) {
      case "string":
        return new Promise((function(n2) {
          t2.sendMessageToCallMachine({ action: "get-single-participant-receive-settings", id: e2, showInheritedValues: i3 }, (function(e3) {
            n2(e3.receiveSettings);
          }));
        }));
      case "undefined":
        return this._receiveSettings;
      default:
        throw new Error('first argument to getReceiveSettings() must be a participant id (or "base"), or there should be no arguments');
    }
  })), function(e2) {
    return K2.apply(this, arguments);
  }) }, { key: "updateReceiveSettings", value: (Q2 = p((function* (e2) {
    var t2 = this;
    if (ec(this._callObjectMode, "updateReceiveSettings()"), !oc(e2, { allowAllParticipantsKey: true })) throw new Error(pc({ allowAllParticipantsKey: true }));
    return Qa(this._callState, "updateReceiveSettings()", "To specify receive settings earlier, use the receiveSettings config property."), new Promise((function(n2) {
      t2.sendMessageToCallMachine({ action: "update-receive-settings", receiveSettings: e2 }, (function(e3) {
        n2({ receiveSettings: e3.receiveSettings });
      }));
    }));
  })), function(e2) {
    return Q2.apply(this, arguments);
  }) }, { key: "_prepInputSettingsForSharing", value: function(e2, t2) {
    if (e2) {
      var n2 = {};
      if (e2.audio) {
        var r4, i3, o2;
        e2.audio.settings && (!Object.keys(e2.audio.settings).length && t2 || (n2.audio = { settings: Aa({}, e2.audio.settings) })), t2 && null !== (r4 = n2.audio) && void 0 !== r4 && null !== (r4 = r4.settings) && void 0 !== r4 && r4.customTrack && (n2.audio.settings = { customTrack: this._sharedTracks.audioTrack });
        var s2 = "none" === (null === (i3 = e2.audio.processor) || void 0 === i3 ? void 0 : i3.type) && (null === (o2 = e2.audio.processor) || void 0 === o2 ? void 0 : o2._isDefaultWhenNone);
        if (e2.audio.processor && !s2) {
          var a2 = Aa({}, e2.audio.processor);
          delete a2._isDefaultWhenNone, n2.audio = Aa(Aa({}, n2.audio), {}, { processor: a2 });
        }
      }
      if (e2.video) {
        var c3, l2, u2;
        e2.video.settings && (!Object.keys(e2.video.settings).length && t2 || (n2.video = { settings: Aa({}, e2.video.settings) })), t2 && null !== (c3 = n2.video) && void 0 !== c3 && null !== (c3 = c3.settings) && void 0 !== c3 && c3.customTrack && (n2.video.settings = { customTrack: this._sharedTracks.videoTrack });
        var d3 = "none" === (null === (l2 = e2.video.processor) || void 0 === l2 ? void 0 : l2.type) && (null === (u2 = e2.video.processor) || void 0 === u2 ? void 0 : u2._isDefaultWhenNone);
        if (e2.video.processor && !d3) {
          var p2 = Aa({}, e2.video.processor);
          delete p2._isDefaultWhenNone, n2.video = Aa(Aa({}, n2.video), {}, { processor: p2 });
        }
      }
      return n2;
    }
  } }, { key: "getInputSettings", value: function() {
    var e2 = this;
    return nc(), new Promise((function(t2) {
      t2(e2._getInputSettings());
    }));
  } }, { key: "_getInputSettings", value: function() {
    var e2, t2, n2, r4, i3, o2, s2 = { processor: { type: "none", _isDefaultWhenNone: true } };
    this._inputSettings ? (e2 = (null === (n2 = this._inputSettings) || void 0 === n2 ? void 0 : n2.video) || s2, t2 = (null === (r4 = this._inputSettings) || void 0 === r4 ? void 0 : r4.audio) || s2) : (e2 = (null === (i3 = this._preloadCache) || void 0 === i3 || null === (i3 = i3.inputSettings) || void 0 === i3 ? void 0 : i3.video) || s2, t2 = (null === (o2 = this._preloadCache) || void 0 === o2 || null === (o2 = o2.inputSettings) || void 0 === o2 ? void 0 : o2.audio) || s2);
    var a2 = { audio: t2, video: e2 };
    return this._prepInputSettingsForSharing(a2, true);
  } }, { key: "_updatePreloadCacheInputSettings", value: function(e2, t2) {
    var n2 = this._inputSettings || {}, r4 = {};
    if (e2.video) {
      var i3, o2, s2;
      if (r4.video = {}, e2.video.settings) r4.video.settings = {}, t2 || e2.video.settings.customTrack || null === (s2 = n2.video) || void 0 === s2 || !s2.settings ? r4.video.settings = e2.video.settings : r4.video.settings = Aa(Aa({}, n2.video.settings), e2.video.settings), Object.keys(r4.video.settings).length || delete r4.video.settings;
      else null !== (i3 = n2.video) && void 0 !== i3 && i3.settings && (r4.video.settings = n2.video.settings);
      e2.video.processor ? r4.video.processor = e2.video.processor : null !== (o2 = n2.video) && void 0 !== o2 && o2.processor && (r4.video.processor = n2.video.processor);
    } else n2.video && (r4.video = n2.video);
    if (e2.audio) {
      var a2, c3, l2;
      if (r4.audio = {}, e2.audio.settings) r4.audio.settings = {}, t2 || e2.audio.settings.customTrack || null === (l2 = n2.audio) || void 0 === l2 || !l2.settings ? r4.audio.settings = e2.audio.settings : r4.audio.settings = Aa(Aa({}, n2.audio.settings), e2.audio.settings), Object.keys(r4.audio.settings).length || delete r4.audio.settings;
      else null !== (a2 = n2.audio) && void 0 !== a2 && a2.settings && (r4.audio.settings = n2.audio.settings);
      e2.audio.processor ? r4.audio.processor = e2.audio.processor : null !== (c3 = n2.audio) && void 0 !== c3 && c3.processor && (r4.audio.processor = n2.audio.processor);
    } else n2.audio && (r4.audio = n2.audio);
    this._maybeUpdateInputSettings(r4);
  } }, { key: "_devicesFromInputSettings", value: function(e2) {
    var t2, n2, r4 = (null == e2 || null === (t2 = e2.video) || void 0 === t2 || null === (t2 = t2.settings) || void 0 === t2 ? void 0 : t2.deviceId) || null, i3 = (null == e2 || null === (n2 = e2.audio) || void 0 === n2 || null === (n2 = n2.settings) || void 0 === n2 ? void 0 : n2.deviceId) || null, o2 = this._preloadCache.outputDeviceId || null;
    return { camera: r4 ? { deviceId: r4 } : {}, mic: i3 ? { deviceId: i3 } : {}, speaker: o2 ? { deviceId: o2 } : {} };
  } }, { key: "updateInputSettings", value: (G2 = p((function* (e2) {
    var t2 = this;
    return nc(), sc(e2) ? e2.video || e2.audio ? (ac(e2, this.properties.dailyConfig, this._sharedTracks), this._callObjectMode && !this._callMachineInitialized ? (this._updatePreloadCacheInputSettings(e2, true), this._getInputSettings()) : new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine({ action: "update-input-settings", inputSettings: e2 }, (function(i3) {
        if (i3.error) r4(i3.error);
        else {
          if (i3.returnPreloadCache) return t2._updatePreloadCacheInputSettings(e2, true), void n2(t2._getInputSettings());
          t2._maybeUpdateInputSettings(i3.inputSettings), n2(t2._prepInputSettingsForSharing(i3.inputSettings, true));
        }
      }));
    }))) : this._getInputSettings() : (console.error(dc()), Promise.reject(dc()));
  })), function(e2) {
    return G2.apply(this, arguments);
  }) }, { key: "setBandwidth", value: function(e2) {
    var t2 = e2.kbs, n2 = e2.trackConstraints;
    if (nc(), this._callMachineInitialized) return this.sendMessageToCallMachine({ action: "set-bandwidth", kbs: t2, trackConstraints: n2 }), this;
  } }, { key: "getDailyLang", value: function() {
    var e2 = this;
    if (nc(), this._callMachineInitialized) return new Promise((function(t2) {
      e2.sendMessageToCallMachine({ action: "get-daily-lang" }, (function(e3) {
        delete e3.action, delete e3.callbackStamp, t2(e3);
      }));
    }));
  } }, { key: "setDailyLang", value: function(e2) {
    return nc(), this.sendMessageToCallMachine({ action: "set-daily-lang", lang: e2 }), this;
  } }, { key: "setProxyUrl", value: function(e2) {
    return this.sendMessageToCallMachine({ action: "set-proxy-url", proxyUrl: e2 }), this;
  } }, { key: "setIceConfig", value: function(e2) {
    return this.sendMessageToCallMachine({ action: "set-ice-config", iceConfig: e2 }), this;
  } }, { key: "meetingSessionSummary", value: function() {
    return [si, ai].includes(this._callState) ? this._finalSummaryOfPrevSession : this._meetingSessionSummary;
  } }, { key: "getMeetingSession", value: (H2 = p((function* () {
    var e2 = this;
    return console.warn("getMeetingSession() is deprecated: use meetingSessionSummary(), which will return immediately"), Qa(this._callState, "getMeetingSession()"), new Promise((function(t2) {
      e2.sendMessageToCallMachine({ action: "get-meeting-session" }, (function(e3) {
        delete e3.action, delete e3.callbackStamp, t2(e3);
      }));
    }));
  })), function() {
    return H2.apply(this, arguments);
  }) }, { key: "meetingSessionState", value: function() {
    return Qa(this._callState, "meetingSessionState"), this._meetingSessionState;
  } }, { key: "setMeetingSessionData", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "replace";
    ec(this._callObjectMode, "setMeetingSessionData()"), Qa(this._callState, "setMeetingSessionData");
    try {
      !(function(e3, t3) {
        new Ds({ data: e3, mergeStrategy: t3 });
      })(e2, t2);
    } catch (e3) {
      throw console.error(e3), e3;
    }
    try {
      this.sendMessageToCallMachine({ action: "set-session-data", data: e2, mergeStrategy: t2 });
    } catch (e3) {
      throw new Error("Error setting meeting session data: ".concat(e3));
    }
  } }, { key: "setUserName", value: function(e2, t2) {
    var n2 = this;
    return this.properties.userName = e2, new Promise((function(r4) {
      n2.sendMessageToCallMachine({ action: "set-user-name", name: null != e2 ? e2 : "", thisMeetingOnly: is() || !!t2 && !!t2.thisMeetingOnly }, (function(e3) {
        delete e3.action, delete e3.callbackStamp, r4(e3);
      }));
    }));
  } }, { key: "setUserData", value: (W2 = p((function* (e2) {
    var t2 = this;
    try {
      ic(e2);
    } catch (e3) {
      throw console.error(e3), e3;
    }
    if (this.properties.userData = e2, this._callMachineInitialized) return new Promise((function(n2) {
      try {
        t2.sendMessageToCallMachine({ action: "set-user-data", userData: e2 }, (function(e3) {
          delete e3.action, delete e3.callbackStamp, n2(e3);
        }));
      } catch (e3) {
        throw new Error("Error setting user data: ".concat(e3));
      }
    }));
  })), function(e2) {
    return W2.apply(this, arguments);
  }) }, { key: "validateAudioLevelInterval", value: function(e2) {
    if (e2 && (e2 < 100 || "number" != typeof e2)) throw new Error("The interval must be a number greater than or equal to 100 milliseconds.");
  } }, { key: "startLocalAudioLevelObserver", value: function(e2) {
    var t2 = this;
    if ("undefined" == typeof AudioWorkletNode && !is()) throw new Error("startLocalAudioLevelObserver() is not supported on this browser");
    if (this.validateAudioLevelInterval(e2), this._callMachineInitialized) return this._isLocalAudioLevelObserverRunning = true, new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine({ action: "start-local-audio-level-observer", interval: e2 }, (function(e3) {
        t2._isLocalAudioLevelObserverRunning = !e3.error, e3.error ? r4({ error: e3.error }) : n2();
      }));
    }));
    this._preloadCache.localAudioLevelObserver = { enabled: true, interval: e2 };
  } }, { key: "isLocalAudioLevelObserverRunning", value: function() {
    return this._isLocalAudioLevelObserverRunning;
  } }, { key: "stopLocalAudioLevelObserver", value: function() {
    this._preloadCache.localAudioLevelObserver = null, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-local-audio-level-observer" });
  } }, { key: "startRemoteParticipantsAudioLevelObserver", value: function(e2) {
    var t2 = this;
    if (this.validateAudioLevelInterval(e2), this._callMachineInitialized) return this._isRemoteParticipantsAudioLevelObserverRunning = true, new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine({ action: "start-remote-participants-audio-level-observer", interval: e2 }, (function(e3) {
        t2._isRemoteParticipantsAudioLevelObserverRunning = !e3.error, e3.error ? r4({ error: e3.error }) : n2();
      }));
    }));
    this._preloadCache.remoteParticipantsAudioLevelObserver = { enabled: true, interval: e2 };
  } }, { key: "isRemoteParticipantsAudioLevelObserverRunning", value: function() {
    return this._isRemoteParticipantsAudioLevelObserverRunning;
  } }, { key: "stopRemoteParticipantsAudioLevelObserver", value: function() {
    this._preloadCache.remoteParticipantsAudioLevelObserver = null, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-remote-participants-audio-level-observer" });
  } }, { key: "startCamera", value: (z2 = p((function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (ec(this._callObjectMode, "startCamera()"), Ya(this._callState, this._isPreparingToJoin, "startCamera()", "Did you mean to use setLocalAudio() and/or setLocalVideo() instead?"), this.needsLoad()) try {
      yield this.load(t2);
    } catch (e3) {
      return Promise.reject(e3);
    }
    else {
      if (this._didPreAuth) {
        if (t2.url && t2.url !== this.properties.url) return console.error("url in startCamera() is different than the one used in preAuth()"), Promise.reject();
        if (t2.token && t2.token !== this.properties.token) return console.error("token in startCamera() is different than the one used in preAuth()"), Promise.reject();
      }
      this.validateProperties(t2), this.properties = Aa(Aa({}, this.properties), t2);
    }
    return new Promise((function(t3) {
      e2._preloadCache.inputSettings = e2._prepInputSettingsForSharing(e2._inputSettings, false), e2.sendMessageToCallMachine({ action: "start-camera", properties: Ga(e2.properties, e2.callClientId), preloadCache: Ga(e2._preloadCache, e2.callClientId) }, (function(e3) {
        t3({ camera: e3.camera, mic: e3.mic, speaker: e3.speaker });
      }));
    }));
  })), function() {
    return z2.apply(this, arguments);
  }) }, { key: "validateCustomTrack", value: function(e2, t2, n2) {
    if (n2 && n2.length > 50) throw new Error("Custom track `trackName` must not be more than 50 characters");
    if (t2 && "music" !== t2 && "speech" !== t2 && !(t2 instanceof Object)) throw new Error("Custom track `mode` must be either `music` | `speech` | `DailyMicAudioModeSettings` or `undefined`");
    if (!!n2 && ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo", "customVideoDefaults"].includes(n2)) throw new Error("Custom track `trackName` must not match a track name already used by daily: cam-audio, cam-video, customVideoDefaults, screen-video, screen-audio, rmpAudio, rmpVideo");
    if (!(e2 instanceof MediaStreamTrack)) throw new Error("Custom tracks provided must be instances of MediaStreamTrack");
  } }, { key: "startCustomTrack", value: function() {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { track, mode, trackName, ignoreAudioLevel };
    return nc(), Qa(this._callState, "startCustomTrack()"), this.validateCustomTrack(t2.track, t2.mode, t2.trackName), new Promise((function(n2, r4) {
      e2._sharedTracks.customTrack = t2.track, t2.track = Qo, e2.sendMessageToCallMachine({ action: "start-custom-track", properties: t2 }, (function(e3) {
        e3.error ? r4({ error: e3.error }) : n2(e3.mediaTag);
      }));
    }));
  } }, { key: "stopCustomTrack", value: function(e2) {
    var t2 = this;
    return nc(), Qa(this._callState, "stopCustomTrack()"), new Promise((function(n2) {
      t2.sendMessageToCallMachine({ action: "stop-custom-track", mediaTag: e2 }, (function(e3) {
        n2(e3.mediaTag);
      }));
    }));
  } }, { key: "setCamera", value: function(e2) {
    var t2 = this;
    return rc(), Xa(this._callMachineInitialized, "setCamera()"), new Promise((function(n2) {
      t2.sendMessageToCallMachine({ action: "set-camera", cameraDeviceId: e2 }, (function(e3) {
        n2({ device: e3.device });
      }));
    }));
  } }, { key: "setAudioDevice", value: (q2 = p((function* (e2) {
    return rc(), this.nativeUtils().setAudioDevice(e2), { deviceId: yield this.nativeUtils().getAudioDevice() };
  })), function(e2) {
    return q2.apply(this, arguments);
  }) }, { key: "cycleCamera", value: function() {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new Promise((function(n2) {
      e2.sendMessageToCallMachine({ action: "cycle-camera", properties: t2 }, (function(e3) {
        n2({ device: e3.device });
      }));
    }));
  } }, { key: "cycleMic", value: function() {
    var e2 = this;
    return nc(), new Promise((function(t2) {
      e2.sendMessageToCallMachine({ action: "cycle-mic" }, (function(e3) {
        t2({ device: e3.device });
      }));
    }));
  } }, { key: "getCameraFacingMode", value: function() {
    var e2 = this;
    return rc(), new Promise((function(t2) {
      e2.sendMessageToCallMachine({ action: "get-camera-facing-mode" }, (function(e3) {
        t2(e3.facingMode);
      }));
    }));
  } }, { key: "setInputDevicesAsync", value: ($2 = p((function* (e2) {
    var t2 = this, n2 = e2.audioDeviceId, r4 = e2.videoDeviceId, i3 = e2.audioSource, o2 = e2.videoSource;
    if (nc(), void 0 !== i3 && (n2 = i3), void 0 !== o2 && (r4 = o2), "boolean" == typeof n2 && (this._setAllowLocalAudio(n2), n2 = void 0), "boolean" == typeof r4 && (this._setAllowLocalVideo(r4), r4 = void 0), !n2 && !r4) return yield this.getInputDevices();
    var s2 = {};
    return n2 && (n2 instanceof MediaStreamTrack ? (this._sharedTracks.audioTrack = n2, n2 = Qo, s2.audio = { settings: { customTrack: n2 } }) : (delete this._sharedTracks.audioTrack, s2.audio = { settings: { deviceId: n2 } })), r4 && (r4 instanceof MediaStreamTrack ? (this._sharedTracks.videoTrack = r4, r4 = Qo, s2.video = { settings: { customTrack: r4 } }) : (delete this._sharedTracks.videoTrack, s2.video = { settings: { deviceId: r4 } })), this._callObjectMode && this.needsLoad() ? (this._updatePreloadCacheInputSettings(s2, false), this._devicesFromInputSettings(this._inputSettings)) : new Promise((function(e3) {
      t2.sendMessageToCallMachine({ action: "set-input-devices", audioDeviceId: n2, videoDeviceId: r4 }, (function(n3) {
        if (delete n3.action, delete n3.callbackStamp, n3.returnPreloadCache) return t2._updatePreloadCacheInputSettings(s2, false), void e3(t2._devicesFromInputSettings(t2._inputSettings));
        e3(n3);
      }));
    }));
  })), function(e2) {
    return $2.apply(this, arguments);
  }) }, { key: "setOutputDeviceAsync", value: (J2 = p((function* (e2) {
    var t2 = this, n2 = e2.outputDeviceId;
    if (nc(), !n2 || "string" != typeof n2) throw new Error("outputDeviceId must be provided and must be a valid device id");
    return this._preloadCache.outputDeviceId = n2, this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise((function(e3, r4) {
      t2.sendMessageToCallMachine({ action: "set-output-device", outputDeviceId: n2 }, (function(n3) {
        if (delete n3.action, delete n3.callbackStamp, n3.error) {
          var i3 = new Error(n3.error.message);
          return i3.type = n3.error.type, void r4(i3);
        }
        n3.returnPreloadCache ? e3(t2._devicesFromInputSettings(t2._inputSettings)) : e3(n3);
      }));
    }));
  })), function(e2) {
    return J2.apply(this, arguments);
  }) }, { key: "getInputDevices", value: (V2 = p((function* () {
    var e2 = this;
    return this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise((function(t2) {
      e2.sendMessageToCallMachine({ action: "get-input-devices" }, (function(n2) {
        n2.returnPreloadCache ? t2(e2._devicesFromInputSettings(e2._inputSettings)) : t2({ camera: n2.camera, mic: n2.mic, speaker: n2.speaker });
      }));
    }));
  })), function() {
    return V2.apply(this, arguments);
  }) }, { key: "nativeInCallAudioMode", value: function() {
    return rc(), this._nativeInCallAudioMode;
  } }, { key: "setNativeInCallAudioMode", value: function(e2) {
    if (rc(), [Da, Na].includes(e2)) {
      if (e2 !== this._nativeInCallAudioMode) return this._nativeInCallAudioMode = e2, !this.disableReactNativeAutoDeviceManagement("audio") && Ka(this._callState, this._isPreparingToJoin) && this.nativeUtils().setAudioMode(this._nativeInCallAudioMode), this;
    } else console.error("invalid in-call audio mode specified: ", e2);
  } }, { key: "preAuth", value: (U2 = p((function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (ec(this._callObjectMode, "preAuth()"), Ya(this._callState, this._isPreparingToJoin, "preAuth()"), this.needsLoad() && (yield this.load(t2)), !t2.url) throw new Error("preAuth() requires at least a url to be provided");
    return this.validateProperties(t2), this.properties = Aa(Aa({}, this.properties), t2), new Promise((function(t3, n2) {
      e2._preloadCache.inputSettings = e2._prepInputSettingsForSharing(e2._inputSettings, false), e2.sendMessageToCallMachine({ action: "daily-method-preauth", properties: Ga(e2.properties, e2.callClientId), preloadCache: Ga(e2._preloadCache, e2.callClientId) }, (function(r4) {
        return r4.error ? n2(r4.error) : r4.access ? (e2._didPreAuth = true, void t3({ access: r4.access })) : n2(new Error("unknown error in preAuth()"));
      }));
    }));
  })), function() {
    return U2.apply(this, arguments);
  }) }, { key: "load", value: (R2 = p((function* (e2) {
    var t2 = this;
    if (this.needsLoad()) {
      if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode)) throw new Error("Use after destroy");
      if (e2 && (this.validateProperties(e2), this.properties = Aa(Aa({}, this.properties), e2)), !this._callObjectMode && !this.properties.url) throw new Error("can't load iframe meeting because url property isn't set");
      return this._updateCallState(ni), this.emitDailyJSEvent({ action: Vi }), this._callObjectMode ? new Promise((function(e3, n2) {
        t2._callObjectLoader.cancel();
        var r4 = Date.now();
        t2._callObjectLoader.load(t2.properties.dailyConfig, (function(n3) {
          t2._bundleLoadTime = n3 ? "no-op" : Date.now() - r4, t2._updateCallState(ri), n3 && t2.emitDailyJSEvent({ action: $i }), e3();
        }), (function(e4, r5) {
          if (t2.emitDailyJSEvent({ action: Ji }), !r5) {
            t2._updateCallState(ai), t2.resetMeetingDependentVars();
            var i3 = { action: Jo, errorMsg: e4.msg, error: { type: "connection-error", msg: "Failed to load call object bundle.", details: { on: "load", sourceError: e4, bundleUrl: B(t2.properties.dailyConfig) } } };
            t2._maybeSendToSentry(i3), t2.emitDailyJSEvent(i3), n2(e4.msg);
          }
        }));
      })) : (this._iframe.src = F(this.assembleMeetingUrl(), this.properties.dailyConfig), new Promise((function(e3, n2) {
        t2._loadedCallback = function(r4) {
          t2._callState !== ai ? (t2._updateCallState(ri), (t2.properties.cssFile || t2.properties.cssText) && t2.loadCss(t2.properties), e3()) : n2(r4);
        };
      })));
    }
  })), function(e2) {
    return R2.apply(this, arguments);
  }) }, { key: "join", value: (L2 = p((function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this._testCallInProgress && this.stopTestCallQuality();
    var n2 = false;
    if (this.needsLoad()) {
      this.updateIsPreparingToJoin(true);
      try {
        yield this.load(t2);
      } catch (e3) {
        return this.updateIsPreparingToJoin(false), Promise.reject(e3);
      }
    } else {
      if (n2 = !(!this.properties.cssFile && !this.properties.cssText), this._didPreAuth) {
        if (t2.url && t2.url !== this.properties.url) return console.error("url in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
        if (t2.token && t2.token !== this.properties.token) return console.error("token in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
      }
      if (t2.url && !this._callObjectMode && t2.url && t2.url !== this.properties.url) return console.error("url in join() is different than the one used in load() (".concat(this.properties.url, " -> ").concat(t2.url, ")")), this.updateIsPreparingToJoin(false), Promise.reject();
      this.validateProperties(t2), this.properties = Aa(Aa({}, this.properties), t2);
    }
    return void 0 !== t2.showLocalVideo && (this._callObjectMode ? console.error("showLocalVideo is not available in callObject mode") : this._showLocalVideo = !!t2.showLocalVideo), void 0 !== t2.showParticipantsBar && (this._callObjectMode ? console.error("showParticipantsBar is not available in callObject mode") : this._showParticipantsBar = !!t2.showParticipantsBar), this._callState === oi || this._callState === ii ? (console.warn("already joined meeting, call leave() before joining again"), void this.updateIsPreparingToJoin(false)) : (this._updateCallState(ii, false), this.emitDailyJSEvent({ action: Wi }), this._preloadCache.inputSettings = this._prepInputSettingsForSharing(this._inputSettings || {}, false), this.sendMessageToCallMachine({ action: "join-meeting", properties: Ga(this.properties, this.callClientId), preloadCache: Ga(this._preloadCache, this.callClientId) }), new Promise((function(t3, r4) {
      e2._joinedCallback = function(i3, o2) {
        if (e2._callState !== ai) {
          if (e2._updateCallState(oi), i3) for (var s2 in i3) {
            if (e2._callObjectMode) {
              var a2 = e2._callMachine().store;
              Zs(i3[s2], a2), ea(i3[s2], a2), na(i3[s2], e2._participants[s2], a2);
            }
            e2._participants[s2] = Aa({}, i3[s2]), e2.toggleParticipantAudioBasedOnNativeAudioFocus();
          }
          n2 && e2.loadCss(e2.properties), t3(i3);
        } else r4(o2);
      };
    })));
  })), function() {
    return L2.apply(this, arguments);
  }) }, { key: "leave", value: (x2 = p((function* () {
    var e2 = this;
    return this._testCallInProgress && this.stopTestCallQuality(), new Promise((function(t2) {
      e2._callState === si || e2._callState === ai ? t2() : e2._callObjectLoader && !e2._callObjectLoader.loaded ? (e2._callObjectLoader.cancel(), e2._updateCallState(si), e2.resetMeetingDependentVars(), e2.emitDailyJSEvent({ action: si }), t2()) : (e2._resolveLeave = t2, e2.sendMessageToCallMachine({ action: "leave-meeting" }));
    }));
  })), function() {
    return x2.apply(this, arguments);
  }) }, { key: "startScreenShare", value: (I2 = p((function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (Xa(this._callMachineInitialized, "startScreenShare()"), t2.screenVideoSendSettings && this._validateVideoSendSettings("screenVideo", t2.screenVideoSendSettings), t2.mediaStream && (this._sharedTracks.screenMediaStream = t2.mediaStream, t2.mediaStream = Qo), "undefined" != typeof DailyNativeUtils && void 0 !== DailyNativeUtils.isIOS && DailyNativeUtils.isIOS) {
      var n2 = this.nativeUtils();
      if (yield n2.isScreenBeingCaptured()) return void this.emitDailyJSEvent({ action: Vo, type: "screen-share-error", errorMsg: "Could not start the screen sharing. The screen is already been captured!" });
      n2.setSystemScreenCaptureStartCallback((function() {
        n2.setSystemScreenCaptureStartCallback(null), e2.sendMessageToCallMachine({ action: Wo, captureOptions: t2 });
      })), n2.presentSystemScreenCapturePrompt();
    } else this.sendMessageToCallMachine({ action: Wo, captureOptions: t2 });
  })), function() {
    return I2.apply(this, arguments);
  }) }, { key: "stopScreenShare", value: function() {
    Xa(this._callMachineInitialized, "stopScreenShare()"), this.sendMessageToCallMachine({ action: "local-screen-stop" });
  } }, { key: "startRecording", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = e2.type;
    if (t2 && "cloud" !== t2 && "raw-tracks" !== t2 && "local" !== t2) throw new Error("invalid type: ".concat(t2, ", allowed values 'cloud', 'raw-tracks', or 'local'"));
    this.sendMessageToCallMachine(Aa({ action: "local-recording-start" }, e2));
  } }, { key: "updateRecording", value: function(e2) {
    var t2 = e2.layout, n2 = void 0 === t2 ? { preset: "default" } : t2, r4 = e2.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-recording", layout: n2, instanceId: r4 });
  } }, { key: "stopRecording", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Aa({ action: "local-recording-stop" }, e2));
  } }, { key: "startLiveStreaming", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Aa({ action: "daily-method-start-live-streaming" }, e2));
  } }, { key: "updateLiveStreaming", value: function(e2) {
    var t2 = e2.layout, n2 = void 0 === t2 ? { preset: "default" } : t2, r4 = e2.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-live-streaming", layout: n2, instanceId: r4 });
  } }, { key: "addLiveStreamingEndpoints", value: function(e2) {
    var t2 = e2.endpoints, n2 = e2.instanceId;
    this.sendMessageToCallMachine({ action: Ho, endpointsOp: es, endpoints: t2, instanceId: n2 });
  } }, { key: "removeLiveStreamingEndpoints", value: function(e2) {
    var t2 = e2.endpoints, n2 = e2.instanceId;
    this.sendMessageToCallMachine({ action: Ho, endpointsOp: ts, endpoints: t2, instanceId: n2 });
  } }, { key: "stopLiveStreaming", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Aa({ action: "daily-method-stop-live-streaming" }, e2));
  } }, { key: "validateDailyConfig", value: function(e2) {
    e2.camSimulcastEncodings && (console.warn("camSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide camera simulcast settings."), this.validateSimulcastEncodings(e2.camSimulcastEncodings)), e2.screenSimulcastEncodings && console.warn("screenSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide screen simulcast settings."), vs() && e2.noAutoDefaultDeviceChange && console.warn("noAutoDefaultDeviceChange is not supported on Android, and will be ignored.");
  } }, { key: "validateSimulcastEncodings", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (e2) {
      if (!(e2 instanceof Array || Array.isArray(e2))) throw new Error("encodings must be an Array");
      if (!bc(e2.length, 1, 3)) throw new Error("encodings must be an Array with between 1 to ".concat(3, " layers"));
      for (var r4 = 0; r4 < e2.length; r4++) {
        var i3 = e2[r4];
        for (var o2 in this._validateEncodingLayerHasValidProperties(i3), i3) if (Ua.includes(o2)) {
          if ("number" != typeof i3[o2]) throw new Error("".concat(o2, " must be a number"));
          if (t2) {
            var s2 = t2[o2], a2 = s2.min, c3 = s2.max;
            if (!bc(i3[o2], a2, c3)) throw new Error("".concat(o2, " value not in range. valid range: ").concat(a2, " to ").concat(c3));
          }
        } else if (!["active", "scalabilityMode"].includes(o2)) throw new Error("Invalid key ".concat(o2, ", valid keys are:") + Object.values(Ua));
        if (n2 && !i3.hasOwnProperty("maxBitrate")) throw new Error("maxBitrate is not specified");
      }
    }
  } }, { key: "startRemoteMediaPlayer", value: (j2 = p((function* (e2) {
    var t2 = this, n2 = e2.url, r4 = e2.settings, i3 = void 0 === r4 ? { state: Xo.PLAY } : r4;
    try {
      !(function(e3) {
        if ("string" != typeof e3) throw new Error('url parameter must be "string" type');
      })(n2), yc(i3), (function(e3) {
        for (var t3 in e3) if (!Va.includes(t3)) throw new Error("Invalid key ".concat(t3, ", valid keys are: ").concat(Va));
        e3.simulcastEncodings && this.validateSimulcastEncodings(e3.simulcastEncodings, Ba, true);
      })(i3);
    } catch (e3) {
      throw console.error("invalid argument Error: ".concat(e3)), console.error('startRemoteMediaPlayer arguments must be of the form:\n  { url: "playback url",\n  settings?:\n  {state: "play"|"pause", simulcastEncodings?: [{}] } }'), e3;
    }
    return new Promise((function(e3, r5) {
      t2.sendMessageToCallMachine({ action: "daily-method-start-remote-media-player", url: n2, settings: i3 }, (function(t3) {
        t3.error ? r5({ error: t3.error, errorMsg: t3.errorMsg }) : e3({ session_id: t3.session_id, remoteMediaPlayerState: { state: t3.state, settings: t3.settings } });
      }));
    }));
  })), function(e2) {
    return j2.apply(this, arguments);
  }) }, { key: "stopRemoteMediaPlayer", value: (A2 = p((function* (e2) {
    var t2 = this;
    if ("string" != typeof e2) throw new Error(" remotePlayerID must be of type string");
    return new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine({ action: "daily-method-stop-remote-media-player", session_id: e2 }, (function(e3) {
        e3.error ? r4({ error: e3.error, errorMsg: e3.errorMsg }) : n2();
      }));
    }));
  })), function(e2) {
    return A2.apply(this, arguments);
  }) }, { key: "updateRemoteMediaPlayer", value: (P2 = p((function* (e2) {
    var t2 = this, n2 = e2.session_id, r4 = e2.settings;
    try {
      yc(r4);
    } catch (e3) {
      throw console.error("invalid argument Error: ".concat(e3)), console.error('updateRemoteMediaPlayer arguments must be of the form:\n  session_id: "participant session",\n  { settings?: {state: "play"|"pause"} }'), e3;
    }
    return new Promise((function(e3, i3) {
      t2.sendMessageToCallMachine({ action: "daily-method-update-remote-media-player", session_id: n2, settings: r4 }, (function(t3) {
        t3.error ? i3({ error: t3.error, errorMsg: t3.errorMsg }) : e3({ session_id: t3.session_id, remoteMediaPlayerState: { state: t3.state, settings: t3.settings } });
      }));
    }));
  })), function(e2) {
    return P2.apply(this, arguments);
  }) }, { key: "startTranscription", value: function(e2) {
    Qa(this._callState, "startTranscription()"), this.sendMessageToCallMachine(Aa({ action: "daily-method-start-transcription" }, e2));
  } }, { key: "updateTranscription", value: function(e2) {
    if (Qa(this._callState, "updateTranscription()"), !e2) throw new Error("updateTranscription Error: options is mandatory");
    if ("object" !== n(e2)) throw new Error("updateTranscription Error: options must be object type");
    if (e2.participants && !Array.isArray(e2.participants)) throw new Error("updateTranscription Error: participants must be an array");
    this.sendMessageToCallMachine(Aa({ action: "daily-method-update-transcription" }, e2));
  } }, { key: "stopTranscription", value: function(e2) {
    if (Qa(this._callState, "stopTranscription()"), e2 && "object" !== n(e2)) throw new Error("stopTranscription Error: options must be object type");
    if (e2 && !e2.instanceId) throw new Error('"instanceId" not provided');
    this.sendMessageToCallMachine(Aa({ action: "daily-method-stop-transcription" }, e2));
  } }, { key: "startDialOut", value: (O2 = p((function* (e2) {
    var t2 = this;
    Qa(this._callState, "startDialOut()");
    var n2 = function(e3) {
      if (e3) {
        if (!Array.isArray(e3)) throw new Error("Error starting dial out: audio codec must be an array");
        if (e3.length <= 0) throw new Error("Error starting dial out: audio codec array specified but empty");
        e3.forEach((function(e4) {
          if ("string" != typeof e4) throw new Error("Error starting dial out: audio codec must be a string");
          if ("OPUS" !== e4 && "PCMU" !== e4 && "PCMA" !== e4 && "G722" !== e4) throw new Error("Error starting dial out: audio codec must be one of OPUS, PCMU, PCMA, G722");
        }));
      }
    };
    if (!e2.sipUri && !e2.phoneNumber) throw new Error("Error starting dial out: either a sip uri or phone number must be provided");
    if (e2.sipUri && e2.phoneNumber) throw new Error("Error starting dial out: only one of sip uri or phone number must be provided");
    if (e2.sipUri) {
      if ("string" != typeof e2.sipUri) throw new Error("Error starting dial out: sipUri must be a string");
      if (!e2.sipUri.startsWith("sip:")) throw new Error("Error starting dial out: Invalid SIP URI, must start with 'sip:'");
      if (e2.video && "boolean" != typeof e2.video) throw new Error("Error starting dial out: video must be a boolean value");
      !(function(e3) {
        if (e3 && (n2(e3.audio), e3.video)) {
          if (!Array.isArray(e3.video)) throw new Error("Error starting dial out: video codec must be an array");
          if (e3.video.length <= 0) throw new Error("Error starting dial out: video codec array specified but empty");
          e3.video.forEach((function(e4) {
            if ("string" != typeof e4) throw new Error("Error starting dial out: video codec must be a string");
            if ("H264" !== e4 && "VP8" !== e4) throw new Error("Error starting dial out: video codec must be H264 or VP8");
          }));
        }
      })(e2.codecs);
    }
    if (e2.phoneNumber) {
      if ("string" != typeof e2.phoneNumber) throw new Error("Error starting dial out: phoneNumber must be a string");
      if (!/^\+\d{1,}$/.test(e2.phoneNumber)) throw new Error("Error starting dial out: Invalid phone number, must be valid phone number as per E.164");
      e2.codecs && n2(e2.codecs.audio);
    }
    if (e2.callerId) {
      if ("string" != typeof e2.callerId) throw new Error("Error starting dial out: callerId must be a string");
      if (e2.sipUri) throw new Error("Error starting dial out: callerId not allowed with sipUri");
    }
    if (e2.displayName) {
      if ("string" != typeof e2.displayName) throw new Error("Error starting dial out: displayName must be a string");
      if (e2.displayName.length >= 200) throw new Error("Error starting dial out: displayName length must be less than 200");
    }
    if (e2.userId) {
      if ("string" != typeof e2.userId) throw new Error("Error starting dial out: userId must be a string");
      if (e2.userId.length > 36) throw new Error("Error starting dial out: userId length must be less than or equal to 36");
    }
    if (e2.permissions && e2.permissions.canReceive) {
      var r4 = f(Ca.validateJSONObject(e2.permissions.canReceive), 2), i3 = r4[0], o2 = r4[1];
      if (!i3) throw new Error(o2);
    }
    return new Promise((function(n3, r5) {
      t2.sendMessageToCallMachine(Aa({ action: "dialout-start" }, e2), (function(e3) {
        e3.error ? r5(e3.error) : n3(e3);
      }));
    }));
  })), function(e2) {
    return O2.apply(this, arguments);
  }) }, { key: "stopDialOut", value: function(e2) {
    var t2 = this;
    return Qa(this._callState, "stopDialOut()"), new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine(Aa({ action: "dialout-stop" }, e2), (function(e3) {
        e3.error ? r4(e3.error) : n2(e3);
      }));
    }));
  } }, { key: "sipCallTransfer", value: (T2 = p((function* (e2) {
    var t2 = this;
    if (Qa(this._callState, "sipCallTransfer()"), !e2) throw new Error("sipCallTransfer() requires a sessionId and toEndPoint");
    return e2.useSipRefer = false, mc(e2, "sipCallTransfer"), new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine(Aa({ action: ns }, e2), (function(e3) {
        e3.error ? r4(e3.error) : n2(e3);
      }));
    }));
  })), function(e2) {
    return T2.apply(this, arguments);
  }) }, { key: "sipRefer", value: (E2 = p((function* (e2) {
    var t2 = this;
    if (Qa(this._callState, "sipRefer()"), !e2) throw new Error("sessionId and toEndPoint are mandatory parameter");
    return e2.useSipRefer = true, mc(e2, "sipRefer"), new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine(Aa({ action: ns }, e2), (function(e3) {
        e3.error ? r4(e3.error) : n2(e3);
      }));
    }));
  })), function(e2) {
    return E2.apply(this, arguments);
  }) }, { key: "sendDTMF", value: (C2 = p((function* (e2) {
    var t2 = this;
    return Qa(this._callState, "sendDTMF()"), (function(e3) {
      var t3 = e3.sessionId, n2 = e3.tones;
      if (!t3 || !n2) throw new Error("sessionId and tones are mandatory parameter");
      if ("string" != typeof t3 || "string" != typeof n2) throw new Error("sessionId and tones should be of string type");
      if (n2.length > 20) throw new Error("tones string must be upto 20 characters");
      var r4 = /[^0-9A-D*#]/g, i3 = n2.match(r4);
      if (i3 && i3[0]) throw new Error("".concat(i3[0], " is not valid DTMF tone"));
    })(e2), new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine(Aa({ action: "send-dtmf" }, e2), (function(e3) {
        e3.error ? r4(e3.error) : n2(e3);
      }));
    }));
  })), function(e2) {
    return C2.apply(this, arguments);
  }) }, { key: "getNetworkStats", value: function() {
    var e2 = this;
    if (this._callState !== oi) {
      return Promise.resolve(Aa({ stats: { latest: {} } }, this._network));
    }
    return new Promise((function(t2) {
      e2.sendMessageToCallMachine({ action: "get-calc-stats" }, (function(n2) {
        t2(Aa(Aa({}, e2._network), {}, { stats: n2.stats }));
      }));
    }));
  } }, { key: "testWebsocketConnectivity", value: (M2 = p((function* () {
    var e2 = this;
    if (Za(this._testCallInProgress, "testWebsocketConnectivity()"), this.needsLoad()) try {
      yield this.load();
    } catch (e3) {
      return Promise.reject(e3);
    }
    return new Promise((function(t2, n2) {
      e2.sendMessageToCallMachine({ action: "test-websocket-connectivity" }, (function(e3) {
        e3.error ? n2(e3.error) : t2(e3.results);
      }));
    }));
  })), function() {
    return M2.apply(this, arguments);
  }) }, { key: "abortTestWebsocketConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-websocket-connectivity" });
  } }, { key: "_validateVideoTrackForNetworkTests", value: function(e2) {
    return e2 ? e2 instanceof MediaStreamTrack ? !!va(e2, { isLocalScreenVideo: false }) || (console.error("Video track is not playable. This test needs a live video track."), false) : (console.error("Video track needs to be of type `MediaStreamTrack`."), false) : (console.error("Missing video track. You must provide a video track in order to run this test."), false);
  } }, { key: "testCallQuality", value: (k2 = p((function* () {
    var t2 = this;
    nc(), ec(this._callObjectMode, "testCallQuality()"), Xa(this._callMachineInitialized, "testCallQuality()", null, true), Ya(this._callState, this._isPreparingToJoin, "testCallQuality()");
    var n2 = this._testCallAlreadyInProgress, r4 = function(e2) {
      n2 || (t2._testCallInProgress = e2);
    };
    if (r4(true), this.needsLoad()) try {
      var i3 = this._callState;
      yield this.load(), this._callState = i3;
    } catch (e2) {
      return r4(false), Promise.reject(e2);
    }
    return new Promise((function(n3) {
      t2.sendMessageToCallMachine({ action: "test-call-quality", dailyJsVersion: t2.properties.dailyJsVersion }, (function(i4) {
        var o2 = i4.results, s2 = o2.result, a2 = e(o2, Ta);
        if ("failed" === s2) {
          var c3, l2 = Aa({}, a2);
          null !== (c3 = a2.error) && void 0 !== c3 && c3.details ? (a2.error.details = JSON.parse(a2.error.details), l2.error = Aa(Aa({}, l2.error), {}, { details: Aa({}, l2.error.details) }), l2.error.details.duringTest = "testCallQuality") : (l2.error = l2.error ? Aa({}, l2.error) : {}, l2.error.details = { duringTest: "testCallQuality" }), t2._maybeSendToSentry(l2);
        }
        r4(false), n3(Aa({ result: s2 }, a2));
      }));
    }));
  })), function() {
    return k2.apply(this, arguments);
  }) }, { key: "stopTestCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-call-quality" });
  } }, { key: "testConnectionQuality", value: (w2 = p((function* (e2) {
    var t2;
    is() ? (console.warn("testConnectionQuality() is deprecated: use testPeerToPeerCallQuality() instead"), t2 = yield this.testPeerToPeerCallQuality(e2)) : (console.warn("testConnectionQuality() is deprecated: use testCallQuality() instead"), t2 = yield this.testCallQuality());
    var n2 = { result: t2.result, secondsElapsed: t2.secondsElapsed };
    return t2.data && (n2.data = { maxRTT: t2.data.maxRoundTripTime, packetLoss: t2.data.avgRecvPacketLoss }), n2;
  })), function(e2) {
    return w2.apply(this, arguments);
  }) }, { key: "testPeerToPeerCallQuality", value: (_2 = p((function* (e2) {
    var t2 = this;
    if (Za(this._testCallInProgress, "testPeerToPeerCallQuality()"), this.needsLoad()) try {
      yield this.load();
    } catch (e3) {
      return Promise.reject(e3);
    }
    var n2 = e2.videoTrack, r4 = e2.duration;
    if (!this._validateVideoTrackForNetworkTests(n2)) throw new Error("Video track error");
    return this._sharedTracks.videoTrackForConnectionQualityTest = n2, new Promise((function(e3, n3) {
      t2.sendMessageToCallMachine({ action: "test-p2p-call-quality", duration: r4 }, (function(t3) {
        t3.error ? n3(t3.error) : e3(t3.results);
      }));
    }));
  })), function(e2) {
    return _2.apply(this, arguments);
  }) }, { key: "stopTestConnectionQuality", value: function() {
    is() ? (console.warn("stopTestConnectionQuality() is deprecated: use testPeerToPeerCallQuality() and stopTestPeerToPeerCallQuality() instead"), this.stopTestPeerToPeerCallQuality()) : (console.warn("stopTestConnectionQuality() is deprecated: use testCallQuality() and stopTestCallQuality() instead"), this.stopTestCallQuality());
  } }, { key: "stopTestPeerToPeerCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-p2p-call-quality" });
  } }, { key: "testNetworkConnectivity", value: (y2 = p((function* (e2) {
    var t2 = this;
    if (Za(this._testCallInProgress, "testNetworkConnectivity()"), this.needsLoad()) try {
      yield this.load();
    } catch (e3) {
      return Promise.reject(e3);
    }
    if (!this._validateVideoTrackForNetworkTests(e2)) throw new Error("Video track error");
    return this._sharedTracks.videoTrackForNetworkConnectivityTest = e2, new Promise((function(e3, n2) {
      t2.sendMessageToCallMachine({ action: "test-network-connectivity" }, (function(t3) {
        t3.error ? n2(t3.error) : e3(t3.results);
      }));
    }));
  })), function(e2) {
    return y2.apply(this, arguments);
  }) }, { key: "abortTestNetworkConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-network-connectivity" });
  } }, { key: "getCpuLoadStats", value: function() {
    var e2 = this;
    return new Promise((function(t2) {
      if (e2._callState === oi) {
        e2.sendMessageToCallMachine({ action: "get-cpu-load-stats" }, (function(e3) {
          t2(e3.cpuStats);
        }));
      } else t2({ cpuLoadState: void 0, cpuLoadStateReason: void 0, stats: {} });
    }));
  } }, { key: "_validateEncodingLayerHasValidProperties", value: function(e2) {
    var t2;
    if (!((null === (t2 = Object.keys(e2)) || void 0 === t2 ? void 0 : t2.length) > 0)) throw new Error("Empty encoding is not allowed. At least one of these valid keys should be specified:" + Object.values(Ua));
  } }, { key: "_validateVideoSendSettings", value: function(e2, t2) {
    var r4 = "screenVideo" === e2 ? ["default-screen-video", "detail-optimized", "motion-optimized", "motion-and-detail-balanced"] : ["default-video", "bandwidth-optimized", "bandwidth-and-quality-balanced", "quality-optimized", "adaptive-2-layers", "adaptive-3-layers"], i3 = "Video send settings should be either an object or one of the supported presets: ".concat(r4.join());
    if ("string" == typeof t2) {
      if (!r4.includes(t2)) throw new Error(i3);
    } else {
      if ("object" !== n(t2)) throw new Error(i3);
      if (!t2.maxQuality && !t2.encodings && void 0 === t2.allowAdaptiveLayers) throw new Error("Video send settings must contain at least maxQuality, allowAdaptiveLayers or encodings attribute");
      if (t2.maxQuality && -1 === ["low", "medium", "high"].indexOf(t2.maxQuality)) throw new Error("maxQuality must be either low, medium or high");
      if (t2.encodings) {
        var o2 = false;
        switch (Object.keys(t2.encodings).length) {
          case 1:
            o2 = !t2.encodings.low;
            break;
          case 2:
            o2 = !t2.encodings.low || !t2.encodings.medium;
            break;
          case 3:
            o2 = !t2.encodings.low || !t2.encodings.medium || !t2.encodings.high;
            break;
          default:
            o2 = true;
        }
        if (o2) throw new Error("Encodings must be defined as: low, low and medium, or low, medium and high.");
        t2.encodings.low && this._validateEncodingLayerHasValidProperties(t2.encodings.low), t2.encodings.medium && this._validateEncodingLayerHasValidProperties(t2.encodings.medium), t2.encodings.high && this._validateEncodingLayerHasValidProperties(t2.encodings.high);
      }
    }
  } }, { key: "validateUpdateSendSettings", value: function(e2) {
    var t2 = this;
    if (!e2 || 0 === Object.keys(e2).length) throw new Error("Send settings must contain at least information for one track!");
    Object.entries(e2).forEach((function(e3) {
      var n2 = f(e3, 2), r4 = n2[0], i3 = n2[1];
      t2._validateVideoSendSettings(r4, i3);
    }));
  } }, { key: "updateSendSettings", value: function(e2) {
    var t2 = this;
    return this.validateUpdateSendSettings(e2), this.needsLoad() ? (this._preloadCache.sendSettings = e2, { sendSettings: this._preloadCache.sendSettings }) : new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine({ action: "update-send-settings", sendSettings: e2 }, (function(e3) {
        e3.error ? r4(e3.error) : n2(e3.sendSettings);
      }));
    }));
  } }, { key: "getSendSettings", value: function() {
    return this._sendSettings || this._preloadCache.sendSettings;
  } }, { key: "getLocalAudioLevel", value: function() {
    return this._localAudioLevel;
  } }, { key: "getRemoteParticipantsAudioLevel", value: function() {
    return this._remoteParticipantsAudioLevel;
  } }, { key: "getActiveSpeaker", value: function() {
    return nc(), this._activeSpeaker;
  } }, { key: "setActiveSpeakerMode", value: function(e2) {
    return nc(), this.sendMessageToCallMachine({ action: "set-active-speaker-mode", enabled: e2 }), this;
  } }, { key: "activeSpeakerMode", value: function() {
    return nc(), this._activeSpeakerMode;
  } }, { key: "subscribeToTracksAutomatically", value: function() {
    return this._preloadCache.subscribeToTracksAutomatically;
  } }, { key: "setSubscribeToTracksAutomatically", value: function(e2) {
    return Qa(this._callState, "setSubscribeToTracksAutomatically()", "Use the subscribeToTracksAutomatically configuration property."), this._preloadCache.subscribeToTracksAutomatically = e2, this.sendMessageToCallMachine({ action: "daily-method-subscribe-to-tracks-automatically", enabled: e2 }), this;
  } }, { key: "enumerateDevices", value: (m2 = p((function* () {
    var e2 = this;
    if (this._callObjectMode) {
      var t2 = yield navigator.mediaDevices.enumerateDevices();
      return "Firefox" === ms() && ys().major > 115 && ys().major < 123 && (t2 = t2.filter((function(e3) {
        return "audiooutput" !== e3.kind;
      }))), { devices: t2.map((function(e3) {
        var t3 = JSON.parse(JSON.stringify(e3));
        if (!is() && "videoinput" === e3.kind && e3.getCapabilities) {
          var n2, r4 = e3.getCapabilities();
          t3.facing = (null == r4 || null === (n2 = r4.facingMode) || void 0 === n2 ? void 0 : n2.length) >= 1 ? r4.facingMode[0] : void 0;
        }
        return t3;
      })) };
    }
    return new Promise((function(t3) {
      e2.sendMessageToCallMachine({ action: "enumerate-devices" }, (function(e3) {
        t3({ devices: e3.devices });
      }));
    }));
  })), function() {
    return m2.apply(this, arguments);
  }) }, { key: "sendAppMessage", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "*";
    if (Qa(this._callState, "sendAppMessage()"), JSON.stringify(e2).length > this._maxAppMessageSize) throw new Error("Message data too large. Max size is " + this._maxAppMessageSize);
    return this.sendMessageToCallMachine({ action: "app-msg", data: e2, to: t2 }), this;
  } }, { key: "addFakeParticipant", value: function(e2) {
    return nc(), Qa(this._callState, "addFakeParticipant()"), this.sendMessageToCallMachine(Aa({ action: "add-fake-participant" }, e2)), this;
  } }, { key: "setShowNamesMode", value: function(e2) {
    return tc(this._callObjectMode, "setShowNamesMode()"), nc(), e2 && "always" !== e2 && "never" !== e2 ? (console.error('setShowNamesMode argument should be "always", "never", or false'), this) : (this.sendMessageToCallMachine({ action: "set-show-names", mode: e2 }), this);
  } }, { key: "setShowLocalVideo", value: function() {
    var e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return tc(this._callObjectMode, "setShowLocalVideo()"), nc(), Qa(this._callState, "setShowLocalVideo()"), "boolean" != typeof e2 ? (console.error("setShowLocalVideo only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-local-video", show: e2 }), this._showLocalVideo = e2, this);
  } }, { key: "showLocalVideo", value: function() {
    return tc(this._callObjectMode, "showLocalVideo()"), nc(), this._showLocalVideo;
  } }, { key: "setShowParticipantsBar", value: function() {
    var e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return tc(this._callObjectMode, "setShowParticipantsBar()"), nc(), Qa(this._callState, "setShowParticipantsBar()"), "boolean" != typeof e2 ? (console.error("setShowParticipantsBar only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-participants-bar", show: e2 }), this._showParticipantsBar = e2, this);
  } }, { key: "showParticipantsBar", value: function() {
    return tc(this._callObjectMode, "showParticipantsBar()"), nc(), this._showParticipantsBar;
  } }, { key: "customIntegrations", value: function() {
    return nc(), tc(this._callObjectMode, "customIntegrations()"), this._customIntegrations;
  } }, { key: "setCustomIntegrations", value: function(e2) {
    return nc(), tc(this._callObjectMode, "setCustomIntegrations()"), Qa(this._callState, "setCustomIntegrations()"), vc(e2) ? (this.sendMessageToCallMachine({ action: "set-custom-integrations", integrations: e2 }), this._customIntegrations = e2, this) : this;
  } }, { key: "startCustomIntegrations", value: function(e2) {
    var t2 = this;
    if (nc(), tc(this._callObjectMode, "startCustomIntegrations()"), Qa(this._callState, "startCustomIntegrations()"), Array.isArray(e2) && e2.some((function(e3) {
      return "string" != typeof e3;
    })) || !Array.isArray(e2) && "string" != typeof e2) return console.error("startCustomIntegrations() only accepts string | string[]"), this;
    var n2 = "string" == typeof e2 ? [e2] : e2, r4 = n2.filter((function(e3) {
      return !(e3 in t2._customIntegrations);
    }));
    return r4.length ? (console.error(`Can't find custom integration(s): "`.concat(r4.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "start-custom-integrations", ids: n2 }), this);
  } }, { key: "stopCustomIntegrations", value: function(e2) {
    var t2 = this;
    if (nc(), tc(this._callObjectMode, "stopCustomIntegrations()"), Qa(this._callState, "stopCustomIntegrations()"), Array.isArray(e2) && e2.some((function(e3) {
      return "string" != typeof e3;
    })) || !Array.isArray(e2) && "string" != typeof e2) return console.error("stopCustomIntegrations() only accepts string | string[]"), this;
    var n2 = "string" == typeof e2 ? [e2] : e2, r4 = n2.filter((function(e3) {
      return !(e3 in t2._customIntegrations);
    }));
    return r4.length ? (console.error(`Can't find custom integration(s): "`.concat(r4.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "stop-custom-integrations", ids: n2 }), this);
  } }, { key: "customTrayButtons", value: function() {
    return tc(this._callObjectMode, "customTrayButtons()"), nc(), this._customTrayButtons;
  } }, { key: "updateCustomTrayButtons", value: function(e2) {
    return tc(this._callObjectMode, "updateCustomTrayButtons()"), nc(), Qa(this._callState, "updateCustomTrayButtons()"), fc(e2) ? (this.sendMessageToCallMachine({ action: "update-custom-tray-buttons", btns: e2 }), this._customTrayButtons = e2, this) : (console.error("updateCustomTrayButtons only accepts a dictionary of the type ".concat(JSON.stringify($a))), this);
  } }, { key: "theme", value: function() {
    return tc(this._callObjectMode, "theme()"), this.properties.theme;
  } }, { key: "setTheme", value: function(e2) {
    var t2 = this;
    return tc(this._callObjectMode, "setTheme()"), new Promise((function(n2, r4) {
      try {
        t2.validateProperties({ theme: e2 }), t2.properties.theme = Aa({}, e2), t2.sendMessageToCallMachine({ action: "set-theme", theme: t2.properties.theme });
        try {
          t2.emitDailyJSEvent({ action: Ui, theme: t2.properties.theme });
        } catch (e3) {
          console.log("could not emit 'theme-updated'", e3);
        }
        n2(t2.properties.theme);
      } catch (e3) {
        r4(e3);
      }
    }));
  } }, { key: "requestFullscreen", value: (g2 = p((function* () {
    if (nc(), this._iframe && !document.fullscreenElement && as()) try {
      (yield this._iframe.requestFullscreen) ? this._iframe.requestFullscreen() : this._iframe.webkitRequestFullscreen();
    } catch (e2) {
      console.log("could not make video call fullscreen", e2);
    }
  })), function() {
    return g2.apply(this, arguments);
  }) }, { key: "exitFullscreen", value: function() {
    nc(), document.fullscreenElement ? document.exitFullscreen() : document.webkitFullscreenElement && document.webkitExitFullscreen();
  } }, { key: "getSidebarView", value: (v2 = p((function* () {
    var e2 = this;
    return this._callObjectMode ? (console.error("getSidebarView is not available in callObject mode"), Promise.resolve(null)) : new Promise((function(t2) {
      e2.sendMessageToCallMachine({ action: "get-sidebar-view" }, (function(e3) {
        t2(e3.view);
      }));
    }));
  })), function() {
    return v2.apply(this, arguments);
  }) }, { key: "setSidebarView", value: function(e2) {
    return this._callObjectMode ? (console.error("setSidebarView is not available in callObject mode"), this) : (this.sendMessageToCallMachine({ action: "set-sidebar-view", view: e2 }), this);
  } }, { key: "room", value: (h3 = p((function* () {
    var e2 = this, t2 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).includeRoomConfigDefaults, n2 = void 0 === t2 || t2;
    return this._accessState.access === fi || this.needsLoad() ? this.properties.url ? { roomUrlPendingJoin: this.properties.url } : null : new Promise((function(t3) {
      e2.sendMessageToCallMachine({ action: "lib-room-info", includeRoomConfigDefaults: n2 }, (function(e3) {
        delete e3.action, delete e3.callbackStamp, t3(e3);
      }));
    }));
  })), function() {
    return h3.apply(this, arguments);
  }) }, { key: "geo", value: (d2 = p((function* () {
    try {
      var e2 = yield fetch("https://gs.daily.co/_ks_/x-swsl/:");
      return { current: (yield e2.json()).geo };
    } catch (e3) {
      return console.error("geo lookup failed", e3), { current: "" };
    }
  })), function() {
    return d2.apply(this, arguments);
  }) }, { key: "setNetworkTopology", value: (c2 = p((function* (e2) {
    var t2 = this;
    return nc(), Qa(this._callState, "setNetworkTopology()"), new Promise((function(n2, r4) {
      t2.sendMessageToCallMachine({ action: "set-network-topology", opts: e2 }, (function(e3) {
        e3.error ? r4({ error: e3.error }) : n2({ workerId: e3.workerId });
      }));
    }));
  })), function(e2) {
    return c2.apply(this, arguments);
  }) }, { key: "getNetworkTopology", value: (i2 = p((function* () {
    var e2 = this;
    return new Promise((function(t2, n2) {
      e2.needsLoad() && t2({ topology: "none" }), e2.sendMessageToCallMachine({ action: "get-network-topology" }, (function(e3) {
        e3.error ? n2({ error: e3.error }) : t2({ topology: e3.topology });
      }));
    }));
  })), function() {
    return i2.apply(this, arguments);
  }) }, { key: "setPlayNewParticipantSound", value: function(e2) {
    if (nc(), "number" != typeof e2 && true !== e2 && false !== e2) throw new Error("argument to setShouldPlayNewParticipantSound should be true, false, or a number, but is ".concat(e2));
    this.sendMessageToCallMachine({ action: "daily-method-set-play-ding", arg: e2 });
  } }, { key: "on", value: function(e2, t2) {
    return b.prototype.on.call(this, e2, t2);
  } }, { key: "once", value: function(e2, t2) {
    return b.prototype.once.call(this, e2, t2);
  } }, { key: "off", value: function(e2, t2) {
    return b.prototype.off.call(this, e2, t2);
  } }, { key: "validateProperties", value: function(e2) {
    var t2, n2;
    if (null != e2 && null !== (t2 = e2.dailyConfig) && void 0 !== t2 && t2.userMediaAudioConstraints) {
      var r4, i3;
      is() || console.warn("userMediaAudioConstraints is deprecated. You can override constraints with inputSettings.audio.settings, found in DailyCallOptions.");
      var o2 = e2.inputSettings || {};
      o2.audio = (null === (r4 = e2.inputSettings) || void 0 === r4 ? void 0 : r4.audio) || {}, o2.audio.settings = (null === (i3 = e2.inputSettings) || void 0 === i3 || null === (i3 = i3.audio) || void 0 === i3 ? void 0 : i3.settings) || {}, o2.audio.settings = Aa(Aa({}, o2.audio.settings), e2.dailyConfig.userMediaAudioConstraints), e2.inputSettings = o2, delete e2.dailyConfig.userMediaAudioConstraints;
    }
    if (null != e2 && null !== (n2 = e2.dailyConfig) && void 0 !== n2 && n2.userMediaVideoConstraints) {
      var s2, a2;
      is() || console.warn("userMediaVideoConstraints is deprecated. You can override constraints with inputSettings.video.settings, found in DailyCallOptions.");
      var c3 = e2.inputSettings || {};
      c3.video = (null === (s2 = e2.inputSettings) || void 0 === s2 ? void 0 : s2.video) || {}, c3.video.settings = (null === (a2 = e2.inputSettings) || void 0 === a2 || null === (a2 = a2.video) || void 0 === a2 ? void 0 : a2.settings) || {}, c3.video.settings = Aa(Aa({}, c3.video.settings), e2.dailyConfig.userMediaVideoConstraints), e2.inputSettings = c3, delete e2.dailyConfig.userMediaVideoConstraints;
    }
    for (var l2 in e2) {
      if (!za[l2]) throw new Error("unrecognized property '".concat(l2, "'"));
      if (za[l2].validate && !za[l2].validate(e2[l2], this)) throw new Error("property '".concat(l2, "': ").concat(za[l2].help));
    }
  } }, { key: "assembleMeetingUrl", value: function() {
    var e2, t2, n2 = Aa(Aa({}, this.properties), {}, { emb: this.callClientId, embHref: encodeURIComponent(window.location.href), proxy: null !== (e2 = this.properties.dailyConfig) && void 0 !== e2 && e2.proxyUrl ? encodeURIComponent(null === (t2 = this.properties.dailyConfig) || void 0 === t2 ? void 0 : t2.proxyUrl) : void 0 }), r4 = n2.url.match(/\?/) ? "&" : "?";
    return n2.url + r4 + Object.keys(za).filter((function(e3) {
      return za[e3].queryString && void 0 !== n2[e3];
    })).map((function(e3) {
      return "".concat(za[e3].queryString, "=").concat(n2[e3]);
    })).join("&");
  } }, { key: "needsLoad", value: function() {
    return [ti, ni, si, ai].includes(this._callState);
  } }, { key: "sendMessageToCallMachine", value: function(e2, t2) {
    if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode)) throw new Error("Use after destroy");
    this._messageChannel.sendMessageToCallMachine(e2, t2, this.callClientId, this._iframe);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e2) {
    this._messageChannel.forwardPackagedMessageToCallMachine(e2, this._iframe, this.callClientId);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e2) {
    return this._messageChannel.addListenerForPackagedMessagesFromCallMachine(e2, this.callClientId);
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e2) {
    this._messageChannel.removeListenerForPackagedMessagesFromCallMachine(e2);
  } }, { key: "handleMessageFromCallMachine", value: function(t2) {
    switch (t2.action) {
      case Fi:
        this.sendMessageToCallMachine(Aa({ action: Bi }, this.properties));
        break;
      case "call-machine-initialized":
        this._callMachineInitialized = true;
        var n2 = { action: Go, level: "log", code: 1011, stats: { event: "bundle load", time: "no-op" === this._bundleLoadTime ? 0 : this._bundleLoadTime, preLoaded: "no-op" === this._bundleLoadTime, url: B(this.properties.dailyConfig) } };
        this.sendMessageToCallMachine(n2), this._delayDuplicateInstanceLog && this._logDuplicateInstanceAttempt();
        break;
      case $i:
        this._loadedCallback && (this._loadedCallback(), this._loadedCallback = null), this.emitDailyJSEvent(t2);
        break;
      case Hi:
        var r4, i3 = Aa({}, t2);
        delete i3.internal, this._maxAppMessageSize = (null === (r4 = t2.internal) || void 0 === r4 ? void 0 : r4._maxAppMessageSize) || $o, this._joinedCallback && (this._joinedCallback(t2.participants), this._joinedCallback = null), this.emitDailyJSEvent(i3);
        break;
      case Qi:
      case Ki:
        if (this._callState === si) return;
        if (t2.participant && t2.participant.session_id) {
          var o2 = t2.participant.local ? "local" : t2.participant.session_id;
          if (this._callObjectMode) {
            var s2 = this._callMachine().store;
            Zs(t2.participant, s2), ea(t2.participant, s2), na(t2.participant, this._participants[o2], s2);
          }
          try {
            this.maybeParticipantTracksStopped(this._participants[o2], t2.participant), this.maybeParticipantTracksStarted(this._participants[o2], t2.participant), this.maybeEventRecordingStopped(this._participants[o2], t2.participant), this.maybeEventRecordingStarted(this._participants[o2], t2.participant);
          } catch (e2) {
            console.error("track events error", e2);
          }
          this.compareEqualForParticipantUpdateEvent(t2.participant, this._participants[o2]) || (this._participants[o2] = Aa({}, t2.participant), this.toggleParticipantAudioBasedOnNativeAudioFocus(), this.emitDailyJSEvent(t2));
        }
        break;
      case Yi:
        if (t2.participant && t2.participant.session_id) {
          var a2 = this._participants[t2.participant.session_id];
          a2 && this.maybeParticipantTracksStopped(a2, null), delete this._participants[t2.participant.session_id], this.emitDailyJSEvent(t2);
        }
        break;
      case Xi:
        S(this._participantCounts, t2.participantCounts) || (this._participantCounts = t2.participantCounts, this.emitDailyJSEvent(t2));
        break;
      case Zi:
        var c3 = { access: t2.access };
        t2.awaitingAccess && (c3.awaitingAccess = t2.awaitingAccess), S(this._accessState, c3) || (this._accessState = c3, this.emitDailyJSEvent(t2));
        break;
      case eo:
        if (t2.meetingSession) {
          this._meetingSessionSummary = t2.meetingSession, this.emitDailyJSEvent(t2);
          var l2 = Aa(Aa({}, t2), {}, { action: "meeting-session-updated" });
          this.emitDailyJSEvent(l2);
        }
        break;
      case Jo:
        var u2;
        this._iframe && !t2.preserveIframe && (this._iframe.src = ""), this._updateCallState(ai), this.resetMeetingDependentVars(), this._loadedCallback && (this._loadedCallback(t2.errorMsg), this._loadedCallback = null), t2.preserveIframe;
        var d3 = e(t2, Oa);
        null != d3 && null !== (u2 = d3.error) && void 0 !== u2 && u2.details && (d3.error.details = JSON.parse(d3.error.details)), this._maybeSendToSentry(t2), this._joinedCallback && (this._joinedCallback(null, d3), this._joinedCallback = null), this.emitDailyJSEvent(d3);
        break;
      case Gi:
        this._callState !== ai && this._updateCallState(si), this.resetMeetingDependentVars(), this._resolveLeave && (this._resolveLeave(), this._resolveLeave = null), this.emitDailyJSEvent(t2);
        break;
      case "selected-devices-updated":
        t2.devices && this.emitDailyJSEvent(t2);
        break;
      case Oo:
        var p2 = t2.state, h4 = t2.threshold, f2 = t2.quality, v3 = p2.state, g3 = p2.reasons;
        v3 === this._network.networkState && S(g3, this._network.networkStateReasons) && h4 === this._network.threshold && f2 === this._network.quality || (this._network.networkState = v3, this._network.networkStateReasons = g3, this._network.quality = f2, this._network.threshold = h4, t2.networkState = v3, g3.length && (t2.networkStateReasons = g3), delete t2.state, this.emitDailyJSEvent(t2));
        break;
      case Ao:
        t2 && t2.cpuLoadState && this.emitDailyJSEvent(t2);
        break;
      case jo:
        t2 && void 0 !== t2.faceCounts && this.emitDailyJSEvent(t2);
        break;
      case Eo:
        var m3 = t2.activeSpeaker;
        this._activeSpeaker.peerId !== m3.peerId && (this._activeSpeaker.peerId = m3.peerId, this.emitDailyJSEvent({ action: t2.action, activeSpeaker: this._activeSpeaker }));
        break;
      case "show-local-video-changed":
        if (this._callObjectMode) return;
        var y3 = t2.show;
        this._showLocalVideo = y3, this.emitDailyJSEvent({ action: t2.action, show: y3 });
        break;
      case To:
        var b2 = t2.enabled;
        this._activeSpeakerMode !== b2 && (this._activeSpeakerMode = b2, this.emitDailyJSEvent({ action: t2.action, enabled: this._activeSpeakerMode }));
        break;
      case ro:
      case io:
      case oo:
        this._waitingParticipants = t2.allWaitingParticipants, this.emitDailyJSEvent({ action: t2.action, participant: t2.participant });
        break;
      case Bo:
        S(this._receiveSettings, t2.receiveSettings) || (this._receiveSettings = t2.receiveSettings, this.emitDailyJSEvent({ action: t2.action, receiveSettings: t2.receiveSettings }));
        break;
      case Uo:
        this._maybeUpdateInputSettings(t2.inputSettings);
        break;
      case "send-settings-updated":
        S(this._sendSettings, t2.sendSettings) || (this._sendSettings = t2.sendSettings, this._preloadCache.sendSettings = null, this.emitDailyJSEvent({ action: t2.action, sendSettings: t2.sendSettings }));
        break;
      case "local-audio-level":
        this._localAudioLevel = t2.audioLevel, this._preloadCache.localAudioLevelObserver = null, this.emitDailyJSEvent(t2);
        break;
      case "remote-participants-audio-level":
        this._remoteParticipantsAudioLevel = t2.participantsAudioLevel, this._preloadCache.remoteParticipantsAudioLevelObserver = null, this.emitDailyJSEvent(t2);
        break;
      case _o:
        var _3 = t2.session_id;
        this._rmpPlayerState[_3] = t2.playerState, this.emitDailyJSEvent(t2);
        break;
      case So:
        delete this._rmpPlayerState[t2.session_id], this.emitDailyJSEvent(t2);
        break;
      case wo:
        var w3 = t2.session_id, k3 = this._rmpPlayerState[w3];
        k3 && this.compareEqualForRMPUpdateEvent(k3, t2.remoteMediaPlayerState) || (this._rmpPlayerState[w3] = t2.remoteMediaPlayerState, this.emitDailyJSEvent(t2));
        break;
      case "custom-button-click":
      case "sidebar-view-changed":
        this.emitDailyJSEvent(t2);
        break;
      case to2:
        var M3 = this._meetingSessionState.topology !== (t2.meetingSessionState && t2.meetingSessionState.topology);
        this._meetingSessionState = _c(t2.meetingSessionState, this._callObjectMode), (this._callObjectMode || M3) && this.emitDailyJSEvent(t2);
        break;
      case ko:
        this._isScreenSharing = true, this.emitDailyJSEvent(t2);
        break;
      case Mo:
      case Co:
        this._isScreenSharing = false, this.emitDailyJSEvent(t2);
        break;
      case po:
      case ho:
      case fo:
      case vo:
      case go:
      case co:
      case lo:
      case uo:
      case qi:
      case zi:
      case yo:
      case bo:
      case "test-completed":
      case Po:
      case mo:
      case Lo:
      case Do:
      case No:
      case Ro:
      case Vo:
      case Fo:
      case "dialin-ready":
      case "dialin-connected":
      case "dialin-error":
      case "dialin-stopped":
      case "dialin-warning":
      case "dialout-connected":
      case "dialout-answered":
      case "dialout-error":
      case "dialout-stopped":
      case "dialout-warning":
        this.emitDailyJSEvent(t2);
        break;
      case "request-fullscreen":
        this.requestFullscreen();
        break;
      case "request-exit-fullscreen":
        this.exitFullscreen();
    }
  } }, { key: "maybeEventRecordingStopped", value: function(e2, t2) {
    var n2 = "record";
    e2 && (t2.local || false !== t2[n2] || e2[n2] === t2[n2] || this.emitDailyJSEvent({ action: ho }));
  } }, { key: "maybeEventRecordingStarted", value: function(e2, t2) {
    var n2 = "record";
    e2 && (t2.local || true !== t2[n2] || e2[n2] === t2[n2] || this.emitDailyJSEvent({ action: po }));
  } }, { key: "_trackStatePlayable", value: function(e2) {
    return !(!e2 || e2.state !== hi);
  } }, { key: "_trackChanged", value: function(e2, t2) {
    return !((null == e2 ? void 0 : e2.id) === (null == t2 ? void 0 : t2.id));
  } }, { key: "maybeEventTrackStopped", value: function(e2, t2, n2) {
    var r4, i3, o2 = null !== (r4 = null == t2 ? void 0 : t2.tracks[e2]) && void 0 !== r4 ? r4 : null, s2 = null !== (i3 = null == n2 ? void 0 : n2.tracks[e2]) && void 0 !== i3 ? i3 : null, a2 = null == o2 ? void 0 : o2.track;
    if (a2) {
      var c3 = this._trackStatePlayable(o2), l2 = this._trackStatePlayable(s2), u2 = this._trackChanged(a2, null == s2 ? void 0 : s2.track);
      c3 && (l2 && !u2 || this.emitDailyJSEvent({ action: ao, track: a2, participant: null != n2 ? n2 : t2, type: e2 }));
    }
  } }, { key: "maybeEventTrackStarted", value: function(e2, t2, n2) {
    var r4, i3, o2 = null !== (r4 = null == t2 ? void 0 : t2.tracks[e2]) && void 0 !== r4 ? r4 : null, s2 = null !== (i3 = null == n2 ? void 0 : n2.tracks[e2]) && void 0 !== i3 ? i3 : null, a2 = null == s2 ? void 0 : s2.track;
    if (a2) {
      var c3 = this._trackStatePlayable(o2), l2 = this._trackStatePlayable(s2), u2 = this._trackChanged(null == o2 ? void 0 : o2.track, a2);
      l2 && (c3 && !u2 || this.emitDailyJSEvent({ action: so, track: a2, participant: n2, type: e2 }));
    }
  } }, { key: "maybeParticipantTracksStopped", value: function(e2, t2) {
    if (e2) for (var n2 in e2.tracks) this.maybeEventTrackStopped(n2, e2, t2);
  } }, { key: "maybeParticipantTracksStarted", value: function(e2, t2) {
    if (t2) for (var n2 in t2.tracks) this.maybeEventTrackStarted(n2, e2, t2);
  } }, { key: "compareEqualForRMPUpdateEvent", value: function(e2, t2) {
    var n2, r4;
    return e2.state === t2.state && (null === (n2 = e2.settings) || void 0 === n2 ? void 0 : n2.volume) === (null === (r4 = t2.settings) || void 0 === r4 ? void 0 : r4.volume);
  } }, { key: "emitDailyJSEvent", value: function(e2) {
    try {
      e2.callClientId = this.callClientId, this.emit(e2.action, e2);
    } catch (t2) {
      console.log("could not emit", e2, t2);
    }
  } }, { key: "compareEqualForParticipantUpdateEvent", value: function(e2, t2) {
    return !!S(e2, t2) && ((!e2.videoTrack || !t2.videoTrack || e2.videoTrack.id === t2.videoTrack.id && e2.videoTrack.muted === t2.videoTrack.muted && e2.videoTrack.enabled === t2.videoTrack.enabled) && (!e2.audioTrack || !t2.audioTrack || e2.audioTrack.id === t2.audioTrack.id && e2.audioTrack.muted === t2.audioTrack.muted && e2.audioTrack.enabled === t2.audioTrack.enabled));
  } }, { key: "nativeUtils", value: function() {
    return is() ? "undefined" == typeof DailyNativeUtils ? (console.warn("in React Native, DailyNativeUtils is expected to be available"), null) : DailyNativeUtils : null;
  } }, { key: "updateIsPreparingToJoin", value: function(e2) {
    this._updateCallState(this._callState, e2);
  } }, { key: "_updateCallState", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._isPreparingToJoin;
    if (e2 !== this._callState || t2 !== this._isPreparingToJoin) {
      var n2 = this._callState, r4 = this._isPreparingToJoin;
      this._callState = e2, this._isPreparingToJoin = t2;
      var i3 = this._callState === oi;
      this.updateShowAndroidOngoingMeetingNotification(i3);
      var o2 = Ka(n2, r4), s2 = Ka(this._callState, this._isPreparingToJoin);
      o2 !== s2 && (this.updateKeepDeviceAwake(s2), this.updateDeviceAudioMode(s2), this.updateNoOpRecordingEnsuringBackgroundContinuity(s2));
    }
  } }, { key: "resetMeetingDependentVars", value: function() {
    this._participants = {}, this._participantCounts = Fa, this._waitingParticipants = {}, this._activeSpeaker = {}, this._activeSpeakerMode = false, this._didPreAuth = false, this._accessState = { access: fi }, this._finalSummaryOfPrevSession = this._meetingSessionSummary, this._meetingSessionSummary = {}, this._meetingSessionState = _c(Ra, this._callObjectMode), this._isScreenSharing = false, this._receiveSettings = {}, this._inputSettings = void 0, this._sendSettings = {}, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this._maxAppMessageSize = $o, this._callMachineInitialized = false, this._bundleLoadTime = void 0, this._preloadCache;
  } }, { key: "updateKeepDeviceAwake", value: function(e2) {
    is() && this.nativeUtils().setKeepDeviceAwake(e2, this.callClientId);
  } }, { key: "updateDeviceAudioMode", value: function(e2) {
    if (is() && !this.disableReactNativeAutoDeviceManagement("audio")) {
      var t2 = e2 ? this._nativeInCallAudioMode : "idle";
      this.nativeUtils().setAudioMode(t2);
    }
  } }, { key: "updateShowAndroidOngoingMeetingNotification", value: function(e2) {
    if (is() && this.nativeUtils().setShowOngoingMeetingNotification) {
      var t2, n2, r4, i3;
      if (this.properties.reactNativeConfig && this.properties.reactNativeConfig.androidInCallNotification) {
        var o2 = this.properties.reactNativeConfig.androidInCallNotification;
        t2 = o2.title, n2 = o2.subtitle, r4 = o2.iconName, i3 = o2.disableForCustomOverride;
      }
      i3 && (e2 = false), this.nativeUtils().setShowOngoingMeetingNotification(e2, t2, n2, r4, this.callClientId);
    }
  } }, { key: "updateNoOpRecordingEnsuringBackgroundContinuity", value: function(e2) {
    is() && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity(e2);
  } }, { key: "toggleParticipantAudioBasedOnNativeAudioFocus", value: function() {
    var e2;
    if (is()) {
      var t2 = null === (e2 = this._callMachine()) || void 0 === e2 || null === (e2 = e2.store) || void 0 === e2 ? void 0 : e2.getState();
      for (var n2 in null == t2 ? void 0 : t2.streams) {
        var r4 = t2.streams[n2];
        r4 && r4.pendingTrack && "audio" === r4.pendingTrack.kind && (r4.pendingTrack.enabled = this._hasNativeAudioFocus);
      }
    }
  } }, { key: "disableReactNativeAutoDeviceManagement", value: function(e2) {
    return this.properties.reactNativeConfig && this.properties.reactNativeConfig.disableAutoDeviceManagement && this.properties.reactNativeConfig.disableAutoDeviceManagement[e2];
  } }, { key: "absoluteUrl", value: function(e2) {
    if (void 0 !== e2) {
      var t2 = document.createElement("a");
      return t2.href = e2, t2.href;
    }
  } }, { key: "sayHello", value: function() {
    var e2 = "hello, world.";
    return console.log(e2), e2;
  } }, { key: "_logUseAfterDestroy", value: function() {
    var e2 = Object.values(La)[0];
    if (this.needsLoad()) {
      if (e2 && !e2.needsLoad()) {
        var t2 = { action: Go, level: "error", code: this.strictMode ? 9995 : 9997 };
        e2.sendMessageToCallMachine(t2);
      } else if (!this.strictMode) {
        console.error("You are are attempting to use a call instance that was previously destroyed, which is unsupported. Please remove `strictMode: false` from your constructor properties to enable strict mode to track down and fix this unsupported usage.");
      }
    } else {
      var n2 = { action: Go, level: "error", code: this.strictMode ? 9995 : 9997 };
      this._messageChannel.sendMessageToCallMachine(n2, null, this.callClientId, this._iframe);
    }
  } }, { key: "_logDuplicateInstanceAttempt", value: function() {
    for (var e2 = 0, t2 = Object.values(La); e2 < t2.length; e2++) {
      var n2 = t2[e2];
      n2._callMachineInitialized ? (n2.sendMessageToCallMachine({ action: Go, level: "warn", code: this.allowMultipleCallInstances ? 9993 : 9992 }), n2._delayDuplicateInstanceLog = false) : n2._delayDuplicateInstanceLog = true;
    }
  } }, { key: "_maybeSendToSentry", value: function(e2) {
    var t2, n2, i3, o2;
    if (null !== (t2 = e2.error) && void 0 !== t2 && t2.type) {
      if (![Pi, Ti, Ci].includes(e2.error.type)) return;
      if (e2.error.type === Ci && e2.error.msg.includes("deleted")) return;
    }
    var s2 = null !== (n2 = this.properties) && void 0 !== n2 && n2.url ? new URL(this.properties.url) : void 0, a2 = "production";
    s2 && s2.host.includes(".staging.daily") && (a2 = "staging");
    var c3, l2, u2, d3, p2, h4 = (function(e3) {
      const t3 = [Ln(), In(), qr(), Jr(), Kr(), ei(), $n(), Zr()];
      return false !== e3.autoSessionTracking && t3.push(Qr()), t3;
    })({}).filter((function(e3) {
      return !["BrowserApiErrors", "Breadcrumbs", "GlobalHandlers"].includes(e3.name);
    })), f2 = new mr({ dsn: "https://f10f1c81e5d44a4098416c0867a8b740@o77906.ingest.sentry.io/168844", transport: Ir, stackParser: Br, integrations: h4, environment: a2 }), v3 = new ut();
    if (v3.setClient(f2), f2.init(), this.session_id && v3.setExtra("sessionId", this.session_id), this.properties) {
      var g3 = Aa({}, this.properties);
      g3.userName = g3.userName ? "[Filtered]" : void 0, g3.userData = g3.userData ? "[Filtered]" : void 0, g3.token = g3.token ? "[Filtered]" : void 0, v3.setExtra("properties", g3);
    }
    if (s2) {
      var m3 = s2.searchParams.get("domain");
      if (!m3) {
        var y3 = s2.host.match(/(.*?)\./);
        m3 = y3 && y3[1] || "";
      }
      m3 && v3.setTag("domain", m3);
    }
    e2.error && (v3.setTag("fatalErrorType", e2.error.type), v3.setExtra("errorDetails", e2.error.details), (null === (c3 = e2.error.details) || void 0 === c3 ? void 0 : c3.uri) && v3.setTag("serverAddress", e2.error.details.uri), (null === (l2 = e2.error.details) || void 0 === l2 ? void 0 : l2.workerGroup) && v3.setTag("workerGroup", e2.error.details.workerGroup), (null === (u2 = e2.error.details) || void 0 === u2 ? void 0 : u2.geoGroup) && v3.setTag("geoGroup", e2.error.details.geoGroup), (null === (d3 = e2.error.details) || void 0 === d3 ? void 0 : d3.on) && v3.setTag("connectionAttempt", e2.error.details.on), null !== (p2 = e2.error.details) && void 0 !== p2 && p2.bundleUrl && (v3.setTag("bundleUrl", e2.error.details.bundleUrl), v3.setTag("bundleError", e2.error.details.sourceError.type)));
    v3.setTags({ callMode: this._callObjectMode ? is() ? "reactNative" : null !== (i3 = this.properties) && void 0 !== i3 && null !== (i3 = i3.dailyConfig) && void 0 !== i3 && null !== (i3 = i3.callMode) && void 0 !== i3 && i3.includes("prebuilt") ? this.properties.dailyConfig.callMode : "custom" : "prebuilt-frame", version: r3.version() });
    var b2 = (null === (o2 = e2.error) || void 0 === o2 ? void 0 : o2.msg) || e2.errorMsg;
    v3.captureException(new Error(b2));
  } }, { key: "_callMachine", value: function() {
    var e2;
    return null === (e2 = window._daily) || void 0 === e2 || null === (e2 = e2.instances) || void 0 === e2 || null === (e2 = e2[this.callClientId]) || void 0 === e2 ? void 0 : e2.callMachine;
  } }, { key: "_maybeUpdateInputSettings", value: function(e2) {
    if (!S(this._inputSettings, e2)) {
      var t2 = this._getInputSettings();
      this._inputSettings = e2;
      var n2 = this._getInputSettings();
      S(t2, n2) || this.emitDailyJSEvent({ action: Uo, inputSettings: n2 });
    }
  } }], [{ key: "supportedBrowser", value: function() {
    if (is()) return { supported: true, mobile: true, name: "React Native", version: null, supportsScreenShare: true, supportsSfu: true, supportsVideoProcessing: false, supportsAudioProcessing: false };
    var e2 = D.getParser(rs());
    return { supported: !!fs(), mobile: "mobile" === e2.getPlatformType(), name: e2.getBrowserName(), version: e2.getBrowserVersion(), supportsFullscreen: !!as(), supportsScreenShare: !!ss(), supportsSfu: !!fs(), supportsVideoProcessing: ps(), supportsAudioProcessing: hs() };
  } }, { key: "version", value: function() {
    return "0.83.1";
  } }, { key: "createCallObject", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return e2.layout = "none", new r3(null, e2);
  } }, { key: "wrap", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (nc(), !e2 || !e2.contentWindow || "string" != typeof e2.src) throw new Error("DailyIframe::Wrap needs an iframe-like first argument");
    return t2.layout || (t2.customLayout ? t2.layout = "custom-v1" : t2.layout = "browser"), new r3(e2, t2);
  } }, { key: "createFrame", value: function(e2, t2) {
    var n2, i3;
    nc(), e2 && t2 ? (n2 = e2, i3 = t2) : e2 && e2.append ? (n2 = e2, i3 = {}) : (n2 = document.body, i3 = e2 || {});
    var o2 = i3.iframeStyle;
    o2 || (o2 = n2 === document.body ? { position: "fixed", border: "1px solid black", backgroundColor: "white", width: "375px", height: "450px", right: "1em", bottom: "1em" } : { border: 0, width: "100%", height: "100%" });
    var s2 = document.createElement("iframe");
    window.navigator && window.navigator.userAgent.match(/Chrome\/61\./) ? s2.allow = "microphone, camera" : s2.allow = "microphone; camera; autoplay; display-capture; screen-wake-lock", s2.style.visibility = "hidden", n2.appendChild(s2), s2.style.visibility = null, Object.keys(o2).forEach((function(e3) {
      return s2.style[e3] = o2[e3];
    })), i3.layout || (i3.customLayout ? i3.layout = "custom-v1" : i3.layout = "browser");
    try {
      return new r3(s2, i3);
    } catch (e3) {
      throw n2.removeChild(s2), e3;
    }
  } }, { key: "createTransparentFrame", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    nc();
    var t2 = document.createElement("iframe");
    return t2.allow = "microphone; camera; autoplay", t2.style.cssText = "\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      border: 0;\n      pointer-events: none;\n    ", document.body.appendChild(t2), e2.layout || (e2.layout = "custom-v1"), r3.wrap(t2, e2);
  } }, { key: "getCallInstance", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    return e2 ? La[e2] : Object.values(La)[0];
  } }]);
  var i2, c2, d2, h3, v2, g2, m2, y2, _2, w2, k2, M2, C2, E2, T2, O2, P2, A2, j2, I2, x2, L2, R2, U2, V2, J2, $2, q2, z2, W2, H2, G2, Q2, K2, Y2, X3, Z2, ee2;
})();
function Ga(e2, t2) {
  var n2 = {};
  for (var r3 in e2) if (e2[r3] instanceof MediaStreamTrack) console.warn("MediaStreamTrack found in props or cache.", r3), n2[r3] = Qo;
  else if ("dailyConfig" === r3) {
    if (e2[r3].modifyLocalSdpHook) {
      var i2 = window._daily.instances[t2].customCallbacks || {};
      i2.modifyLocalSdpHook = e2[r3].modifyLocalSdpHook, window._daily.instances[t2].customCallbacks = i2, delete e2[r3].modifyLocalSdpHook;
    }
    if (e2[r3].modifyRemoteSdpHook) {
      var o2 = window._daily.instances[t2].customCallbacks || {};
      o2.modifyRemoteSdpHook = e2[r3].modifyRemoteSdpHook, window._daily.instances[t2].customCallbacks = o2, delete e2[r3].modifyRemoteSdpHook;
    }
    n2[r3] = e2[r3];
  } else n2[r3] = e2[r3];
  return n2;
}
function Qa(e2) {
  var t2 = arguments.length > 2 ? arguments[2] : void 0;
  if (e2 !== oi) {
    var n2 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " only supported after join.");
    throw t2 && (n2 += " ".concat(t2)), console.error(n2), new Error(n2);
  }
}
function Ka(e2, t2) {
  return [ii, oi].includes(e2) || t2;
}
function Ya(e2, t2) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "This daily-js method", r3 = arguments.length > 3 ? arguments[3] : void 0;
  if (Ka(e2, t2)) {
    var i2 = "".concat(n2, " not supported after joining a meeting.");
    throw r3 && (i2 += " ".concat(r3)), console.error(i2), new Error(i2);
  }
}
function Xa(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", n2 = arguments.length > 2 ? arguments[2] : void 0;
  if (!e2) {
    var r3 = "".concat(t2, arguments.length > 3 && void 0 !== arguments[3] && arguments[3] ? " requires preAuth() or startCamera() to initialize call state." : " requires preAuth(), startCamera(), or join() to initialize call state.");
    throw n2 && (r3 += " ".concat(n2)), console.error(r3), new Error(r3);
  }
}
function Za(e2) {
  if (e2) {
    var t2 = "A pre-call quality test is in progress. Please try ".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " again once testing has completed. Use stopTestCallQuality() to end it early.");
    throw console.error(t2), new Error(t2);
  }
}
function ec(e2) {
  if (!e2) {
    var t2 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported on custom callObject instances");
    throw console.error(t2), new Error(t2);
  }
}
function tc(e2) {
  if (e2) {
    var t2 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported as part of Daily's Prebuilt");
    throw console.error(t2), new Error(t2);
  }
}
function nc() {
  if (is()) throw new Error("This daily-js method is not currently supported in React Native");
}
function rc() {
  if (!is()) throw new Error("This daily-js method is only supported in React Native");
}
function ic(e2) {
  if (void 0 === e2) return true;
  var t2;
  if ("string" == typeof e2) t2 = e2;
  else try {
    t2 = JSON.stringify(e2), S(JSON.parse(t2), e2) || console.warn("The userData provided will be modified when serialized.");
  } catch (e3) {
    throw Error("userData must be serializable to JSON: ".concat(e3));
  }
  if (t2.length > 4096) throw Error("userData is too large (".concat(t2.length, " characters). Maximum size suppported is ").concat(4096, "."));
  return true;
}
function oc(e2, t2) {
  for (var n2 = t2.allowAllParticipantsKey, r3 = function(e3) {
    var t3 = ["local"];
    return n2 || t3.push("*"), e3 && !t3.includes(e3);
  }, i2 = function(e3) {
    return !!(void 0 === e3.layer || Number.isInteger(e3.layer) && e3.layer >= 0 || "inherit" === e3.layer);
  }, o2 = function(e3) {
    return !!e3 && (!(e3.video && !i2(e3.video)) && !(e3.screenVideo && !i2(e3.screenVideo)));
  }, s2 = 0, a2 = Object.entries(e2); s2 < a2.length; s2++) {
    var c2 = f(a2[s2], 2), l2 = c2[0], u2 = c2[1];
    if (!r3(l2) || !o2(u2)) return false;
  }
  return true;
}
function sc(e2) {
  if ("object" !== n(e2)) return false;
  for (var t2 = 0, r3 = Object.entries(e2); t2 < r3.length; t2++) {
    var i2 = f(r3[t2], 2), o2 = i2[0], s2 = i2[1];
    switch (o2) {
      case "video":
        if ("object" !== n(s2)) return false;
        for (var a2 = 0, c2 = Object.entries(s2); a2 < c2.length; a2++) {
          var l2 = f(c2[a2], 2), u2 = l2[0], d2 = l2[1];
          switch (u2) {
            case "processor":
              if (!lc(d2)) return false;
              break;
            case "settings":
              if (!uc(d2)) return false;
              break;
            default:
              return false;
          }
        }
        break;
      case "audio":
        if ("object" !== n(s2)) return false;
        for (var p2 = 0, h3 = Object.entries(s2); p2 < h3.length; p2++) {
          var v2 = f(h3[p2], 2), g2 = v2[0], m2 = v2[1];
          switch (g2) {
            case "processor":
              if (!cc(m2)) return false;
              break;
            case "settings":
              if (!uc(m2)) return false;
              break;
            default:
              return false;
          }
        }
        break;
      default:
        return false;
    }
  }
  return true;
}
function ac(e2, t2, n2) {
  var r3, i2 = [];
  e2.video && e2.video.processor && (ps(null !== (r3 = null == t2 ? void 0 : t2.useLegacyVideoProcessor) && void 0 !== r3 && r3) || (e2.video.settings ? delete e2.video.processor : delete e2.video, i2.push("video")));
  e2.audio && e2.audio.processor && (hs() || (e2.audio.settings ? delete e2.audio.processor : delete e2.audio, i2.push("audio"))), i2.length > 0 && console.error("Ignoring settings for browser- or platform-unsupported input processor(s): ".concat(i2.join(", "))), e2.audio && e2.audio.settings && (e2.audio.settings.customTrack ? (n2.audioTrack = e2.audio.settings.customTrack, e2.audio.settings = { customTrack: Qo }) : delete n2.audioTrack), e2.video && e2.video.settings && (e2.video.settings.customTrack ? (n2.videoTrack = e2.video.settings.customTrack, e2.video.settings = { customTrack: Qo }) : delete n2.videoTrack);
}
function cc(e2) {
  if (is()) return console.warn("Video processing is not yet supported in React Native"), false;
  var t2 = ["type"];
  return !!e2 && ("object" === n(e2) && (Object.keys(e2).filter((function(e3) {
    return !t2.includes(e3);
  })).forEach((function(t3) {
    console.warn("invalid key inputSettings -> audio -> processor : ".concat(t3)), delete e2[t3];
  })), !!(function(e3) {
    if ("string" != typeof e3) return false;
    if (!Object.values(Yo).includes(e3)) return console.error("inputSettings audio processor type invalid"), false;
    return true;
  })(e2.type)));
}
function lc(e2) {
  if (is()) return console.warn("Video processing is not yet supported in React Native"), false;
  var t2 = ["type", "config"];
  if (!e2) return false;
  if ("object" !== n(e2)) return false;
  if (!(function(e3) {
    if ("string" != typeof e3) return false;
    if (!Object.values(Ko).includes(e3)) return console.error("inputSettings video processor type invalid"), false;
    return true;
  })(e2.type)) return false;
  if (e2.config) {
    if ("object" !== n(e2.config)) return false;
    if (!(function(e3, t3) {
      var n2 = Object.keys(t3);
      if (0 === n2.length) return true;
      var r3 = "invalid object in inputSettings -> video -> processor -> config";
      switch (e3) {
        case Ko.BGBLUR:
          return n2.length > 1 || "strength" !== n2[0] ? (console.error(r3), false) : !("number" != typeof t3.strength || t3.strength <= 0 || t3.strength > 1 || isNaN(t3.strength)) || (console.error("".concat(r3, "; expected: {0 < strength <= 1}, got: ").concat(t3.strength)), false);
        case Ko.BGIMAGE:
          return !(void 0 !== t3.source && !(function(e4) {
            if ("default" === e4.source) return e4.type = "default", true;
            if (e4.source instanceof ArrayBuffer) return true;
            if (U(e4.source)) return e4.type = "url", !!(function(e5) {
              var t5 = new URL(e5), n4 = t5.pathname;
              if ("data:" === t5.protocol) try {
                var r4 = n4.substring(n4.indexOf(":") + 1, n4.indexOf(";")).split("/")[1];
                return Zo.includes(r4);
              } catch (e6) {
                return console.error("failed to deduce blob content type", e6), false;
              }
              var i2 = n4.split(".").at(-1).toLowerCase().trim();
              return Zo.includes(i2);
            })(e4.source) || (console.error("invalid image type; supported types: [".concat(Zo.join(", "), "]")), false);
            return t4 = e4.source, n3 = Number(t4), isNaN(n3) || !Number.isInteger(n3) || n3 <= 0 || n3 > 10 ? (console.error("invalid image selection; must be an int, > 0, <= ".concat(10)), false) : (e4.type = "daily-preselect", true);
            var t4, n3;
          })(t3));
        default:
          return true;
      }
    })(e2.type, e2.config)) return false;
  }
  return Object.keys(e2).filter((function(e3) {
    return !t2.includes(e3);
  })).forEach((function(t3) {
    console.warn("invalid key inputSettings -> video -> processor : ".concat(t3)), delete e2[t3];
  })), true;
}
function uc(e2) {
  return "object" === n(e2) && (!e2.customTrack || e2.customTrack instanceof MediaStreamTrack);
}
function dc() {
  var e2 = Object.values(Ko).join(" | "), t2 = Object.values(Yo).join(" | ");
  return "inputSettings must be of the form: { video?: { processor?: { type: [ ".concat(e2, " ], config?: {} } }, audio?: { processor: {type: [ ").concat(t2, " ] } } }");
}
function pc(e2) {
  var t2 = e2.allowAllParticipantsKey;
  return "receiveSettings must be of the form { [<remote participant id> | ".concat(yi).concat(t2 ? ' | "'.concat("*", '"') : "", "]: ") + '{ [video: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]], [screenVideo: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]] }}}';
}
function hc() {
  return "customIntegrations should be an object of type ".concat(JSON.stringify(qa), ".");
}
function fc(e2) {
  if (e2 && "object" !== n(e2) || Array.isArray(e2)) return console.error("customTrayButtons should be an Object of the type ".concat(JSON.stringify($a), ".")), false;
  if (e2) for (var t2 = 0, r3 = Object.entries(e2); t2 < r3.length; t2++) for (var i2 = f(r3[t2], 1)[0], o2 = 0, s2 = Object.entries(e2[i2]); o2 < s2.length; o2++) {
    var a2 = f(s2[o2], 2), c2 = a2[0], l2 = a2[1], u2 = $a.id[c2];
    if (!u2) return console.error("customTrayButton does not support key ".concat(c2)), false;
    switch (c2) {
      case "iconPath":
      case "iconPathDarkMode":
        if (!U(l2)) return console.error("customTrayButton ".concat(c2, " should be a url.")), false;
        break;
      case "visualState":
        if (!["default", "sidebar-open", "active"].includes(l2)) return console.error("customTrayButton ".concat(c2, " should be ").concat(u2, ". Got: ").concat(l2)), false;
        break;
      default:
        if (n(l2) !== u2) return console.error("customTrayButton ".concat(c2, " should be a ").concat(u2, ".")), false;
    }
  }
  return true;
}
function vc(e2) {
  if (!e2 || e2 && "object" !== n(e2) || Array.isArray(e2)) return console.error(hc()), false;
  for (var t2 = function(e3) {
    return "".concat(e3, " should be ").concat(qa.id[e3]);
  }, r3 = function(e3, t3) {
    return console.error("customIntegration ".concat(e3, ": ").concat(t3));
  }, i2 = 0, o2 = Object.entries(e2); i2 < o2.length; i2++) {
    var s2 = f(o2[i2], 1)[0];
    if (!("label" in e2[s2])) return r3(s2, "label is required"), false;
    if (!("location" in e2[s2])) return r3(s2, "location is required"), false;
    if (!("src" in e2[s2]) && !("srcdoc" in e2[s2])) return r3(s2, "src or srcdoc is required"), false;
    for (var a2 = 0, c2 = Object.entries(e2[s2]); a2 < c2.length; a2++) {
      var l2 = f(c2[a2], 2), u2 = l2[0], d2 = l2[1];
      switch (u2) {
        case "allow":
        case "csp":
        case "name":
        case "referrerPolicy":
        case "sandbox":
          if ("string" != typeof d2) return r3(s2, t2(u2)), false;
          break;
        case "iconURL":
          if (!U(d2)) return r3(s2, "".concat(u2, " should be a url")), false;
          break;
        case "src":
          if ("srcdoc" in e2[s2]) return r3(s2, "cannot have both src and srcdoc"), false;
          if (!U(d2)) return r3(s2, 'src "'.concat(d2, '" is not a valid URL')), false;
          break;
        case "srcdoc":
          if ("src" in e2[s2]) return r3(s2, "cannot have both src and srcdoc"), false;
          if ("string" != typeof d2) return r3(s2, t2(u2)), false;
          break;
        case "location":
          if (!["main", "sidebar"].includes(d2)) return r3(s2, t2(u2)), false;
          break;
        case "controlledBy":
          if ("*" !== d2 && "owners" !== d2 && (!Array.isArray(d2) || d2.some((function(e3) {
            return "string" != typeof e3;
          })))) return r3(s2, t2(u2)), false;
          break;
        case "shared":
          if ((!Array.isArray(d2) || d2.some((function(e3) {
            return "string" != typeof e3;
          }))) && "owners" !== d2 && "boolean" != typeof d2) return r3(s2, t2(u2)), false;
          break;
        default:
          if (!qa.id[u2]) return console.error("customIntegration does not support key ".concat(u2)), false;
      }
    }
  }
  return true;
}
function gc(e2, t2) {
  if (void 0 === t2) return false;
  switch (n(t2)) {
    case "string":
      return n(e2) === t2;
    case "object":
      if ("object" !== n(e2)) return false;
      for (var r3 in e2) if (!gc(e2[r3], t2[r3])) return false;
      return true;
    default:
      return false;
  }
}
function mc(e2, t2) {
  var n2 = e2.sessionId, r3 = e2.toEndPoint, i2 = e2.callerId, o2 = e2.useSipRefer;
  if (!n2 || !r3) throw new Error("".concat(t2, "() requires a sessionId and toEndPoint"));
  if ("string" != typeof n2 || "string" != typeof r3) throw new Error("Invalid paramater: sessionId and toEndPoint must be of type string");
  if (o2 && !r3.startsWith("sip:")) throw new Error('"toEndPoint" must be a "sip" address');
  if (!r3.startsWith("sip:") && !r3.startsWith("+")) throw new Error("toEndPoint: ".concat(r3, ' must starts with either "sip:" or "+"'));
  if (i2 && "string" != typeof i2) throw new Error("callerId must be of type string");
  if (i2 && !r3.startsWith("+")) throw new Error("callerId is only valid when transferring to a PSTN number");
}
function yc(e2) {
  if ("object" !== n(e2)) throw new Error('RemoteMediaPlayerSettings: must be "object" type');
  if (e2.state && !Object.values(Xo).includes(e2.state)) throw new Error("Invalid value for RemoteMediaPlayerSettings.state, valid values are: " + JSON.stringify(Xo));
  if (e2.volume) {
    if ("number" != typeof e2.volume) throw new Error('RemoteMediaPlayerSettings.volume: must be "number" type');
    if (e2.volume < 0 || e2.volume > 2) throw new Error("RemoteMediaPlayerSettings.volume: must be between 0.0 - 2.0");
  }
}
function bc(e2, t2, n2) {
  return !("number" != typeof e2 || e2 < t2 || e2 > n2);
}
function _c(e2, t2) {
  return e2 && !t2 && delete e2.data, e2;
}

// node_modules/.pnpm/@pipecat-ai+daily-transport@1.3.0_@pipecat-ai+client-js@1.3.0/node_modules/@pipecat-ai/daily-transport/dist/index.module.js
function $parcel$interopDefault(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
function $parcel$export(e2, n2, v2, s2) {
  Object.defineProperty(e2, n2, { get: v2, set: s2, enumerable: true, configurable: true });
}
var $683f111f61e07358$exports = {};
$parcel$export($683f111f61e07358$exports, "DailyRTVIMessageType", () => $683f111f61e07358$export$ef180de88fd317cc);
$parcel$export($683f111f61e07358$exports, "DailyTransport", () => $683f111f61e07358$export$b1ca982aa1e488c1);
var $6d4b7449a1e1544a$export$13afda237b1c9846 = class {
  /**
  * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format
  * @param {Float32Array} float32Array
  * @returns {ArrayBuffer}
  */
  static floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset2 = 0;
    for (let i2 = 0; i2 < float32Array.length; i2++, offset2 += 2) {
      let s2 = Math.max(-1, Math.min(1, float32Array[i2]));
      view.setInt16(offset2, s2 < 0 ? s2 * 32768 : s2 * 32767, true);
    }
    return buffer;
  }
  /**
  * Concatenates two ArrayBuffers
  * @param {ArrayBuffer} leftBuffer
  * @param {ArrayBuffer} rightBuffer
  * @returns {ArrayBuffer}
  */
  static mergeBuffers(leftBuffer, rightBuffer) {
    const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);
    tmpArray.set(new Uint8Array(leftBuffer), 0);
    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);
    return tmpArray.buffer;
  }
  /**
  * Packs data into an Int16 format
  * @private
  * @param {number} size 0 = 1x Int16, 1 = 2x Int16
  * @param {number} arg value to pack
  * @returns
  */
  _packData(size2, arg) {
    return [
      new Uint8Array([
        arg,
        arg >> 8
      ]),
      new Uint8Array([
        arg,
        arg >> 8,
        arg >> 16,
        arg >> 24
      ])
    ][size2];
  }
  /**
  * Packs audio into "audio/wav" Blob
  * @param {number} sampleRate
  * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio
  * @returns {WavPackerAudioType}
  */
  pack(sampleRate, audio) {
    if (!(audio == null ? void 0 : audio.bitsPerSample)) throw new Error(`Missing "bitsPerSample"`);
    else if (!(audio == null ? void 0 : audio.channels)) throw new Error(`Missing "channels"`);
    else if (!(audio == null ? void 0 : audio.data)) throw new Error(`Missing "data"`);
    const { bitsPerSample, channels, data } = audio;
    const output = [
      // Header
      "RIFF",
      this._packData(1, 52),
      "WAVE",
      // chunk 1
      "fmt ",
      this._packData(1, 16),
      this._packData(0, 1),
      this._packData(0, channels.length),
      this._packData(1, sampleRate),
      this._packData(1, sampleRate * channels.length * bitsPerSample / 8),
      this._packData(0, channels.length * bitsPerSample / 8),
      this._packData(0, bitsPerSample),
      // chunk 2
      "data",
      this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),
      data
    ];
    const blob = new Blob(output, {
      type: "audio/mpeg"
    });
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      channelCount: channels.length,
      sampleRate,
      duration: data.byteLength / (channels.length * sampleRate * 2)
    };
  }
};
globalThis.WavPacker = $6d4b7449a1e1544a$export$13afda237b1c9846;
var $03f71ce85e00ada6$var$octave8Frequencies = [
  4186.01,
  4434.92,
  4698.63,
  4978.03,
  5274.04,
  5587.65,
  5919.91,
  6271.93,
  6644.88,
  7040,
  7458.62,
  7902.13
];
var $03f71ce85e00ada6$var$octave8FrequencyLabels = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
var $03f71ce85e00ada6$export$776c63898ae5b636 = [];
var $03f71ce85e00ada6$export$facd167cc27ea9b0 = [];
for (let i2 = 1; i2 <= 8; i2++) for (let f2 = 0; f2 < $03f71ce85e00ada6$var$octave8Frequencies.length; f2++) {
  const freq = $03f71ce85e00ada6$var$octave8Frequencies[f2];
  $03f71ce85e00ada6$export$776c63898ae5b636.push(freq / Math.pow(2, 8 - i2));
  $03f71ce85e00ada6$export$facd167cc27ea9b0.push($03f71ce85e00ada6$var$octave8FrequencyLabels[f2] + i2);
}
var $03f71ce85e00ada6$var$voiceFrequencyRange = [
  32,
  2e3
];
var $03f71ce85e00ada6$export$dbc1581ed2cfa183 = $03f71ce85e00ada6$export$776c63898ae5b636.filter((_2, i2) => {
  return $03f71ce85e00ada6$export$776c63898ae5b636[i2] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i2] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];
});
var $03f71ce85e00ada6$export$30a6f2881311088f = $03f71ce85e00ada6$export$facd167cc27ea9b0.filter((_2, i2) => {
  return $03f71ce85e00ada6$export$776c63898ae5b636[i2] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i2] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];
});
var $f32f064564ee62f6$export$2c3136da0bf130f9 = class _$f32f064564ee62f6$export$2c3136da0bf130f9 {
  /**
  * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range
  * returns human-readable formatting and labels
  * @param {AnalyserNode} analyser
  * @param {number} sampleRate
  * @param {Float32Array} [fftResult]
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  static getFrequencies(analyser, sampleRate, fftResult, analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!fftResult) {
      fftResult = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(fftResult);
    }
    const nyquistFrequency = sampleRate / 2;
    const frequencyStep = 1 / fftResult.length * nyquistFrequency;
    let outputValues;
    let frequencies;
    let labels;
    if (analysisType === "music" || analysisType === "voice") {
      const useFrequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);
      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);
      for (let i2 = 0; i2 < fftResult.length; i2++) {
        const frequency = i2 * frequencyStep;
        const amplitude = fftResult[i2];
        for (let n2 = useFrequencies.length - 1; n2 >= 0; n2--) if (frequency > useFrequencies[n2]) {
          aggregateOutput[n2] = Math.max(aggregateOutput[n2], amplitude);
          break;
        }
      }
      outputValues = aggregateOutput;
      frequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);
      labels = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$30a6f2881311088f) : (0, $03f71ce85e00ada6$export$facd167cc27ea9b0);
    } else {
      outputValues = Array.from(fftResult);
      frequencies = outputValues.map((_2, i2) => frequencyStep * i2);
      labels = frequencies.map((f2) => `${f2.toFixed(2)} Hz`);
    }
    const normalizedOutput = outputValues.map((v2) => {
      return Math.max(0, Math.min((v2 - minDecibels) / (maxDecibels - minDecibels), 1));
    });
    const values = new Float32Array(normalizedOutput);
    return {
      values,
      frequencies,
      labels
    };
  }
  /**
  * Creates a new AudioAnalysis instance for an HTMLAudioElement
  * @param {HTMLAudioElement} audioElement
  * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer
  * @returns {AudioAnalysis}
  */
  constructor(audioElement, audioBuffer = null) {
    this.fftResults = [];
    if (audioBuffer) {
      const { length, sampleRate } = audioBuffer;
      const offlineAudioContext = new OfflineAudioContext({
        length,
        sampleRate
      });
      const source = offlineAudioContext.createBufferSource();
      source.buffer = audioBuffer;
      const analyser = offlineAudioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      source.connect(analyser);
      const renderQuantumInSeconds = 1 / 60;
      const durationInSeconds = length / sampleRate;
      const analyze = (index2) => {
        const suspendTime = renderQuantumInSeconds * index2;
        if (suspendTime < durationInSeconds) offlineAudioContext.suspend(suspendTime).then(() => {
          const fftResult = new Float32Array(analyser.frequencyBinCount);
          analyser.getFloatFrequencyData(fftResult);
          this.fftResults.push(fftResult);
          analyze(index2 + 1);
        });
        if (index2 === 1) offlineAudioContext.startRendering();
        else offlineAudioContext.resume();
      };
      source.start(0);
      analyze(1);
      this.audio = audioElement;
      this.context = offlineAudioContext;
      this.analyser = analyser;
      this.sampleRate = sampleRate;
      this.audioBuffer = audioBuffer;
    } else {
      const audioContext = new AudioContext();
      const track2 = audioContext.createMediaElementSource(audioElement);
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      track2.connect(analyser);
      analyser.connect(audioContext.destination);
      this.audio = audioElement;
      this.context = audioContext;
      this.analyser = analyser;
      this.sampleRate = this.context.sampleRate;
      this.audioBuffer = null;
    }
  }
  /**
  * Gets the current frequency domain data from the playing audio track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    let fftResult = null;
    if (this.audioBuffer && this.fftResults.length) {
      const pct = this.audio.currentTime / this.audio.duration;
      const index2 = Math.min(pct * this.fftResults.length | 0, this.fftResults.length - 1);
      fftResult = this.fftResults[index2];
    }
    return _$f32f064564ee62f6$export$2c3136da0bf130f9.getFrequencies(this.analyser, this.sampleRate, fftResult, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Resume the internal AudioContext if it was suspended due to the lack of
  * user interaction when the AudioAnalysis was instantiated.
  * @returns {Promise<true>}
  */
  async resumeIfSuspended() {
    if (this.context.state === "suspended") await this.context.resume();
    return true;
  }
};
globalThis.AudioAnalysis = $f32f064564ee62f6$export$2c3136da0bf130f9;
var $29a8a70a9466b14f$export$50b76700e2b15e9 = `
class StreamProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.hasStarted = false;
    this.hasInterrupted = false;
    this.outputBuffers = [];
    this.bufferLength = 128;
    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };
    this.writeOffset = 0;
    this.trackSampleOffsets = {};
    this.port.onmessage = (event) => {
      if (event.data) {
        const payload = event.data;
        if (payload.event === 'write') {
          const int16Array = payload.buffer;
          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32
          }
          this.writeData(float32Array, payload.trackId);
        } else if (
          payload.event === 'offset' ||
          payload.event === 'interrupt'
        ) {
          const requestId = payload.requestId;
          const trackId = this.write.trackId;
          const offset = this.trackSampleOffsets[trackId] || 0;
          this.port.postMessage({
            event: 'offset',
            requestId,
            trackId,
            offset,
          });
          if (payload.event === 'interrupt') {
            this.hasInterrupted = true;
          }
        } else {
          throw new Error(\`Unhandled event "\${payload.event}"\`);
        }
      }
    };
  }

  writeData(float32Array, trackId = null) {
    let { buffer } = this.write;
    let offset = this.writeOffset;
    for (let i = 0; i < float32Array.length; i++) {
      buffer[offset++] = float32Array[i];
      if (offset >= buffer.length) {
        this.outputBuffers.push(this.write);
        this.write = { buffer: new Float32Array(this.bufferLength), trackId };
        buffer = this.write.buffer;
        offset = 0;
      }
    }
    this.writeOffset = offset;
    return true;
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const outputChannelData = output[0];
    const outputBuffers = this.outputBuffers;
    if (this.hasInterrupted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else if (outputBuffers.length) {
      this.hasStarted = true;
      const { buffer, trackId } = outputBuffers.shift();
      for (let i = 0; i < outputChannelData.length; i++) {
        outputChannelData[i] = buffer[i] || 0;
      }
      if (trackId) {
        this.trackSampleOffsets[trackId] =
          this.trackSampleOffsets[trackId] || 0;
        this.trackSampleOffsets[trackId] += buffer.length;
      }
      return true;
    } else if (this.hasStarted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else {
      return true;
    }
  }
}

registerProcessor('stream_processor', StreamProcessor);
`;
var $29a8a70a9466b14f$var$script = new Blob([
  $29a8a70a9466b14f$export$50b76700e2b15e9
], {
  type: "application/javascript"
});
var $29a8a70a9466b14f$var$src = URL.createObjectURL($29a8a70a9466b14f$var$script);
var $29a8a70a9466b14f$export$bfa8c596114d74df = $29a8a70a9466b14f$var$src;
var $d0a969833958d9e7$export$9698d62c78b8f366 = class {
  /**
  * Creates a new WavStreamPlayer instance
  * @param {{sampleRate?: number}} options
  * @returns {WavStreamPlayer}
  */
  constructor({ sampleRate = 44100 } = {}) {
    this.scriptSrc = (0, $29a8a70a9466b14f$export$bfa8c596114d74df);
    this.sampleRate = sampleRate;
    this.context = null;
    this.stream = null;
    this.analyser = null;
    this.trackSampleOffsets = {};
    this.interruptedTrackIds = {};
  }
  /**
  * Connects the audio context and enables output to speakers
  * @returns {Promise<true>}
  */
  async connect() {
    this.context = new AudioContext({
      sampleRate: this.sampleRate
    });
    if (this._speakerID) this.context.setSinkId(this._speakerID);
    if (this.context.state === "suspended") await this.context.resume();
    try {
      await this.context.audioWorklet.addModule(this.scriptSrc);
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const analyser = this.context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    this.analyser = analyser;
    return true;
  }
  /**
  * Gets the current frequency domain data from the playing track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.analyser) throw new Error("Not connected, please call .connect() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * @param {string} speaker deviceId
  */
  async updateSpeaker(speaker) {
    const _prevSpeaker = this._speakerID;
    this._speakerID = speaker;
    if (this.context) try {
      if (speaker === "default") await this.context.setSinkId();
      else await this.context.setSinkId(speaker);
    } catch (e2) {
      console.error(`Could not set sinkId to ${speaker}: ${e2}`);
      this._speakerID = _prevSpeaker;
    }
  }
  /**
  * Starts audio streaming
  * @private
  * @returns {Promise<true>}
  */
  _start() {
    const streamNode = new AudioWorkletNode(this.context, "stream_processor");
    streamNode.connect(this.context.destination);
    streamNode.port.onmessage = (e2) => {
      const { event } = e2.data;
      if (event === "stop") {
        streamNode.disconnect();
        this.stream = null;
      } else if (event === "offset") {
        const { requestId, trackId, offset: offset2 } = e2.data;
        const currentTime = offset2 / this.sampleRate;
        this.trackSampleOffsets[requestId] = {
          trackId,
          offset: offset2,
          currentTime
        };
      }
    };
    this.analyser.disconnect();
    streamNode.connect(this.analyser);
    this.stream = streamNode;
    return true;
  }
  /**
  * Adds 16BitPCM data to the currently playing audio stream
  * You can add chunks beyond the current play point and they will be queued for play
  * @param {ArrayBuffer|Int16Array} arrayBuffer
  * @param {string} [trackId]
  * @returns {Int16Array}
  */
  add16BitPCM(arrayBuffer, trackId = "default") {
    if (typeof trackId !== "string") throw new Error(`trackId must be a string`);
    else if (this.interruptedTrackIds[trackId]) return;
    if (!this.stream) this._start();
    let buffer;
    if (arrayBuffer instanceof Int16Array) buffer = arrayBuffer;
    else if (arrayBuffer instanceof ArrayBuffer) buffer = new Int16Array(arrayBuffer);
    else throw new Error(`argument must be Int16Array or ArrayBuffer`);
    this.stream.port.postMessage({
      event: "write",
      buffer,
      trackId
    });
    return buffer;
  }
  /**
  * Gets the offset (sample count) of the currently playing stream
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async getTrackSampleOffset(interrupt = false) {
    if (!this.stream) return null;
    const requestId = crypto.randomUUID();
    this.stream.port.postMessage({
      event: interrupt ? "interrupt" : "offset",
      requestId
    });
    let trackSampleOffset;
    while (!trackSampleOffset) {
      trackSampleOffset = this.trackSampleOffsets[requestId];
      await new Promise((r3) => setTimeout(() => r3(), 1));
    }
    const { trackId } = trackSampleOffset;
    if (interrupt && trackId) this.interruptedTrackIds[trackId] = true;
    return trackSampleOffset;
  }
  /**
  * Strips the current stream and returns the sample offset of the audio
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async interrupt() {
    return this.getTrackSampleOffset(true);
  }
};
globalThis.WavStreamPlayer = $d0a969833958d9e7$export$9698d62c78b8f366;
var $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet = `
class AudioProcessor extends AudioWorkletProcessor {

  constructor() {
    super();
    this.port.onmessage = this.receive.bind(this);
    this.initialize();
  }

  initialize() {
    this.foundAudio = false;
    this.recording = false;
    this.chunks = [];
  }

  /**
   * Concatenates sampled chunks into channels
   * Format is chunk[Left[], Right[]]
   */
  readChannelData(chunks, channel = -1, maxChannels = 9) {
    let channelLimit;
    if (channel !== -1) {
      if (chunks[0] && chunks[0].length - 1 < channel) {
        throw new Error(
          \`Channel \${channel} out of range: max \${chunks[0].length}\`
        );
      }
      channelLimit = channel + 1;
    } else {
      channel = 0;
      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);
    }
    const channels = [];
    for (let n = channel; n < channelLimit; n++) {
      const length = chunks.reduce((sum, chunk) => {
        return sum + chunk[n].length;
      }, 0);
      const buffers = chunks.map((chunk) => chunk[n]);
      const result = new Float32Array(length);
      let offset = 0;
      for (let i = 0; i < buffers.length; i++) {
        result.set(buffers[i], offset);
        offset += buffers[i].length;
      }
      channels[n] = result;
    }
    return channels;
  }

  /**
   * Combines parallel audio data into correct format,
   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]
   */
  formatAudioData(channels) {
    if (channels.length === 1) {
      // Simple case is only one channel
      const float32Array = channels[0].slice();
      const meanValues = channels[0].slice();
      return { float32Array, meanValues };
    } else {
      const float32Array = new Float32Array(
        channels[0].length * channels.length
      );
      const meanValues = new Float32Array(channels[0].length);
      for (let i = 0; i < channels[0].length; i++) {
        const offset = i * channels.length;
        let meanValue = 0;
        for (let n = 0; n < channels.length; n++) {
          float32Array[offset + n] = channels[n][i];
          meanValue += channels[n][i];
        }
        meanValues[i] = meanValue / channels.length;
      }
      return { float32Array, meanValues };
    }
  }

  /**
   * Converts 32-bit float data to 16-bit integers
   */
  floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < float32Array.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
    return buffer;
  }

  /**
   * Retrieves the most recent amplitude values from the audio stream
   * @param {number} channel
   */
  getValues(channel = -1) {
    const channels = this.readChannelData(this.chunks, channel);
    const { meanValues } = this.formatAudioData(channels);
    return { meanValues, channels };
  }

  /**
   * Exports chunks as an audio/wav file
   */
  export() {
    const channels = this.readChannelData(this.chunks);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const audioData = this.floatTo16BitPCM(float32Array);
    return {
      meanValues: meanValues,
      audio: {
        bitsPerSample: 16,
        channels: channels,
        data: audioData,
      },
    };
  }

  receive(e) {
    const { event, id } = e.data;
    let receiptData = {};
    switch (event) {
      case 'start':
        this.recording = true;
        break;
      case 'stop':
        this.recording = false;
        break;
      case 'clear':
        this.initialize();
        break;
      case 'export':
        receiptData = this.export();
        break;
      case 'read':
        receiptData = this.getValues();
        break;
      default:
        break;
    }
    // Always send back receipt
    this.port.postMessage({ event: 'receipt', id, data: receiptData });
  }

  sendChunk(chunk) {
    const channels = this.readChannelData([chunk]);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const rawAudioData = this.floatTo16BitPCM(float32Array);
    const monoAudioData = this.floatTo16BitPCM(meanValues);
    this.port.postMessage({
      event: 'chunk',
      data: {
        mono: monoAudioData,
        raw: rawAudioData,
      },
    });
  }

  process(inputList, outputList, parameters) {
    // Copy input to output (e.g. speakers)
    // Note that this creates choppy sounds with Mac products
    const sourceLimit = Math.min(inputList.length, outputList.length);
    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {
      const input = inputList[inputNum];
      const output = outputList[inputNum];
      const channelCount = Math.min(input.length, output.length);
      for (let channelNum = 0; channelNum < channelCount; channelNum++) {
        input[channelNum].forEach((sample, i) => {
          output[channelNum][i] = sample;
        });
      }
    }
    const inputs = inputList[0];
    // There's latency at the beginning of a stream before recording starts
    // Make sure we actually receive audio data before we start storing chunks
    let sliceIndex = 0;
    if (!this.foundAudio) {
      for (const channel of inputs) {
        sliceIndex = 0; // reset for each channel
        if (this.foundAudio) {
          break;
        }
        if (channel) {
          for (const value of channel) {
            if (value !== 0) {
              // find only one non-zero entry in any channel
              this.foundAudio = true;
              break;
            } else {
              sliceIndex++;
            }
          }
        }
      }
    }
    if (inputs && inputs[0] && this.foundAudio && this.recording) {
      // We need to copy the TypedArray, because the \`process\`
      // internals will reuse the same buffer to hold each input
      const chunk = inputs.map((input) => input.slice(sliceIndex));
      this.chunks.push(chunk);
      this.sendChunk(chunk);
    }
    return true;
  }
}

registerProcessor('audio_processor', AudioProcessor);
`;
var $8e1d1e6ff08f6fb5$var$script = new Blob([
  $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet
], {
  type: "application/javascript"
});
var $8e1d1e6ff08f6fb5$var$src = URL.createObjectURL($8e1d1e6ff08f6fb5$var$script);
var $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c = $8e1d1e6ff08f6fb5$var$src;
var $62bc376044a05513$export$439b217ca659a877 = class {
  /**
  * Create a new WavRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {WavRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this._deviceChangeCallback = null;
    this._deviceErrorCallback = null;
    this._devices = [];
    this.deviceSelection = null;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer
  * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData
  * @param {number} sampleRate
  * @param {number} fromSampleRate
  * @returns {Promise<DecodedAudioType>}
  */
  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {
    const context = new AudioContext({
      sampleRate
    });
    let arrayBuffer;
    let blob;
    if (audioData instanceof Blob) {
      if (fromSampleRate !== -1) throw new Error(`Can not specify "fromSampleRate" when reading from Blob`);
      blob = audioData;
      arrayBuffer = await blob.arrayBuffer();
    } else if (audioData instanceof ArrayBuffer) {
      if (fromSampleRate !== -1) throw new Error(`Can not specify "fromSampleRate" when reading from ArrayBuffer`);
      arrayBuffer = audioData;
      blob = new Blob([
        arrayBuffer
      ], {
        type: "audio/wav"
      });
    } else {
      let float32Array;
      let data;
      if (audioData instanceof Int16Array) {
        data = audioData;
        float32Array = new Float32Array(audioData.length);
        for (let i2 = 0; i2 < audioData.length; i2++) float32Array[i2] = audioData[i2] / 32768;
      } else if (audioData instanceof Float32Array) float32Array = audioData;
      else if (audioData instanceof Array) float32Array = new Float32Array(audioData);
      else throw new Error(`"audioData" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);
      if (fromSampleRate === -1) throw new Error(`Must specify "fromSampleRate" when reading from Float32Array, In16Array or Array`);
      else if (fromSampleRate < 3e3) throw new Error(`Minimum "fromSampleRate" is 3000 (3kHz)`);
      if (!data) data = (0, $6d4b7449a1e1544a$export$13afda237b1c9846).floatTo16BitPCM(float32Array);
      const audio = {
        bitsPerSample: 16,
        channels: [
          float32Array
        ],
        data
      };
      const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
      const result = packer.pack(fromSampleRate, audio);
      blob = result.blob;
      arrayBuffer = await blob.arrayBuffer();
    }
    const audioBuffer = await context.decodeAudioData(arrayBuffer);
    const values = audioBuffer.getChannelData(0);
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      values,
      audioBuffer
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug) this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor) return "ended";
    else if (!this.recording) return "paused";
    else return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor) throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Sets device change callback, remove if callback provided is `null`
  * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback
  * @returns {true}
  */
  listenForDeviceChange(callback2) {
    if (callback2 === null && this._deviceChangeCallback) {
      navigator.mediaDevices.removeEventListener("devicechange", this._deviceChangeCallback);
      this._deviceChangeCallback = null;
    } else if (callback2 !== null) {
      let lastId = 0;
      let lastDevices = [];
      const serializeDevices = (devices) => devices.map((d2) => d2.deviceId).sort().join(",");
      const cb = async () => {
        let id = ++lastId;
        const devices = await this.listDevices();
        if (id === lastId) {
          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {
            lastDevices = devices;
            callback2(devices.slice());
          }
        }
      };
      navigator.mediaDevices.addEventListener("devicechange", cb);
      cb();
      this._deviceChangeCallback = cb;
    }
    return true;
  }
  /**
  * Provide a callback for if/when device errors occur
  * @param {(({devices: Array<"cam" | "mic">, type: string, error?: Error}) => void) | null} callback
  * @returns {true}
  */
  listenForDeviceErrors(callback2) {
    this._deviceErrorCallback = callback2;
  }
  /**
  * Manually request permission to use the microphone
  * @returns {Promise<true>}
  */
  async requestPermission() {
    const permissionStatus = await navigator.permissions.query({
      name: "microphone"
    });
    if (permissionStatus.state === "denied") {
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic"
        ],
        type: "unknown",
        error: new Error("Microphone access denied")
      });
    } else if (permissionStatus.state === "prompt") try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true
      });
      const tracks = stream.getTracks();
      tracks.forEach((track2) => track2.stop());
    } catch (e2) {
      console.error("Error accessing microphone.");
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic"
        ],
        type: "unknown",
        error: e2
      });
    }
    return true;
  }
  /**
  * List all eligible devices for recording, will request permission to use microphone
  * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}
  */
  async listDevices() {
    if (!navigator.mediaDevices || !("enumerateDevices" in navigator.mediaDevices)) throw new Error("Could not request user devices");
    await this.requestPermission();
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioDevices = devices.filter((device) => device.kind === "audioinput");
    return audioDevices;
  }
  /**
  * Begins a recording session and requests microphone permissions if not already granted
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {string} [deviceId] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(deviceId) {
    var _a3;
    if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);
    if (!navigator.mediaDevices || !("getUserMedia" in navigator.mediaDevices)) {
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic",
          "cam"
        ],
        type: "undefined-mediadevices"
      });
      throw new Error("Could not request user media");
    }
    deviceId = deviceId ?? ((_a3 = this.deviceSelection) == null ? void 0 : _a3.deviceId);
    try {
      const config = {
        audio: true
      };
      if (deviceId) config.audio = {
        deviceId: {
          exact: deviceId
        }
      };
      this.stream = await navigator.mediaDevices.getUserMedia(config);
    } catch (err) {
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic"
        ],
        type: "unknown",
        error: err
      });
      throw new Error("Could not start media stream");
    }
    this.listDevices().then((devices) => {
      deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;
      console.log("find current device", devices, deviceId, this.stream.getAudioTracks()[0].getSettings());
      this.deviceSelection = devices.find((d2) => d2.deviceId === deviceId);
      console.log("current device", this.deviceSelection);
    });
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e2) => {
      const { event, id, data } = e2.data;
      if (event === "receipt") this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    console.log("begin completed");
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (!this.recording) throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (this.recording) throw new Error("Already recording: please call .pause() first");
    else if (typeof chunkProcessor !== "function") throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording) throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    const tracks = this.stream.getTracks();
    tracks.forEach((track2) => track2.stop());
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    this.deviceSelection = null;
    if (this.processor) await this.end();
    return true;
  }
};
globalThis.WavRecorder = $62bc376044a05513$export$439b217ca659a877;
var $5fc11d7bc0d20724$export$2934cf2d25c67a48 = class {
  /**
  * Create a new MediaStreamRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {MediaStreamRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug) this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor) return "ended";
    else if (!this.recording) return "paused";
    else return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor) throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Begins a recording session for the given audioTrack
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(audioTrack) {
    if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);
    if (!audioTrack || audioTrack.kind !== "audio") throw new Error("No audio track provided");
    this.stream = new MediaStream([
      audioTrack
    ]);
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e2) => {
      const { event, id, data } = e2.data;
      if (event === "receipt") this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (!this.recording) throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (this.recording) throw new Error("Already recording: HELLO please call .pause() first");
    else if (typeof chunkProcessor !== "function") throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording) throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    if (this.processor) await this.end();
    return true;
  }
};
globalThis.WavRecorder = WavRecorder;
var $58d19ff082af5e5c$exports = {};
$58d19ff082af5e5c$exports = JSON.parse('{"name":"@pipecat-ai/daily-transport","version":"1.3.0","license":"BSD-2-Clause","main":"dist/index.js","module":"dist/index.module.js","types":"dist/index.d.ts","source":"src/index.ts","repository":{"type":"git","url":"git+https://github.com/pipecat-ai/pipecat-client-web-transports.git"},"files":["dist","package.json","README.md"],"scripts":{"build":"parcel build --no-cache","dev":"parcel watch","lint":"eslint . --ext ts --report-unused-disable-directives --max-warnings 0"},"devDependencies":{"@pipecat-ai/client-js":"^1.3.0","eslint":"9.11.1","eslint-config-prettier":"^9.1.0","eslint-plugin-simple-import-sort":"^12.1.1"},"peerDependencies":{"@pipecat-ai/client-js":"~1.3.0"},"dependencies":{"@daily-co/daily-js":"^0.83.1"},"description":"Pipecat Daily Transport Package","author":"Daily.co","bugs":{"url":"https://github.com/pipecat-ai/pipecat-client-web-transports/issues"},"homepage":"https://github.com/pipecat-ai/pipecat-client-web-transports/blob/main/transports/daily-webrtc/README.md"}');
var $683f111f61e07358$export$ef180de88fd317cc;
(function(DailyRTVIMessageType) {
  DailyRTVIMessageType["AUDIO_BUFFERING_STARTED"] = "audio-buffering-started";
  DailyRTVIMessageType["AUDIO_BUFFERING_STOPPED"] = "audio-buffering-stopped";
})($683f111f61e07358$export$ef180de88fd317cc || ($683f111f61e07358$export$ef180de88fd317cc = {}));
var $683f111f61e07358$var$DailyCallWrapper = class {
  constructor(daily) {
    this._daily = daily;
    this._proxy = new Proxy(this._daily, {
      get: (target, prop, receiver) => {
        if (typeof target[prop] === "function") {
          let errMsg;
          switch (String(prop)) {
            // Disable methods that modify the lifecycle of the call. These operations
            // should be performed via the PipecatClient in order to keep state in sync.
            case "preAuth":
              errMsg = `Calls to preAuth() are disabled. Please use Transport.preAuth()`;
              break;
            case "startCamera":
              errMsg = `Calls to startCamera() are disabled. Please use PipecatClient.initDevices()`;
              break;
            case "join":
              errMsg = `Calls to join() are disabled. Please use PipecatClient.connect()`;
              break;
            case "leave":
              errMsg = `Calls to leave() are disabled. Please use PipecatClient.disconnect()`;
              break;
            case "destroy":
              errMsg = `Calls to destroy() are disabled.`;
              break;
          }
          if (errMsg) return () => {
            throw new Error(errMsg);
          };
          return (...args) => {
            return target[prop](...args);
          };
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  get proxy() {
    return this._proxy;
  }
};
var $683f111f61e07358$export$b1ca982aa1e488c1 = class _$683f111f61e07358$export$b1ca982aa1e488c1 extends (0, $7ef5cee66c377f4d$export$86495b081fef8e52) {
  constructor(opts = {}) {
    super();
    this._botId = "";
    this._selectedCam = {};
    this._selectedMic = {};
    this._selectedSpeaker = {};
    this._currentAudioTrack = null;
    this._audioQueue = [];
    this._callbacks = {};
    const { bufferLocalAudioUntilBotReady, ...dailyOpts } = opts;
    this._dailyFactoryOptions = dailyOpts;
    this._bufferLocalAudioUntilBotReady = bufferLocalAudioUntilBotReady || false;
    this._daily = (0, Ha).createCallObject({
      ...this._dailyFactoryOptions,
      allowMultipleCallInstances: true
    });
    this._dailyWrapper = new $683f111f61e07358$var$DailyCallWrapper(this._daily);
  }
  setupRecorder() {
    this._mediaStreamRecorder = new (0, $5fc11d7bc0d20724$export$2934cf2d25c67a48)({
      sampleRate: _$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE
    });
  }
  handleUserAudioStream(data) {
    this._audioQueue.push(data);
  }
  flushAudioQueue() {
    const batchSize = 10;
    if (this._audioQueue.length === 0) return;
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Will flush audio queue: ${this._audioQueue.length}`);
    while (this._audioQueue.length > 0) {
      const batch = [];
      while (batch.length < batchSize && this._audioQueue.length > 0) {
        const queuedData = this._audioQueue.shift();
        if (queuedData) batch.push(queuedData);
      }
      if (batch.length > 0) this._sendAudioBatch(batch);
    }
  }
  _sendAudioBatch(dataBatch) {
    const encodedBatch = dataBatch.map((data) => {
      const pcmByteArray = new Uint8Array(data);
      return btoa(String.fromCharCode(...pcmByteArray));
    });
    const audioMessage = {
      id: "raw-audio-batch",
      label: "rtvi-ai",
      type: "raw-audio-batch",
      data: {
        base64AudioBatch: encodedBatch,
        sampleRate: _$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE,
        numChannels: 1
      }
    };
    this.sendMessage(audioMessage);
  }
  initialize(options, messageHandler) {
    if (this._bufferLocalAudioUntilBotReady) this.setupRecorder();
    this._callbacks = options.callbacks ?? {};
    this._onMessage = messageHandler;
    if (this._dailyFactoryOptions.startVideoOff == null || options.enableCam != null)
      this._dailyFactoryOptions.startVideoOff = !(options.enableCam ?? false);
    if (this._dailyFactoryOptions.startAudioOff == null || options.enableMic != null)
      this._dailyFactoryOptions.startAudioOff = !(options.enableMic ?? true);
    this.attachEventListeners();
    this.state = "disconnected";
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[Daily Transport] Initialized", (0, $parcel$interopDefault($58d19ff082af5e5c$exports)).version);
  }
  get dailyCallClient() {
    return this._dailyWrapper.proxy;
  }
  get state() {
    return this._state;
  }
  set state(state) {
    var _a3, _b;
    if (this._state === state) return;
    this._state = state;
    (_b = (_a3 = this._callbacks).onTransportStateChanged) == null ? void 0 : _b.call(_a3, state);
  }
  getSessionInfo() {
    return this._daily.meetingSessionSummary();
  }
  async getAllCams() {
    const { devices } = await this._daily.enumerateDevices();
    return devices.filter((d2) => d2.kind === "videoinput");
  }
  updateCam(camId) {
    this._daily.setInputDevicesAsync({
      videoDeviceId: camId
    }).then((infos) => {
      this._selectedCam = infos.camera;
    });
  }
  get selectedCam() {
    return this._selectedCam;
  }
  async getAllMics() {
    const { devices } = await this._daily.enumerateDevices();
    return devices.filter((d2) => d2.kind === "audioinput");
  }
  updateMic(micId) {
    this._daily.setInputDevicesAsync({
      audioDeviceId: micId
    }).then((infos) => {
      this._selectedMic = infos.mic;
    });
  }
  get selectedMic() {
    return this._selectedMic;
  }
  async getAllSpeakers() {
    const { devices } = await this._daily.enumerateDevices();
    return devices.filter((d2) => d2.kind === "audiooutput");
  }
  updateSpeaker(speakerId) {
    this._daily.setOutputDeviceAsync({
      outputDeviceId: speakerId
    }).then((infos) => {
      this._selectedSpeaker = infos.speaker;
    }).catch((e2) => {
      var _a3, _b;
      (_b = (_a3 = this._callbacks).onDeviceError) == null ? void 0 : _b.call(_a3, new (0, $db6391dc7d757577$export$64c9f614187c1e59)([
        "speaker"
      ], e2.type ?? "unknown", e2.message));
    });
  }
  get selectedSpeaker() {
    return this._selectedSpeaker;
  }
  enableMic(enable) {
    this._daily.setLocalAudio(enable);
  }
  get isMicEnabled() {
    return this._daily.localAudio();
  }
  enableCam(enable) {
    this._daily.setLocalVideo(enable);
  }
  get isCamEnabled() {
    return this._daily.localVideo();
  }
  enableScreenShare(enable) {
    if (enable) this._daily.startScreenShare();
    else this._daily.stopScreenShare();
  }
  get isSharingScreen() {
    return this._daily.localScreenAudio() || this._daily.localScreenVideo();
  }
  tracks() {
    var _a3, _b, _c2, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n2, _o2, _p;
    const participants = this._daily.participants() ?? {};
    const bot = participants == null ? void 0 : participants[this._botId];
    const tracks = {
      local: {
        audio: (_c2 = (_b = (_a3 = participants == null ? void 0 : participants.local) == null ? void 0 : _a3.tracks) == null ? void 0 : _b.audio) == null ? void 0 : _c2.persistentTrack,
        screenAudio: (_f = (_e2 = (_d = participants == null ? void 0 : participants.local) == null ? void 0 : _d.tracks) == null ? void 0 : _e2.screenAudio) == null ? void 0 : _f.persistentTrack,
        screenVideo: (_i = (_h = (_g = participants == null ? void 0 : participants.local) == null ? void 0 : _g.tracks) == null ? void 0 : _h.screenVideo) == null ? void 0 : _i.persistentTrack,
        video: (_l = (_k = (_j = participants == null ? void 0 : participants.local) == null ? void 0 : _j.tracks) == null ? void 0 : _k.video) == null ? void 0 : _l.persistentTrack
      }
    };
    if (bot) tracks.bot = {
      audio: (_n2 = (_m = bot == null ? void 0 : bot.tracks) == null ? void 0 : _m.audio) == null ? void 0 : _n2.persistentTrack,
      video: (_p = (_o2 = bot == null ? void 0 : bot.tracks) == null ? void 0 : _o2.video) == null ? void 0 : _p.persistentTrack
    };
    return tracks;
  }
  async startRecording() {
    var _a3, _b;
    try {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).info("[Daily Transport] Initializing recording");
      await this._mediaStreamRecorder.record((data) => {
        this.handleUserAudioStream(data.mono);
      }, _$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_CHUNK_SIZE);
      (_b = (_a3 = this._callbacks).onAudioBufferingStarted) == null ? void 0 : _b.call(_a3);
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).info("[Daily Transport] Recording Initialized");
    } catch (e2) {
      const err = e2;
      if (!err.message.includes("Already recording")) (0, $e0900798b6cc045b$export$af88d00dbe7f521).error("Error starting recording", e2);
    }
  }
  async preAuth(dailyCallOptions) {
    this._dailyFactoryOptions = dailyCallOptions;
    await this._daily.preAuth(dailyCallOptions);
  }
  async initDevices() {
    var _a3, _b, _c2, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
    if (!this._daily) throw new (0, $db6391dc7d757577$export$59b4786f333aac02)("Transport instance not initialized");
    this.state = "initializing";
    const infos = await this._daily.startCamera(this._dailyFactoryOptions);
    const { devices } = await this._daily.enumerateDevices();
    const cams = devices.filter((d2) => d2.kind === "videoinput");
    const mics = devices.filter((d2) => d2.kind === "audioinput");
    const speakers = devices.filter((d2) => d2.kind === "audiooutput");
    this._selectedCam = infos.camera;
    this._selectedMic = infos.mic;
    this._selectedSpeaker = infos.speaker;
    (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) == null ? void 0 : _b.call(_a3, cams);
    (_d = (_c2 = this._callbacks).onAvailableMicsUpdated) == null ? void 0 : _d.call(_c2, mics);
    (_f = (_e2 = this._callbacks).onAvailableSpeakersUpdated) == null ? void 0 : _f.call(_e2, speakers);
    (_h = (_g = this._callbacks).onCamUpdated) == null ? void 0 : _h.call(_g, infos.camera);
    (_j = (_i = this._callbacks).onMicUpdated) == null ? void 0 : _j.call(_i, infos.mic);
    (_l = (_k = this._callbacks).onSpeakerUpdated) == null ? void 0 : _l.call(_k, infos.speaker);
    if (!this._daily.isLocalAudioLevelObserverRunning()) await this._daily.startLocalAudioLevelObserver(100);
    if (!this._daily.isRemoteParticipantsAudioLevelObserverRunning()) await this._daily.startRemoteParticipantsAudioLevelObserver(100);
    this.state = "initialized";
  }
  _validateConnectionParams(connectParams) {
    if (connectParams === void 0 || connectParams === null) return void 0;
    if (typeof connectParams !== "object") throw new (0, $db6391dc7d757577$export$59b4786f333aac02)("Invalid connection parameters");
    const tmpParams = connectParams;
    if (tmpParams.room_url) {
      tmpParams.url = tmpParams.room_url;
      delete tmpParams.room_url;
    } else if (tmpParams.dailyRoom) {
      tmpParams.url = tmpParams.dailyRoom;
      delete tmpParams.dailyRoom;
    }
    if (tmpParams.dailyToken) {
      tmpParams.token = tmpParams.dailyToken;
      delete tmpParams.dailyToken;
    }
    if (!tmpParams.token)
      delete tmpParams.token;
    return tmpParams;
  }
  async _connect(connectParams) {
    var _a3, _b, _c2;
    if (!this._daily) throw new (0, $db6391dc7d757577$export$59b4786f333aac02)("Transport instance not initialized");
    if (connectParams) this._dailyFactoryOptions = {
      ...this._dailyFactoryOptions,
      ...connectParams
    };
    this.state = "connecting";
    try {
      await this._daily.join(this._dailyFactoryOptions);
    } catch (e2) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).error("Failed to join room", e2);
      this.state = "error";
      throw new (0, $db6391dc7d757577$export$e0624a511a2c4e9)();
    }
    if ((_a3 = this._abortController) == null ? void 0 : _a3.signal.aborted) return;
    this.state = "connected";
    (_c2 = (_b = this._callbacks).onConnected) == null ? void 0 : _c2.call(_b);
  }
  async sendReadyMessage() {
    return new Promise((resolve2) => {
      var _a3, _b;
      const isIOS = () => {
        const userAgent = navigator.userAgent;
        return /iPad|iPhone|iPod/.test(userAgent) || /Macintosh/.test(userAgent) && "ontouchend" in document;
      };
      const sendReadyMessage = () => {
        this.state = "ready";
        this.flushAudioQueue();
        this.sendMessage((0, $c0d10c4690969999$export$69aa9ab0334b212).clientReady());
        this.stopRecording();
        resolve2();
      };
      for (const id in this._daily.participants()) {
        const p2 = this._daily.participants()[id];
        if (!p2.local && ((_b = (_a3 = p2.tracks) == null ? void 0 : _a3.audio) == null ? void 0 : _b.persistentTrack)) {
          sendReadyMessage();
          resolve2();
          return;
        }
      }
      const readyHandler = (ev) => {
        var _a4;
        if (!((_a4 = ev.participant) == null ? void 0 : _a4.local)) {
          this._daily.off("track-started", readyHandler);
          if (isIOS()) {
            (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[Daily Transport] iOS device detected, adding 0.5 second delay before sending ready message");
            setTimeout(sendReadyMessage, 500);
          } else
            sendReadyMessage();
        }
      };
      this._daily.on("track-started", readyHandler);
    });
  }
  stopRecording() {
    var _a3, _b;
    if (this._mediaStreamRecorder && this._mediaStreamRecorder.getStatus() !== "ended") {
      this._mediaStreamRecorder.end();
      (_b = (_a3 = this._callbacks).onAudioBufferingStopped) == null ? void 0 : _b.call(_a3);
    }
  }
  attachEventListeners() {
    this._daily.on("available-devices-updated", this.handleAvailableDevicesUpdated.bind(this));
    this._daily.on("selected-devices-updated", this.handleSelectedDevicesUpdated.bind(this));
    this._daily.on("camera-error", this.handleDeviceError.bind(this));
    this._daily.on("track-started", this.handleTrackStarted.bind(this));
    this._daily.on("track-stopped", this.handleTrackStopped.bind(this));
    this._daily.on("participant-joined", this.handleParticipantJoined.bind(this));
    this._daily.on("participant-left", this.handleParticipantLeft.bind(this));
    this._daily.on("local-audio-level", this.handleLocalAudioLevel.bind(this));
    this._daily.on("remote-participants-audio-level", this.handleRemoteAudioLevel.bind(this));
    this._daily.on("app-message", this.handleAppMessage.bind(this));
    this._daily.on("left-meeting", this.handleLeftMeeting.bind(this));
    this._daily.on("error", this.handleFatalError.bind(this));
    this._daily.on("nonfatal-error", this.handleNonFatalError.bind(this));
  }
  async _disconnect() {
    this.state = "disconnecting";
    this._daily.stopLocalAudioLevelObserver();
    this._daily.stopRemoteParticipantsAudioLevelObserver();
    this._audioQueue = [];
    this._currentAudioTrack = null;
    this.stopRecording();
    await this._daily.leave();
  }
  sendMessage(message) {
    this._daily.sendAppMessage(message, "*");
  }
  handleAppMessage(ev) {
    if (ev.data.label === "rtvi-ai") this._onMessage({
      id: ev.data.id,
      type: ev.data.type,
      data: ev.data.data
    });
  }
  handleAvailableDevicesUpdated(ev) {
    var _a3, _b, _c2, _d, _e2, _f;
    (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) == null ? void 0 : _b.call(_a3, ev.availableDevices.filter((d2) => d2.kind === "videoinput"));
    (_d = (_c2 = this._callbacks).onAvailableMicsUpdated) == null ? void 0 : _d.call(_c2, ev.availableDevices.filter((d2) => d2.kind === "audioinput"));
    (_f = (_e2 = this._callbacks).onAvailableSpeakersUpdated) == null ? void 0 : _f.call(_e2, ev.availableDevices.filter((d2) => d2.kind === "audiooutput"));
  }
  handleSelectedDevicesUpdated(ev) {
    var _a3, _b, _c2, _d, _e2, _f, _g, _h, _i;
    if (((_a3 = this._selectedCam) == null ? void 0 : _a3.deviceId) !== ev.devices.camera) {
      this._selectedCam = ev.devices.camera;
      (_c2 = (_b = this._callbacks).onCamUpdated) == null ? void 0 : _c2.call(_b, ev.devices.camera);
    }
    if (((_d = this._selectedMic) == null ? void 0 : _d.deviceId) !== ev.devices.mic) {
      this._selectedMic = ev.devices.mic;
      (_f = (_e2 = this._callbacks).onMicUpdated) == null ? void 0 : _f.call(_e2, ev.devices.mic);
    }
    if (((_g = this._selectedSpeaker) == null ? void 0 : _g.deviceId) !== ev.devices.speaker) {
      this._selectedSpeaker = ev.devices.speaker;
      (_i = (_h = this._callbacks).onSpeakerUpdated) == null ? void 0 : _i.call(_h, ev.devices.speaker);
    }
  }
  handleDeviceError(ev) {
    var _a3, _b;
    const generateDeviceError = (error) => {
      const devices = [];
      switch (error.type) {
        case "permissions":
          error.blockedMedia.forEach((d2) => {
            devices.push(d2 === "video" ? "cam" : "mic");
          });
          return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg, {
            blockedBy: error.blockedBy
          });
        case "not-found":
          error.missingMedia.forEach((d2) => {
            devices.push(d2 === "video" ? "cam" : "mic");
          });
          return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg);
        case "constraints":
          error.failedMedia.forEach((d2) => {
            devices.push(d2 === "video" ? "cam" : "mic");
          });
          return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg, {
            reason: error.reason
          });
        case "cam-in-use":
          devices.push("cam");
          return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, "in-use", error.msg);
        case "mic-in-use":
          devices.push("mic");
          return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, "in-use", error.msg);
        case "cam-mic-in-use":
          devices.push("cam");
          devices.push("mic");
          return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, "in-use", error.msg);
        case "undefined-mediadevices":
        case "unknown":
        default:
          devices.push("cam");
          devices.push("mic");
          return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg);
      }
    };
    (_b = (_a3 = this._callbacks).onDeviceError) == null ? void 0 : _b.call(_a3, generateDeviceError(ev.error));
  }
  async handleLocalAudioTrack(track2) {
    if (this.state == "ready" || !this._bufferLocalAudioUntilBotReady) return;
    const status = this._mediaStreamRecorder.getStatus();
    switch (status) {
      case "ended":
        try {
          await this._mediaStreamRecorder.begin(track2);
          await this.startRecording();
        } catch (e2) {
        }
        break;
      case "paused":
        await this.startRecording();
        break;
      case "recording":
      default:
        if (this._currentAudioTrack !== track2) try {
          await this._mediaStreamRecorder.end();
          await this._mediaStreamRecorder.begin(track2);
          await this.startRecording();
        } catch (e2) {
        }
        else (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn("track-started event received for current track and already recording");
        break;
    }
    this._currentAudioTrack = track2;
  }
  handleTrackStarted(ev) {
    var _a3, _b, _c2, _d, _e2;
    if (ev.type === "screenAudio" || ev.type === "screenVideo") (_b = (_a3 = this._callbacks).onScreenTrackStarted) == null ? void 0 : _b.call(_a3, ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
    else {
      if (((_c2 = ev.participant) == null ? void 0 : _c2.local) && ev.track.kind === "audio") this.handleLocalAudioTrack(ev.track);
      (_e2 = (_d = this._callbacks).onTrackStarted) == null ? void 0 : _e2.call(_d, ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
    }
  }
  handleTrackStopped(ev) {
    var _a3, _b, _c2, _d;
    if (ev.type === "screenAudio" || ev.type === "screenVideo") (_b = (_a3 = this._callbacks).onScreenTrackStopped) == null ? void 0 : _b.call(_a3, ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
    else (_d = (_c2 = this._callbacks).onTrackStopped) == null ? void 0 : _d.call(_c2, ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
  }
  handleParticipantJoined(ev) {
    var _a3, _b, _c2, _d;
    const p2 = $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant);
    (_b = (_a3 = this._callbacks).onParticipantJoined) == null ? void 0 : _b.call(_a3, p2);
    if (p2.local) return;
    this._botId = ev.participant.session_id;
    (_d = (_c2 = this._callbacks).onBotConnected) == null ? void 0 : _d.call(_c2, p2);
  }
  handleParticipantLeft(ev) {
    var _a3, _b, _c2, _d;
    const p2 = $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant);
    (_b = (_a3 = this._callbacks).onParticipantLeft) == null ? void 0 : _b.call(_a3, p2);
    if (p2.local) return;
    this._botId = "";
    (_d = (_c2 = this._callbacks).onBotDisconnected) == null ? void 0 : _d.call(_c2, p2);
  }
  handleLocalAudioLevel(ev) {
    var _a3, _b;
    (_b = (_a3 = this._callbacks).onLocalAudioLevel) == null ? void 0 : _b.call(_a3, ev.audioLevel);
  }
  handleRemoteAudioLevel(ev) {
    var _a3, _b;
    const participants = this._daily.participants();
    const ids = Object.keys(ev.participantsAudioLevel);
    for (let i2 = 0; i2 < ids.length; i2++) {
      const id = ids[i2];
      const level = ev.participantsAudioLevel[id];
      (_b = (_a3 = this._callbacks).onRemoteAudioLevel) == null ? void 0 : _b.call(_a3, level, $683f111f61e07358$var$dailyParticipantToParticipant(participants[id]));
    }
  }
  handleLeftMeeting() {
    var _a3, _b;
    this.state = "disconnected";
    this._botId = "";
    (_b = (_a3 = this._callbacks).onDisconnected) == null ? void 0 : _b.call(_a3);
  }
  handleFatalError(ev) {
    var _a3, _b;
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).error("Daily fatal error", ev.errorMsg);
    this.state = "error";
    this._botId = "";
    (_b = (_a3 = this._callbacks).onError) == null ? void 0 : _b.call(_a3, (0, $c0d10c4690969999$export$69aa9ab0334b212).error(ev.errorMsg, true));
  }
  handleNonFatalError(ev) {
    var _a3, _b;
    switch (ev.type) {
      case "screen-share-error":
        (_b = (_a3 = this._callbacks).onScreenShareError) == null ? void 0 : _b.call(_a3, ev.errorMsg);
        break;
    }
  }
};
$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE = 16e3;
$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_CHUNK_SIZE = 512;
var $683f111f61e07358$var$dailyParticipantToParticipant = (p2) => ({
  id: p2.user_id,
  local: p2.local,
  name: p2.user_name
});

// node_modules/.pnpm/@pipecat-ai+small-webrtc-transport@1.4.0_@pipecat-ai+client-js@1.3.0/node_modules/@pipecat-ai/small-webrtc-transport/dist/index.module.js
var import_cloneDeep = __toESM(require_cloneDeep());
function $parcel$export2(e2, n2, v2, s2) {
  Object.defineProperty(e2, n2, { get: v2, set: s2, enumerable: true, configurable: true });
}
var $6d4b7449a1e1544a$export$13afda237b1c98462 = class {
  /**
  * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format
  * @param {Float32Array} float32Array
  * @returns {ArrayBuffer}
  */
  static floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset2 = 0;
    for (let i2 = 0; i2 < float32Array.length; i2++, offset2 += 2) {
      let s2 = Math.max(-1, Math.min(1, float32Array[i2]));
      view.setInt16(offset2, s2 < 0 ? s2 * 32768 : s2 * 32767, true);
    }
    return buffer;
  }
  /**
  * Concatenates two ArrayBuffers
  * @param {ArrayBuffer} leftBuffer
  * @param {ArrayBuffer} rightBuffer
  * @returns {ArrayBuffer}
  */
  static mergeBuffers(leftBuffer, rightBuffer) {
    const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);
    tmpArray.set(new Uint8Array(leftBuffer), 0);
    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);
    return tmpArray.buffer;
  }
  /**
  * Packs data into an Int16 format
  * @private
  * @param {number} size 0 = 1x Int16, 1 = 2x Int16
  * @param {number} arg value to pack
  * @returns
  */
  _packData(size2, arg) {
    return [
      new Uint8Array([
        arg,
        arg >> 8
      ]),
      new Uint8Array([
        arg,
        arg >> 8,
        arg >> 16,
        arg >> 24
      ])
    ][size2];
  }
  /**
  * Packs audio into "audio/wav" Blob
  * @param {number} sampleRate
  * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio
  * @returns {WavPackerAudioType}
  */
  pack(sampleRate, audio) {
    if (!(audio == null ? void 0 : audio.bitsPerSample)) throw new Error(`Missing "bitsPerSample"`);
    else if (!(audio == null ? void 0 : audio.channels)) throw new Error(`Missing "channels"`);
    else if (!(audio == null ? void 0 : audio.data)) throw new Error(`Missing "data"`);
    const { bitsPerSample, channels, data } = audio;
    const output = [
      // Header
      "RIFF",
      this._packData(1, 52),
      "WAVE",
      // chunk 1
      "fmt ",
      this._packData(1, 16),
      this._packData(0, 1),
      this._packData(0, channels.length),
      this._packData(1, sampleRate),
      this._packData(1, sampleRate * channels.length * bitsPerSample / 8),
      this._packData(0, channels.length * bitsPerSample / 8),
      this._packData(0, bitsPerSample),
      // chunk 2
      "data",
      this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),
      data
    ];
    const blob = new Blob(output, {
      type: "audio/mpeg"
    });
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      channelCount: channels.length,
      sampleRate,
      duration: data.byteLength / (channels.length * sampleRate * 2)
    };
  }
};
globalThis.WavPacker = $6d4b7449a1e1544a$export$13afda237b1c98462;
var $03f71ce85e00ada6$var$octave8Frequencies2 = [
  4186.01,
  4434.92,
  4698.63,
  4978.03,
  5274.04,
  5587.65,
  5919.91,
  6271.93,
  6644.88,
  7040,
  7458.62,
  7902.13
];
var $03f71ce85e00ada6$var$octave8FrequencyLabels2 = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
var $03f71ce85e00ada6$export$776c63898ae5b6362 = [];
var $03f71ce85e00ada6$export$facd167cc27ea9b02 = [];
for (let i2 = 1; i2 <= 8; i2++) for (let f2 = 0; f2 < $03f71ce85e00ada6$var$octave8Frequencies2.length; f2++) {
  const freq = $03f71ce85e00ada6$var$octave8Frequencies2[f2];
  $03f71ce85e00ada6$export$776c63898ae5b6362.push(freq / Math.pow(2, 8 - i2));
  $03f71ce85e00ada6$export$facd167cc27ea9b02.push($03f71ce85e00ada6$var$octave8FrequencyLabels2[f2] + i2);
}
var $03f71ce85e00ada6$var$voiceFrequencyRange2 = [
  32,
  2e3
];
var $03f71ce85e00ada6$export$dbc1581ed2cfa1832 = $03f71ce85e00ada6$export$776c63898ae5b6362.filter((_2, i2) => {
  return $03f71ce85e00ada6$export$776c63898ae5b6362[i2] > $03f71ce85e00ada6$var$voiceFrequencyRange2[0] && $03f71ce85e00ada6$export$776c63898ae5b6362[i2] < $03f71ce85e00ada6$var$voiceFrequencyRange2[1];
});
var $03f71ce85e00ada6$export$30a6f2881311088f2 = $03f71ce85e00ada6$export$facd167cc27ea9b02.filter((_2, i2) => {
  return $03f71ce85e00ada6$export$776c63898ae5b6362[i2] > $03f71ce85e00ada6$var$voiceFrequencyRange2[0] && $03f71ce85e00ada6$export$776c63898ae5b6362[i2] < $03f71ce85e00ada6$var$voiceFrequencyRange2[1];
});
var $f32f064564ee62f6$export$2c3136da0bf130f92 = class _$f32f064564ee62f6$export$2c3136da0bf130f9 {
  /**
  * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range
  * returns human-readable formatting and labels
  * @param {AnalyserNode} analyser
  * @param {number} sampleRate
  * @param {Float32Array} [fftResult]
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  static getFrequencies(analyser, sampleRate, fftResult, analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!fftResult) {
      fftResult = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(fftResult);
    }
    const nyquistFrequency = sampleRate / 2;
    const frequencyStep = 1 / fftResult.length * nyquistFrequency;
    let outputValues;
    let frequencies;
    let labels;
    if (analysisType === "music" || analysisType === "voice") {
      const useFrequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa1832) : (0, $03f71ce85e00ada6$export$776c63898ae5b6362);
      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);
      for (let i2 = 0; i2 < fftResult.length; i2++) {
        const frequency = i2 * frequencyStep;
        const amplitude = fftResult[i2];
        for (let n2 = useFrequencies.length - 1; n2 >= 0; n2--) if (frequency > useFrequencies[n2]) {
          aggregateOutput[n2] = Math.max(aggregateOutput[n2], amplitude);
          break;
        }
      }
      outputValues = aggregateOutput;
      frequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa1832) : (0, $03f71ce85e00ada6$export$776c63898ae5b6362);
      labels = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$30a6f2881311088f2) : (0, $03f71ce85e00ada6$export$facd167cc27ea9b02);
    } else {
      outputValues = Array.from(fftResult);
      frequencies = outputValues.map((_2, i2) => frequencyStep * i2);
      labels = frequencies.map((f2) => `${f2.toFixed(2)} Hz`);
    }
    const normalizedOutput = outputValues.map((v2) => {
      return Math.max(0, Math.min((v2 - minDecibels) / (maxDecibels - minDecibels), 1));
    });
    const values = new Float32Array(normalizedOutput);
    return {
      values,
      frequencies,
      labels
    };
  }
  /**
  * Creates a new AudioAnalysis instance for an HTMLAudioElement
  * @param {HTMLAudioElement} audioElement
  * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer
  * @returns {AudioAnalysis}
  */
  constructor(audioElement, audioBuffer = null) {
    this.fftResults = [];
    if (audioBuffer) {
      const { length, sampleRate } = audioBuffer;
      const offlineAudioContext = new OfflineAudioContext({
        length,
        sampleRate
      });
      const source = offlineAudioContext.createBufferSource();
      source.buffer = audioBuffer;
      const analyser = offlineAudioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      source.connect(analyser);
      const renderQuantumInSeconds = 1 / 60;
      const durationInSeconds = length / sampleRate;
      const analyze = (index2) => {
        const suspendTime = renderQuantumInSeconds * index2;
        if (suspendTime < durationInSeconds) offlineAudioContext.suspend(suspendTime).then(() => {
          const fftResult = new Float32Array(analyser.frequencyBinCount);
          analyser.getFloatFrequencyData(fftResult);
          this.fftResults.push(fftResult);
          analyze(index2 + 1);
        });
        if (index2 === 1) offlineAudioContext.startRendering();
        else offlineAudioContext.resume();
      };
      source.start(0);
      analyze(1);
      this.audio = audioElement;
      this.context = offlineAudioContext;
      this.analyser = analyser;
      this.sampleRate = sampleRate;
      this.audioBuffer = audioBuffer;
    } else {
      const audioContext = new AudioContext();
      const track2 = audioContext.createMediaElementSource(audioElement);
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      track2.connect(analyser);
      analyser.connect(audioContext.destination);
      this.audio = audioElement;
      this.context = audioContext;
      this.analyser = analyser;
      this.sampleRate = this.context.sampleRate;
      this.audioBuffer = null;
    }
  }
  /**
  * Gets the current frequency domain data from the playing audio track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    let fftResult = null;
    if (this.audioBuffer && this.fftResults.length) {
      const pct = this.audio.currentTime / this.audio.duration;
      const index2 = Math.min(pct * this.fftResults.length | 0, this.fftResults.length - 1);
      fftResult = this.fftResults[index2];
    }
    return _$f32f064564ee62f6$export$2c3136da0bf130f9.getFrequencies(this.analyser, this.sampleRate, fftResult, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Resume the internal AudioContext if it was suspended due to the lack of
  * user interaction when the AudioAnalysis was instantiated.
  * @returns {Promise<true>}
  */
  async resumeIfSuspended() {
    if (this.context.state === "suspended") await this.context.resume();
    return true;
  }
};
globalThis.AudioAnalysis = $f32f064564ee62f6$export$2c3136da0bf130f92;
var $29a8a70a9466b14f$export$50b76700e2b15e92 = `
class StreamProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.hasStarted = false;
    this.hasInterrupted = false;
    this.outputBuffers = [];
    this.bufferLength = 128;
    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };
    this.writeOffset = 0;
    this.trackSampleOffsets = {};
    this.port.onmessage = (event) => {
      if (event.data) {
        const payload = event.data;
        if (payload.event === 'write') {
          const int16Array = payload.buffer;
          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32
          }
          this.writeData(float32Array, payload.trackId);
        } else if (
          payload.event === 'offset' ||
          payload.event === 'interrupt'
        ) {
          const requestId = payload.requestId;
          const trackId = this.write.trackId;
          const offset = this.trackSampleOffsets[trackId] || 0;
          this.port.postMessage({
            event: 'offset',
            requestId,
            trackId,
            offset,
          });
          if (payload.event === 'interrupt') {
            this.hasInterrupted = true;
          }
        } else {
          throw new Error(\`Unhandled event "\${payload.event}"\`);
        }
      }
    };
  }

  writeData(float32Array, trackId = null) {
    let { buffer } = this.write;
    let offset = this.writeOffset;
    for (let i = 0; i < float32Array.length; i++) {
      buffer[offset++] = float32Array[i];
      if (offset >= buffer.length) {
        this.outputBuffers.push(this.write);
        this.write = { buffer: new Float32Array(this.bufferLength), trackId };
        buffer = this.write.buffer;
        offset = 0;
      }
    }
    this.writeOffset = offset;
    return true;
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const outputChannelData = output[0];
    const outputBuffers = this.outputBuffers;
    if (this.hasInterrupted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else if (outputBuffers.length) {
      this.hasStarted = true;
      const { buffer, trackId } = outputBuffers.shift();
      for (let i = 0; i < outputChannelData.length; i++) {
        outputChannelData[i] = buffer[i] || 0;
      }
      if (trackId) {
        this.trackSampleOffsets[trackId] =
          this.trackSampleOffsets[trackId] || 0;
        this.trackSampleOffsets[trackId] += buffer.length;
      }
      return true;
    } else if (this.hasStarted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else {
      return true;
    }
  }
}

registerProcessor('stream_processor', StreamProcessor);
`;
var $29a8a70a9466b14f$var$script2 = new Blob([
  $29a8a70a9466b14f$export$50b76700e2b15e92
], {
  type: "application/javascript"
});
var $29a8a70a9466b14f$var$src2 = URL.createObjectURL($29a8a70a9466b14f$var$script2);
var $29a8a70a9466b14f$export$bfa8c596114d74df2 = $29a8a70a9466b14f$var$src2;
var $d0a969833958d9e7$export$9698d62c78b8f3662 = class {
  /**
  * Creates a new WavStreamPlayer instance
  * @param {{sampleRate?: number}} options
  * @returns {WavStreamPlayer}
  */
  constructor({ sampleRate = 44100 } = {}) {
    this.scriptSrc = (0, $29a8a70a9466b14f$export$bfa8c596114d74df2);
    this.sampleRate = sampleRate;
    this.context = null;
    this.stream = null;
    this.analyser = null;
    this.trackSampleOffsets = {};
    this.interruptedTrackIds = {};
  }
  /**
  * Connects the audio context and enables output to speakers
  * @returns {Promise<true>}
  */
  async connect() {
    this.context = new AudioContext({
      sampleRate: this.sampleRate
    });
    if (this._speakerID) this.context.setSinkId(this._speakerID);
    if (this.context.state === "suspended") await this.context.resume();
    try {
      await this.context.audioWorklet.addModule(this.scriptSrc);
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const analyser = this.context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    this.analyser = analyser;
    return true;
  }
  /**
  * Gets the current frequency domain data from the playing track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.analyser) throw new Error("Not connected, please call .connect() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f92).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * @param {string} speaker deviceId
  */
  async updateSpeaker(speaker) {
    const _prevSpeaker = this._speakerID;
    this._speakerID = speaker;
    if (this.context) try {
      if (speaker === "default") await this.context.setSinkId();
      else await this.context.setSinkId(speaker);
    } catch (e2) {
      console.error(`Could not set sinkId to ${speaker}: ${e2}`);
      this._speakerID = _prevSpeaker;
    }
  }
  /**
  * Starts audio streaming
  * @private
  * @returns {Promise<true>}
  */
  _start() {
    const streamNode = new AudioWorkletNode(this.context, "stream_processor");
    streamNode.connect(this.context.destination);
    streamNode.port.onmessage = (e2) => {
      const { event } = e2.data;
      if (event === "stop") {
        streamNode.disconnect();
        this.stream = null;
      } else if (event === "offset") {
        const { requestId, trackId, offset: offset2 } = e2.data;
        const currentTime = offset2 / this.sampleRate;
        this.trackSampleOffsets[requestId] = {
          trackId,
          offset: offset2,
          currentTime
        };
      }
    };
    this.analyser.disconnect();
    streamNode.connect(this.analyser);
    this.stream = streamNode;
    return true;
  }
  /**
  * Adds 16BitPCM data to the currently playing audio stream
  * You can add chunks beyond the current play point and they will be queued for play
  * @param {ArrayBuffer|Int16Array} arrayBuffer
  * @param {string} [trackId]
  * @returns {Int16Array}
  */
  add16BitPCM(arrayBuffer, trackId = "default") {
    if (typeof trackId !== "string") throw new Error(`trackId must be a string`);
    else if (this.interruptedTrackIds[trackId]) return;
    if (!this.stream) this._start();
    let buffer;
    if (arrayBuffer instanceof Int16Array) buffer = arrayBuffer;
    else if (arrayBuffer instanceof ArrayBuffer) buffer = new Int16Array(arrayBuffer);
    else throw new Error(`argument must be Int16Array or ArrayBuffer`);
    this.stream.port.postMessage({
      event: "write",
      buffer,
      trackId
    });
    return buffer;
  }
  /**
  * Gets the offset (sample count) of the currently playing stream
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async getTrackSampleOffset(interrupt = false) {
    if (!this.stream) return null;
    const requestId = crypto.randomUUID();
    this.stream.port.postMessage({
      event: interrupt ? "interrupt" : "offset",
      requestId
    });
    let trackSampleOffset;
    while (!trackSampleOffset) {
      trackSampleOffset = this.trackSampleOffsets[requestId];
      await new Promise((r3) => setTimeout(() => r3(), 1));
    }
    const { trackId } = trackSampleOffset;
    if (interrupt && trackId) this.interruptedTrackIds[trackId] = true;
    return trackSampleOffset;
  }
  /**
  * Strips the current stream and returns the sample offset of the audio
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async interrupt() {
    return this.getTrackSampleOffset(true);
  }
};
globalThis.WavStreamPlayer = $d0a969833958d9e7$export$9698d62c78b8f3662;
var $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet2 = `
class AudioProcessor extends AudioWorkletProcessor {

  constructor() {
    super();
    this.port.onmessage = this.receive.bind(this);
    this.initialize();
  }

  initialize() {
    this.foundAudio = false;
    this.recording = false;
    this.chunks = [];
  }

  /**
   * Concatenates sampled chunks into channels
   * Format is chunk[Left[], Right[]]
   */
  readChannelData(chunks, channel = -1, maxChannels = 9) {
    let channelLimit;
    if (channel !== -1) {
      if (chunks[0] && chunks[0].length - 1 < channel) {
        throw new Error(
          \`Channel \${channel} out of range: max \${chunks[0].length}\`
        );
      }
      channelLimit = channel + 1;
    } else {
      channel = 0;
      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);
    }
    const channels = [];
    for (let n = channel; n < channelLimit; n++) {
      const length = chunks.reduce((sum, chunk) => {
        return sum + chunk[n].length;
      }, 0);
      const buffers = chunks.map((chunk) => chunk[n]);
      const result = new Float32Array(length);
      let offset = 0;
      for (let i = 0; i < buffers.length; i++) {
        result.set(buffers[i], offset);
        offset += buffers[i].length;
      }
      channels[n] = result;
    }
    return channels;
  }

  /**
   * Combines parallel audio data into correct format,
   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]
   */
  formatAudioData(channels) {
    if (channels.length === 1) {
      // Simple case is only one channel
      const float32Array = channels[0].slice();
      const meanValues = channels[0].slice();
      return { float32Array, meanValues };
    } else {
      const float32Array = new Float32Array(
        channels[0].length * channels.length
      );
      const meanValues = new Float32Array(channels[0].length);
      for (let i = 0; i < channels[0].length; i++) {
        const offset = i * channels.length;
        let meanValue = 0;
        for (let n = 0; n < channels.length; n++) {
          float32Array[offset + n] = channels[n][i];
          meanValue += channels[n][i];
        }
        meanValues[i] = meanValue / channels.length;
      }
      return { float32Array, meanValues };
    }
  }

  /**
   * Converts 32-bit float data to 16-bit integers
   */
  floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < float32Array.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
    return buffer;
  }

  /**
   * Retrieves the most recent amplitude values from the audio stream
   * @param {number} channel
   */
  getValues(channel = -1) {
    const channels = this.readChannelData(this.chunks, channel);
    const { meanValues } = this.formatAudioData(channels);
    return { meanValues, channels };
  }

  /**
   * Exports chunks as an audio/wav file
   */
  export() {
    const channels = this.readChannelData(this.chunks);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const audioData = this.floatTo16BitPCM(float32Array);
    return {
      meanValues: meanValues,
      audio: {
        bitsPerSample: 16,
        channels: channels,
        data: audioData,
      },
    };
  }

  receive(e) {
    const { event, id } = e.data;
    let receiptData = {};
    switch (event) {
      case 'start':
        this.recording = true;
        break;
      case 'stop':
        this.recording = false;
        break;
      case 'clear':
        this.initialize();
        break;
      case 'export':
        receiptData = this.export();
        break;
      case 'read':
        receiptData = this.getValues();
        break;
      default:
        break;
    }
    // Always send back receipt
    this.port.postMessage({ event: 'receipt', id, data: receiptData });
  }

  sendChunk(chunk) {
    const channels = this.readChannelData([chunk]);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const rawAudioData = this.floatTo16BitPCM(float32Array);
    const monoAudioData = this.floatTo16BitPCM(meanValues);
    this.port.postMessage({
      event: 'chunk',
      data: {
        mono: monoAudioData,
        raw: rawAudioData,
      },
    });
  }

  process(inputList, outputList, parameters) {
    // Copy input to output (e.g. speakers)
    // Note that this creates choppy sounds with Mac products
    const sourceLimit = Math.min(inputList.length, outputList.length);
    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {
      const input = inputList[inputNum];
      const output = outputList[inputNum];
      const channelCount = Math.min(input.length, output.length);
      for (let channelNum = 0; channelNum < channelCount; channelNum++) {
        input[channelNum].forEach((sample, i) => {
          output[channelNum][i] = sample;
        });
      }
    }
    const inputs = inputList[0];
    // There's latency at the beginning of a stream before recording starts
    // Make sure we actually receive audio data before we start storing chunks
    let sliceIndex = 0;
    if (!this.foundAudio) {
      for (const channel of inputs) {
        sliceIndex = 0; // reset for each channel
        if (this.foundAudio) {
          break;
        }
        if (channel) {
          for (const value of channel) {
            if (value !== 0) {
              // find only one non-zero entry in any channel
              this.foundAudio = true;
              break;
            } else {
              sliceIndex++;
            }
          }
        }
      }
    }
    if (inputs && inputs[0] && this.foundAudio && this.recording) {
      // We need to copy the TypedArray, because the \`process\`
      // internals will reuse the same buffer to hold each input
      const chunk = inputs.map((input) => input.slice(sliceIndex));
      this.chunks.push(chunk);
      this.sendChunk(chunk);
    }
    return true;
  }
}

registerProcessor('audio_processor', AudioProcessor);
`;
var $8e1d1e6ff08f6fb5$var$script2 = new Blob([
  $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet2
], {
  type: "application/javascript"
});
var $8e1d1e6ff08f6fb5$var$src2 = URL.createObjectURL($8e1d1e6ff08f6fb5$var$script2);
var $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c2 = $8e1d1e6ff08f6fb5$var$src2;
var $62bc376044a05513$export$439b217ca659a8772 = class {
  /**
  * Create a new WavRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {WavRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c2);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this._deviceChangeCallback = null;
    this._deviceErrorCallback = null;
    this._devices = [];
    this.deviceSelection = null;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer
  * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData
  * @param {number} sampleRate
  * @param {number} fromSampleRate
  * @returns {Promise<DecodedAudioType>}
  */
  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {
    const context = new AudioContext({
      sampleRate
    });
    let arrayBuffer;
    let blob;
    if (audioData instanceof Blob) {
      if (fromSampleRate !== -1) throw new Error(`Can not specify "fromSampleRate" when reading from Blob`);
      blob = audioData;
      arrayBuffer = await blob.arrayBuffer();
    } else if (audioData instanceof ArrayBuffer) {
      if (fromSampleRate !== -1) throw new Error(`Can not specify "fromSampleRate" when reading from ArrayBuffer`);
      arrayBuffer = audioData;
      blob = new Blob([
        arrayBuffer
      ], {
        type: "audio/wav"
      });
    } else {
      let float32Array;
      let data;
      if (audioData instanceof Int16Array) {
        data = audioData;
        float32Array = new Float32Array(audioData.length);
        for (let i2 = 0; i2 < audioData.length; i2++) float32Array[i2] = audioData[i2] / 32768;
      } else if (audioData instanceof Float32Array) float32Array = audioData;
      else if (audioData instanceof Array) float32Array = new Float32Array(audioData);
      else throw new Error(`"audioData" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);
      if (fromSampleRate === -1) throw new Error(`Must specify "fromSampleRate" when reading from Float32Array, In16Array or Array`);
      else if (fromSampleRate < 3e3) throw new Error(`Minimum "fromSampleRate" is 3000 (3kHz)`);
      if (!data) data = (0, $6d4b7449a1e1544a$export$13afda237b1c98462).floatTo16BitPCM(float32Array);
      const audio = {
        bitsPerSample: 16,
        channels: [
          float32Array
        ],
        data
      };
      const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
      const result = packer.pack(fromSampleRate, audio);
      blob = result.blob;
      arrayBuffer = await blob.arrayBuffer();
    }
    const audioBuffer = await context.decodeAudioData(arrayBuffer);
    const values = audioBuffer.getChannelData(0);
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      values,
      audioBuffer
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug) this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor) return "ended";
    else if (!this.recording) return "paused";
    else return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor) throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Sets device change callback, remove if callback provided is `null`
  * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback
  * @returns {true}
  */
  listenForDeviceChange(callback2) {
    if (callback2 === null && this._deviceChangeCallback) {
      navigator.mediaDevices.removeEventListener("devicechange", this._deviceChangeCallback);
      this._deviceChangeCallback = null;
    } else if (callback2 !== null) {
      let lastId = 0;
      let lastDevices = [];
      const serializeDevices = (devices) => devices.map((d2) => d2.deviceId).sort().join(",");
      const cb = async () => {
        let id = ++lastId;
        const devices = await this.listDevices();
        if (id === lastId) {
          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {
            lastDevices = devices;
            callback2(devices.slice());
          }
        }
      };
      navigator.mediaDevices.addEventListener("devicechange", cb);
      cb();
      this._deviceChangeCallback = cb;
    }
    return true;
  }
  /**
  * Provide a callback for if/when device errors occur
  * @param {(({devices: Array<"cam" | "mic">, type: string, error?: Error}) => void) | null} callback
  * @returns {true}
  */
  listenForDeviceErrors(callback2) {
    this._deviceErrorCallback = callback2;
  }
  /**
  * Manually request permission to use the microphone
  * @returns {Promise<true>}
  */
  async requestPermission() {
    const permissionStatus = await navigator.permissions.query({
      name: "microphone"
    });
    if (permissionStatus.state === "denied") {
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic"
        ],
        type: "unknown",
        error: new Error("Microphone access denied")
      });
    } else if (permissionStatus.state === "prompt") try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true
      });
      const tracks = stream.getTracks();
      tracks.forEach((track2) => track2.stop());
    } catch (e2) {
      console.error("Error accessing microphone.");
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic"
        ],
        type: "unknown",
        error: e2
      });
    }
    return true;
  }
  /**
  * List all eligible devices for recording, will request permission to use microphone
  * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}
  */
  async listDevices() {
    if (!navigator.mediaDevices || !("enumerateDevices" in navigator.mediaDevices)) throw new Error("Could not request user devices");
    await this.requestPermission();
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioDevices = devices.filter((device) => device.kind === "audioinput");
    return audioDevices;
  }
  /**
  * Begins a recording session and requests microphone permissions if not already granted
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {string} [deviceId] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(deviceId) {
    var _a3;
    if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);
    if (!navigator.mediaDevices || !("getUserMedia" in navigator.mediaDevices)) {
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic",
          "cam"
        ],
        type: "undefined-mediadevices"
      });
      throw new Error("Could not request user media");
    }
    deviceId = deviceId ?? ((_a3 = this.deviceSelection) == null ? void 0 : _a3.deviceId);
    try {
      const config = {
        audio: true
      };
      if (deviceId) config.audio = {
        deviceId: {
          exact: deviceId
        }
      };
      this.stream = await navigator.mediaDevices.getUserMedia(config);
    } catch (err) {
      if (this._deviceErrorCallback) this._deviceErrorCallback({
        devices: [
          "mic"
        ],
        type: "unknown",
        error: err
      });
      throw new Error("Could not start media stream");
    }
    this.listDevices().then((devices) => {
      deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;
      console.log("find current device", devices, deviceId, this.stream.getAudioTracks()[0].getSettings());
      this.deviceSelection = devices.find((d2) => d2.deviceId === deviceId);
      console.log("current device", this.deviceSelection);
    });
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e2) => {
      const { event, id, data } = e2.data;
      if (event === "receipt") this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    console.log("begin completed");
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f92).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (!this.recording) throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (this.recording) throw new Error("Already recording: please call .pause() first");
    else if (typeof chunkProcessor !== "function") throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording) throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    const tracks = this.stream.getTracks();
    tracks.forEach((track2) => track2.stop());
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    this.deviceSelection = null;
    if (this.processor) await this.end();
    return true;
  }
};
globalThis.WavRecorder = $62bc376044a05513$export$439b217ca659a8772;
var $5fc11d7bc0d20724$export$2934cf2d25c67a482 = class {
  /**
  * Create a new MediaStreamRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {MediaStreamRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c2);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug) this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor) return "ended";
    else if (!this.recording) return "paused";
    else return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor) throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Begins a recording session for the given audioTrack
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(audioTrack) {
    if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);
    if (!audioTrack || audioTrack.kind !== "audio") throw new Error("No audio track provided");
    this.stream = new MediaStream([
      audioTrack
    ]);
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e2) => {
      const { event, id, data } = e2.data;
      if (event === "receipt") this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f92).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (!this.recording) throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    else if (this.recording) throw new Error("Already recording: HELLO please call .pause() first");
    else if (typeof chunkProcessor !== "function") throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording) throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor) throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    if (this.processor) await this.end();
    return true;
  }
};
globalThis.WavRecorder = WavRecorder;
var $fc49a56cd8739127$var$__extends = /* @__PURE__ */ (function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null) throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
})();
var $fc49a56cd8739127$var$__awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $fc49a56cd8739127$var$__generator = function(thisArg, body) {
  var _2 = {
    label: 0,
    sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([
        n2,
        v2
      ]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [
        op[0] & 2,
        t2.value
      ];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [
            0
          ];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [
        6,
        e2
      ];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var $fc49a56cd8739127$export$4a0c46dbbe2ddb67 = (
  /** @class */
  (function() {
    function MediaManager() {
      this._callbacks = {};
      this._micEnabled = true;
      this._camEnabled = false;
      this._supportsScreenShare = false;
    }
    MediaManager.prototype.setUserAudioCallback = function(userAudioCallback) {
      this._userAudioCallback = userAudioCallback;
    };
    MediaManager.prototype.setClientOptions = function(options, override) {
      var _a3, _b, _c2;
      if (override === void 0) override = false;
      if (this._options && !override) return;
      this._options = options;
      this._callbacks = (_a3 = options.callbacks) !== null && _a3 !== void 0 ? _a3 : {};
      this._micEnabled = (_b = options.enableMic) !== null && _b !== void 0 ? _b : true;
      this._camEnabled = (_c2 = options.enableCam) !== null && _c2 !== void 0 ? _c2 : false;
    };
    Object.defineProperty(MediaManager.prototype, "supportsScreenShare", {
      get: function() {
        return this._supportsScreenShare;
      },
      enumerable: false,
      configurable: true
    });
    return MediaManager;
  })()
);
var $fc49a56cd8739127$export$45c5b9bfba2f6304 = (
  /** @class */
  (function(_super) {
    $fc49a56cd8739127$var$__extends(WavMediaManager, _super);
    function WavMediaManager(recorderChunkSize, recorderSampleRate) {
      if (recorderChunkSize === void 0) recorderChunkSize = void 0;
      if (recorderSampleRate === void 0) recorderSampleRate = 24e3;
      var _this = _super.call(this) || this;
      _this._initialized = false;
      _this._recorderChunkSize = void 0;
      _this._recorderChunkSize = recorderChunkSize;
      _this._wavRecorder = new (0, $62bc376044a05513$export$439b217ca659a8772)({
        sampleRate: recorderSampleRate
      });
      _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f3662)({
        sampleRate: 24e3
      });
      return _this;
    }
    WavMediaManager.prototype.initialize = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        var error_1;
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              _a3.trys.push([
                0,
                2,
                ,
                3
              ]);
              return [
                4,
                this._wavRecorder.begin()
              ];
            case 1:
              _a3.sent();
              return [
                3,
                3
              ];
            case 2:
              error_1 = _a3.sent();
              return [
                3,
                3
              ];
            case 3:
              this._wavRecorder.listenForDeviceChange(null);
              this._wavRecorder.listenForDeviceChange(this._handleAvailableDevicesUpdated.bind(this));
              this._wavRecorder.listenForDeviceErrors(null);
              this._wavRecorder.listenForDeviceErrors(this._handleDeviceError.bind(this));
              return [
                4,
                this._wavStreamPlayer.connect()
              ];
            case 4:
              _a3.sent();
              this._initialized = true;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.connect = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        var isAlreadyRecording;
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!!this._initialized) return [
                3,
                2
              ];
              return [
                4,
                this.initialize()
              ];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              isAlreadyRecording = this._wavRecorder.getStatus() == "recording";
              if (!(this._micEnabled && !isAlreadyRecording)) return [
                3,
                4
              ];
              return [
                4,
                this._startRecording()
              ];
            case 3:
              _a3.sent();
              _a3.label = 4;
            case 4:
              if (this._camEnabled) console.warn("WavMediaManager does not support video input.");
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.disconnect = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!this._initialized) return [
                2
                /*return*/
              ];
              return [
                4,
                this._wavRecorder.end()
              ];
            case 1:
              _a3.sent();
              return [
                4,
                this._wavStreamPlayer.interrupt()
              ];
            case 2:
              _a3.sent();
              this._initialized = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.userStartedSpeaking = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          return [
            2,
            this._wavStreamPlayer.interrupt()
          ];
        });
      });
    };
    WavMediaManager.prototype.bufferBotAudio = function(data, id) {
      return this._wavStreamPlayer.add16BitPCM(data, id);
    };
    WavMediaManager.prototype.getAllMics = function() {
      return this._wavRecorder.listDevices();
    };
    WavMediaManager.prototype.getAllCams = function() {
      return Promise.resolve([]);
    };
    WavMediaManager.prototype.getAllSpeakers = function() {
      return Promise.resolve([]);
    };
    WavMediaManager.prototype.updateMic = function(micId) {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        var prevMic, curMic, error_2;
        var _a3, _b;
        return $fc49a56cd8739127$var$__generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              prevMic = this._wavRecorder.deviceSelection;
              if (!(this._wavRecorder.getStatus() !== "ended")) return [
                3,
                2
              ];
              return [
                4,
                this._wavRecorder.end()
              ];
            case 1:
              _c2.sent();
              _c2.label = 2;
            case 2:
              _c2.trys.push([
                2,
                6,
                ,
                7
              ]);
              return [
                4,
                this._wavRecorder.begin(micId)
              ];
            case 3:
              _c2.sent();
              if (!this._micEnabled) return [
                3,
                5
              ];
              return [
                4,
                this._startRecording()
              ];
            case 4:
              _c2.sent();
              _c2.label = 5;
            case 5:
              curMic = this._wavRecorder.deviceSelection;
              if (curMic && prevMic && prevMic.label !== curMic.label) (_b = (_a3 = this._callbacks).onMicUpdated) === null || _b === void 0 || _b.call(_a3, curMic);
              return [
                3,
                7
              ];
            case 6:
              error_2 = _c2.sent();
              return [
                3,
                7
              ];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.updateCam = function(camId) {
    };
    WavMediaManager.prototype.updateSpeaker = function(speakerId) {
    };
    Object.defineProperty(WavMediaManager.prototype, "selectedMic", {
      get: function() {
        var _a3;
        return (_a3 = this._wavRecorder.deviceSelection) !== null && _a3 !== void 0 ? _a3 : {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "selectedCam", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "selectedSpeaker", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    WavMediaManager.prototype.enableMic = function(enable) {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        var _this = this;
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              this._micEnabled = enable;
              if (!this._wavRecorder.stream) return [
                2
                /*return*/
              ];
              this._wavRecorder.stream.getAudioTracks().forEach(function(track2) {
                var _a4, _b;
                track2.enabled = enable;
                if (!enable) (_b = (_a4 = _this._callbacks).onTrackStopped) === null || _b === void 0 || _b.call(_a4, track2, $fc49a56cd8739127$var$localParticipant());
              });
              if (!enable) return [
                3,
                2
              ];
              return [
                4,
                this._startRecording()
              ];
            case 1:
              _a3.sent();
              return [
                3,
                4
              ];
            case 2:
              return [
                4,
                this._wavRecorder.pause()
              ];
            case 3:
              _a3.sent();
              _a3.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.enableCam = function(enable) {
      console.warn("WavMediaManager does not support video input.");
    };
    WavMediaManager.prototype.enableScreenShare = function(enable) {
      console.warn("WavMediaManager does not support screen sharing.");
    };
    Object.defineProperty(WavMediaManager.prototype, "isCamEnabled", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "isMicEnabled", {
      get: function() {
        return this._micEnabled;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "isSharingScreen", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    WavMediaManager.prototype.tracks = function() {
      var _a3;
      var tracks = (_a3 = this._wavRecorder.stream) === null || _a3 === void 0 ? void 0 : _a3.getTracks()[0];
      return {
        local: tracks ? {
          audio: tracks
        } : {}
      };
    };
    WavMediaManager.prototype._startRecording = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, void 0, function() {
        var track2;
        var _this = this;
        var _a3, _b, _c2;
        return $fc49a56cd8739127$var$__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [
                4,
                this._wavRecorder.record(function(data) {
                  var _a4;
                  (_a4 = _this._userAudioCallback) === null || _a4 === void 0 || _a4.call(_this, data.mono);
                }, this._recorderChunkSize)
              ];
            case 1:
              _d.sent();
              track2 = (_a3 = this._wavRecorder.stream) === null || _a3 === void 0 ? void 0 : _a3.getAudioTracks()[0];
              if (track2) (_c2 = (_b = this._callbacks).onTrackStarted) === null || _c2 === void 0 || _c2.call(_b, track2, $fc49a56cd8739127$var$localParticipant());
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype._handleAvailableDevicesUpdated = function(devices) {
      var _a3, _b, _c2, _d;
      (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, devices.filter(function(d2) {
        return d2.kind === "videoinput";
      }));
      (_d = (_c2 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c2, devices.filter(function(d2) {
        return d2.kind === "audioinput";
      }));
      var defaultDevice = devices.find(function(d2) {
        return d2.deviceId === "default";
      });
      var currentDevice = this._wavRecorder.deviceSelection;
      if (currentDevice && (!devices.some(function(d2) {
        return d2.deviceId === currentDevice.deviceId;
      }) || currentDevice.deviceId === "default" && currentDevice.label !== (defaultDevice === null || defaultDevice === void 0 ? void 0 : defaultDevice.label))) this.updateMic("");
    };
    WavMediaManager.prototype._handleDeviceError = function(_a3) {
      var _b, _c2;
      var devices = _a3.devices, type = _a3.type, error = _a3.error;
      var deviceError = new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, type, error === null || error === void 0 ? void 0 : error.message, error ? {
        sourceError: error
      } : void 0);
      (_c2 = (_b = this._callbacks).onDeviceError) === null || _c2 === void 0 || _c2.call(_b, deviceError);
    };
    return WavMediaManager;
  })($fc49a56cd8739127$export$4a0c46dbbe2ddb67)
);
var $fc49a56cd8739127$var$localParticipant = function() {
  return {
    id: "local",
    name: "",
    local: true
  };
};
var $22ece045290c996a$var$__extends = /* @__PURE__ */ (function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null) throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
})();
var $22ece045290c996a$var$__awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $22ece045290c996a$var$__generator = function(thisArg, body) {
  var _2 = {
    label: 0,
    sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([
        n2,
        v2
      ]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [
        op[0] & 2,
        t2.value
      ];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [
            0
          ];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [
        6,
        e2
      ];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var $22ece045290c996a$export$c95c65abc5f47125 = (
  /** @class */
  (function(_super) {
    $22ece045290c996a$var$__extends(DailyMediaManager, _super);
    function DailyMediaManager(enablePlayer, enableRecording, onTrackStartedCallback, onTrackStoppedCallback, recorderChunkSize, recorderSampleRate, playerSampleRate) {
      if (enablePlayer === void 0) enablePlayer = true;
      if (enableRecording === void 0) enableRecording = true;
      if (recorderChunkSize === void 0) recorderChunkSize = void 0;
      if (recorderSampleRate === void 0) recorderSampleRate = 24e3;
      if (playerSampleRate === void 0) playerSampleRate = 24e3;
      var _a3;
      var _this = _super.call(this) || this;
      _this._selectedCam = {};
      _this._selectedMic = {};
      _this._selectedSpeaker = {};
      _this._remoteAudioLevelInterval = null;
      _this._recorderChunkSize = void 0;
      _this._initialized = false;
      _this._connected = false;
      _this._currentAudioTrack = null;
      _this._connectResolve = null;
      _this.onTrackStartedCallback = onTrackStartedCallback;
      _this.onTrackStoppedCallback = onTrackStoppedCallback;
      _this._recorderChunkSize = recorderChunkSize;
      _this._supportsScreenShare = true;
      _this._daily = (_a3 = (0, Ha).getCallInstance()) !== null && _a3 !== void 0 ? _a3 : (0, Ha).createCallObject();
      if (enableRecording) _this._mediaStreamRecorder = new (0, $5fc11d7bc0d20724$export$2934cf2d25c67a482)({
        sampleRate: recorderSampleRate
      });
      if (enablePlayer) _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f3662)({
        sampleRate: playerSampleRate
      });
      _this._daily.on("track-started", _this.handleTrackStarted.bind(_this));
      _this._daily.on("track-stopped", _this.handleTrackStopped.bind(_this));
      _this._daily.on("available-devices-updated", _this._handleAvailableDevicesUpdated.bind(_this));
      _this._daily.on("selected-devices-updated", _this._handleSelectedDevicesUpdated.bind(_this));
      _this._daily.on("camera-error", _this.handleDeviceError.bind(_this));
      _this._daily.on("local-audio-level", _this._handleLocalAudioLevel.bind(_this));
      return _this;
    }
    DailyMediaManager.prototype.initialize = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var infos, devices, cams, mics, speakers;
        var _this = this;
        var _a3, _b, _c2, _d, _e2, _f, _g, _h, _j, _k, _l, _m;
        return $22ece045290c996a$var$__generator(this, function(_o2) {
          switch (_o2.label) {
            case 0:
              if (this._initialized) {
                console.warn("DailyMediaManager already initialized");
                return [
                  2
                  /*return*/
                ];
              }
              return [
                4,
                this._daily.startCamera({
                  startVideoOff: !this._camEnabled,
                  startAudioOff: !this._micEnabled
                })
              ];
            case 1:
              infos = _o2.sent();
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 2:
              devices = _o2.sent().devices;
              cams = devices.filter(function(d2) {
                return d2.kind === "videoinput";
              });
              mics = devices.filter(function(d2) {
                return d2.kind === "audioinput";
              });
              speakers = devices.filter(function(d2) {
                return d2.kind === "audiooutput";
              });
              (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, cams);
              (_d = (_c2 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c2, mics);
              (_f = (_e2 = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e2, speakers);
              this._selectedCam = infos.camera;
              (_h = (_g = this._callbacks).onCamUpdated) === null || _h === void 0 || _h.call(_g, infos.camera);
              this._selectedMic = infos.mic;
              (_k = (_j = this._callbacks).onMicUpdated) === null || _k === void 0 || _k.call(_j, infos.mic);
              this._selectedSpeaker = infos.speaker;
              (_m = (_l = this._callbacks).onSpeakerUpdated) === null || _m === void 0 || _m.call(_l, infos.speaker);
              if (!!this._daily.isLocalAudioLevelObserverRunning()) return [
                3,
                4
              ];
              return [
                4,
                this._daily.startLocalAudioLevelObserver(100)
              ];
            case 3:
              _o2.sent();
              _o2.label = 4;
            case 4:
              if (!this._wavStreamPlayer) return [
                3,
                6
              ];
              return [
                4,
                this._wavStreamPlayer.connect()
              ];
            case 5:
              _o2.sent();
              if (!this._remoteAudioLevelInterval) this._remoteAudioLevelInterval = setInterval(function() {
                var _a4;
                var frequencies = _this._wavStreamPlayer.getFrequencies();
                var aveVal = 0;
                if ((_a4 = frequencies.values) === null || _a4 === void 0 ? void 0 : _a4.length) aveVal = frequencies.values.reduce(function(a2, c2) {
                  return a2 + c2;
                }, 0) / frequencies.values.length;
                _this._handleRemoteAudioLevel(aveVal);
              }, 100);
              _o2.label = 6;
            case 6:
              this._initialized = true;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.connect = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _this = this;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          if (this._connected) {
            console.warn("DailyMediaManager already connected");
            return [
              2
              /*return*/
            ];
          }
          this._connected = true;
          if (!this._initialized) return [
            2,
            new Promise(function(resolve2) {
              (function() {
                return $22ece045290c996a$var$__awaiter(_this, void 0, void 0, function() {
                  return $22ece045290c996a$var$__generator(this, function(_a4) {
                    switch (_a4.label) {
                      case 0:
                        this._connectResolve = resolve2;
                        return [
                          4,
                          this.initialize()
                        ];
                      case 1:
                        _a4.sent();
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              })();
            })
          ];
          if (this._micEnabled) this._startRecording();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    DailyMediaManager.prototype.disconnect = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _a3, _b;
        return $22ece045290c996a$var$__generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              if (this._remoteAudioLevelInterval) clearInterval(this._remoteAudioLevelInterval);
              this._remoteAudioLevelInterval = null;
              this._daily.leave();
              this._currentAudioTrack = null;
              return [
                4,
                (_a3 = this._mediaStreamRecorder) === null || _a3 === void 0 ? void 0 : _a3.end()
              ];
            case 1:
              _c2.sent();
              (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.interrupt();
              this._initialized = false;
              this._connected = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.userStartedSpeaking = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _a3;
        return $22ece045290c996a$var$__generator(this, function(_b) {
          return [
            2,
            (_a3 = this._wavStreamPlayer) === null || _a3 === void 0 ? void 0 : _a3.interrupt()
          ];
        });
      });
    };
    DailyMediaManager.prototype.bufferBotAudio = function(data, id) {
      var _a3;
      return (_a3 = this._wavStreamPlayer) === null || _a3 === void 0 ? void 0 : _a3.add16BitPCM(data, id);
    };
    DailyMediaManager.prototype.getAllMics = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "audioinput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.getAllCams = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "videoinput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.getAllSpeakers = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "audiooutput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.updateMic = function(micId) {
      var _this = this;
      this._daily.setInputDevicesAsync({
        audioDeviceId: micId
      }).then(function(deviceInfo) {
        _this._selectedMic = deviceInfo.mic;
      });
    };
    DailyMediaManager.prototype.updateCam = function(camId) {
      var _this = this;
      this._daily.setInputDevicesAsync({
        videoDeviceId: camId
      }).then(function(deviceInfo) {
        _this._selectedCam = deviceInfo.camera;
      });
    };
    DailyMediaManager.prototype.updateSpeaker = function(speakerId) {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var sID, speakers, defaultSpeaker_1, defaultSpeakerCp;
        var _this = this;
        var _a3, _b;
        return $22ece045290c996a$var$__generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              if (speakerId !== "default" && this._selectedSpeaker.deviceId === speakerId) return [
                2
                /*return*/
              ];
              sID = speakerId;
              if (!(sID === "default")) return [
                3,
                2
              ];
              return [
                4,
                this.getAllSpeakers()
              ];
            case 1:
              speakers = _c2.sent();
              defaultSpeaker_1 = speakers.find(function(s2) {
                return s2.deviceId === "default";
              });
              if (!defaultSpeaker_1) {
                console.warn("No default speaker found");
                return [
                  2
                  /*return*/
                ];
              }
              speakers.splice(speakers.indexOf(defaultSpeaker_1), 1);
              defaultSpeakerCp = speakers.find(function(s2) {
                return defaultSpeaker_1.label.includes(s2.label);
              });
              sID = (_a3 = defaultSpeakerCp === null || defaultSpeakerCp === void 0 ? void 0 : defaultSpeakerCp.deviceId) !== null && _a3 !== void 0 ? _a3 : speakerId;
              _c2.label = 2;
            case 2:
              (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.updateSpeaker(sID).then(function() {
                var _a4, _b2;
                _this._selectedSpeaker = {
                  deviceId: speakerId
                };
                (_b2 = (_a4 = _this._callbacks).onSpeakerUpdated) === null || _b2 === void 0 || _b2.call(_a4, _this._selectedSpeaker);
              });
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Object.defineProperty(DailyMediaManager.prototype, "selectedMic", {
      get: function() {
        return this._selectedMic;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "selectedCam", {
      get: function() {
        return this._selectedCam;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "selectedSpeaker", {
      get: function() {
        return this._selectedSpeaker;
      },
      enumerable: false,
      configurable: true
    });
    DailyMediaManager.prototype.enableMic = function(enable) {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _a3;
        return $22ece045290c996a$var$__generator(this, function(_b) {
          this._micEnabled = enable;
          if (!((_a3 = this._daily.participants()) === null || _a3 === void 0 ? void 0 : _a3.local)) return [
            2
            /*return*/
          ];
          this._daily.setLocalAudio(enable);
          if (this._mediaStreamRecorder) {
            if (enable) {
              if (this._mediaStreamRecorder.getStatus() === "paused") this._startRecording();
            } else if (this._mediaStreamRecorder.getStatus() === "recording") this._mediaStreamRecorder.pause();
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    DailyMediaManager.prototype.enableCam = function(enable) {
      this._camEnabled = enable;
      this._daily.setLocalVideo(enable);
    };
    DailyMediaManager.prototype.enableScreenShare = function(enable) {
      if (enable) this._daily.startScreenShare();
      else this._daily.stopScreenShare();
    };
    Object.defineProperty(DailyMediaManager.prototype, "isCamEnabled", {
      get: function() {
        return this._daily.localVideo();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "isMicEnabled", {
      get: function() {
        return this._daily.localAudio();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "isSharingScreen", {
      get: function() {
        return this._daily.localScreenAudio() || this._daily.localScreenVideo();
      },
      enumerable: false,
      configurable: true
    });
    DailyMediaManager.prototype.tracks = function() {
      var _a3, _b, _c2, _d, _e2, _f, _g, _h, _j, _k, _l, _m;
      var participants = this._daily.participants();
      return {
        local: {
          audio: (_c2 = (_b = (_a3 = participants === null || participants === void 0 ? void 0 : participants.local) === null || _a3 === void 0 ? void 0 : _a3.tracks) === null || _b === void 0 ? void 0 : _b.audio) === null || _c2 === void 0 ? void 0 : _c2.persistentTrack,
          screenAudio: (_f = (_e2 = (_d = participants === null || participants === void 0 ? void 0 : participants.local) === null || _d === void 0 ? void 0 : _d.tracks) === null || _e2 === void 0 ? void 0 : _e2.screenAudio) === null || _f === void 0 ? void 0 : _f.persistentTrack,
          screenVideo: (_j = (_h = (_g = participants === null || participants === void 0 ? void 0 : participants.local) === null || _g === void 0 ? void 0 : _g.tracks) === null || _h === void 0 ? void 0 : _h.screenVideo) === null || _j === void 0 ? void 0 : _j.persistentTrack,
          video: (_m = (_l = (_k = participants === null || participants === void 0 ? void 0 : participants.local) === null || _k === void 0 ? void 0 : _k.tracks) === null || _l === void 0 ? void 0 : _l.video) === null || _m === void 0 ? void 0 : _m.persistentTrack
        }
      };
    };
    DailyMediaManager.prototype._startRecording = function() {
      var _this = this;
      if (!this._connected || !this._mediaStreamRecorder) return;
      try {
        this._mediaStreamRecorder.record(function(data) {
          _this._userAudioCallback(data.mono);
        }, this._recorderChunkSize);
      } catch (e2) {
        var err = e2;
        if (!err.message.includes("Already recording")) console.error("Error starting recording", e2);
      }
    };
    DailyMediaManager.prototype._handleAvailableDevicesUpdated = function(event) {
      var _a3, _b, _c2, _d, _e2, _f;
      (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, event.availableDevices.filter(function(d2) {
        return d2.kind === "videoinput";
      }));
      (_d = (_c2 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c2, event.availableDevices.filter(function(d2) {
        return d2.kind === "audioinput";
      }));
      (_f = (_e2 = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e2, event.availableDevices.filter(function(d2) {
        return d2.kind === "audiooutput";
      }));
      if (this._selectedSpeaker.deviceId === "default") this.updateSpeaker("default");
    };
    DailyMediaManager.prototype._handleSelectedDevicesUpdated = function(event) {
      var _a3, _b, _c2, _d, _e2, _f;
      if (((_a3 = this._selectedCam) === null || _a3 === void 0 ? void 0 : _a3.deviceId) !== event.devices.camera) {
        this._selectedCam = event.devices.camera;
        (_c2 = (_b = this._callbacks).onCamUpdated) === null || _c2 === void 0 || _c2.call(_b, event.devices.camera);
      }
      if (((_d = this._selectedMic) === null || _d === void 0 ? void 0 : _d.deviceId) !== event.devices.mic) {
        this._selectedMic = event.devices.mic;
        (_f = (_e2 = this._callbacks).onMicUpdated) === null || _f === void 0 || _f.call(_e2, event.devices.mic);
      }
    };
    DailyMediaManager.prototype.handleDeviceError = function(ev) {
      var _a3, _b;
      var generateDeviceError = function(error) {
        var devices = [];
        switch (error.type) {
          case "permissions":
            error.blockedMedia.forEach(function(d2) {
              devices.push(d2 === "video" ? "cam" : "mic");
            });
            return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg, {
              blockedBy: error.blockedBy
            });
          case "not-found":
            error.missingMedia.forEach(function(d2) {
              devices.push(d2 === "video" ? "cam" : "mic");
            });
            return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg);
          case "constraints":
            error.failedMedia.forEach(function(d2) {
              devices.push(d2 === "video" ? "cam" : "mic");
            });
            return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg, {
              reason: error.reason
            });
          case "cam-in-use":
            devices.push("cam");
            return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, "in-use", error.msg);
          case "mic-in-use":
            devices.push("mic");
            return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, "in-use", error.msg);
          case "cam-mic-in-use":
            devices.push("cam");
            devices.push("mic");
            return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, "in-use", error.msg);
          case "undefined-mediadevices":
          case "unknown":
          default:
            devices.push("cam");
            devices.push("mic");
            return new (0, $db6391dc7d757577$export$64c9f614187c1e59)(devices, error.type, error.msg);
        }
      };
      (_b = (_a3 = this._callbacks).onDeviceError) === null || _b === void 0 || _b.call(_a3, generateDeviceError(ev.error));
    };
    DailyMediaManager.prototype._handleLocalAudioLevel = function(ev) {
      var _a3, _b;
      (_b = (_a3 = this._callbacks).onLocalAudioLevel) === null || _b === void 0 || _b.call(_a3, ev.audioLevel);
    };
    DailyMediaManager.prototype._handleRemoteAudioLevel = function(audioLevel) {
      var _a3, _b;
      (_b = (_a3 = this._callbacks).onRemoteAudioLevel) === null || _b === void 0 || _b.call(_a3, audioLevel, $22ece045290c996a$var$botParticipant());
    };
    DailyMediaManager.prototype.handleTrackStarted = function(event) {
      return $22ece045290c996a$var$__awaiter(this, void 0, void 0, function() {
        var status, _a3, e_1, e_2;
        var _b, _c2, _d, _e2;
        return $22ece045290c996a$var$__generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              if (!((_b = event.participant) === null || _b === void 0 ? void 0 : _b.local)) return [
                2
                /*return*/
              ];
              if (!(event.track.kind === "audio")) return [
                3,
                15
              ];
              if (!this._mediaStreamRecorder) return [
                3,
                14
              ];
              status = this._mediaStreamRecorder.getStatus();
              _a3 = status;
              switch (_a3) {
                case "ended":
                  return [
                    3,
                    1
                  ];
                case "paused":
                  return [
                    3,
                    5
                  ];
                case "recording":
                  return [
                    3,
                    6
                  ];
              }
              return [
                3,
                6
              ];
            case 1:
              _f.trys.push([
                1,
                3,
                ,
                4
              ]);
              return [
                4,
                this._mediaStreamRecorder.begin(event.track)
              ];
            case 2:
              _f.sent();
              if (this._connected) {
                this._startRecording();
                if (this._connectResolve) {
                  this._connectResolve();
                  this._connectResolve = null;
                }
              }
              return [
                3,
                4
              ];
            case 3:
              e_1 = _f.sent();
              return [
                3,
                4
              ];
            case 4:
              return [
                3,
                14
              ];
            case 5:
              this._startRecording();
              return [
                3,
                14
              ];
            case 6:
              if (!(this._currentAudioTrack !== event.track)) return [
                3,
                12
              ];
              return [
                4,
                this._mediaStreamRecorder.end()
              ];
            case 7:
              _f.sent();
              _f.label = 8;
            case 8:
              _f.trys.push([
                8,
                10,
                ,
                11
              ]);
              return [
                4,
                this._mediaStreamRecorder.begin(event.track)
              ];
            case 9:
              _f.sent();
              this._startRecording();
              return [
                3,
                11
              ];
            case 10:
              e_2 = _f.sent();
              return [
                3,
                11
              ];
            case 11:
              return [
                3,
                13
              ];
            case 12:
              console.warn("track-started event received for current track and already recording");
              _f.label = 13;
            case 13:
              return [
                3,
                14
              ];
            case 14:
              this._currentAudioTrack = event.track;
              _f.label = 15;
            case 15:
              (_d = (_c2 = this._callbacks).onTrackStarted) === null || _d === void 0 || _d.call(_c2, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant(event.participant) : void 0);
              (_e2 = this.onTrackStartedCallback) === null || _e2 === void 0 || _e2.call(this, event);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.handleTrackStopped = function(event) {
      var _a3, _b, _c2, _d;
      if (!((_a3 = event.participant) === null || _a3 === void 0 ? void 0 : _a3.local)) return;
      if (event.track.kind === "audio") {
        if (this._mediaStreamRecorder && this._mediaStreamRecorder.getStatus() === "recording") this._mediaStreamRecorder.pause();
      }
      (_c2 = (_b = this._callbacks).onTrackStopped) === null || _c2 === void 0 || _c2.call(_b, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant(event.participant) : void 0);
      (_d = this.onTrackStoppedCallback) === null || _d === void 0 || _d.call(this, event);
    };
    return DailyMediaManager;
  })((0, $fc49a56cd8739127$export$4a0c46dbbe2ddb67))
);
var $22ece045290c996a$var$dailyParticipantToParticipant = function(p2) {
  return {
    id: p2.user_id,
    local: p2.local,
    name: p2.user_name
  };
};
var $22ece045290c996a$var$botParticipant = function() {
  return {
    id: "bot",
    local: false,
    name: "Bot"
  };
};
var $b31644dc78dca54a$exports = {};
$parcel$export2($b31644dc78dca54a$exports, "SmallWebRTCTransport", () => $b31644dc78dca54a$export$62043589d053a879);
var $b31644dc78dca54a$var$TrackStatusMessage = class {
  constructor(receiver_index, enabled2) {
    this.type = "trackStatus";
    this.receiver_index = receiver_index;
    this.enabled = enabled2;
  }
};
var $b31644dc78dca54a$var$WebRTCTrack = class {
  constructor(track2) {
    this.track = track2;
    this.status = "new";
  }
};
var $b31644dc78dca54a$var$RENEGOTIATE_TYPE = "renegotiate";
var $b31644dc78dca54a$var$PEER_LEFT_TYPE = "peerLeft";
var $b31644dc78dca54a$var$SIGNALLING_TYPE = "signalling";
var $b31644dc78dca54a$var$SignallingMessageObject = class {
  constructor(message) {
    this.type = $b31644dc78dca54a$var$SIGNALLING_TYPE;
    this.message = message;
  }
};
var $b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX = 0;
var $b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX = 1;
var $b31644dc78dca54a$var$SCREEN_VIDEO_TRANSCEIVER_INDEX = 2;
var $b31644dc78dca54a$export$62043589d053a879 = class extends (0, $7ef5cee66c377f4d$export$86495b081fef8e52) {
  constructor(opts = {}) {
    super();
    this._webrtcRequest = null;
    this._connectResolved = null;
    this._connectFailed = null;
    this.pc = null;
    this.dc = null;
    this.audioCodec = null;
    this.videoCodec = null;
    this.pc_id = null;
    this.reconnectionAttempts = 0;
    this.maxReconnectionAttempts = 3;
    this.isReconnecting = false;
    this.keepAliveInterval = null;
    this._iceServers = [];
    this._incomingTracks = /* @__PURE__ */ new Map();
    this._iceServers = opts.iceServers ?? [];
    this._waitForICEGathering = opts.waitForICEGathering ?? false;
    this.audioCodec = opts.audioCodec ?? null;
    this.videoCodec = opts.videoCodec ?? null;
    this._webrtcRequest = this._resolveRequestInfo(opts);
    this.mediaManager = opts.mediaManager || new (0, $22ece045290c996a$export$c95c65abc5f47125)(false, false, async (event) => {
      if (!this.pc) return;
      if (event.type == "audio") {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).info("SmallWebRTCMediaManager replacing audio track");
        await this.getAudioTransceiver().sender.replaceTrack(event.track);
      } else if (event.type == "video") {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).info("SmallWebRTCMediaManager replacing video track");
        await this.getVideoTransceiver().sender.replaceTrack(event.track);
      } else if (event.type == "screenVideo") {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).info("SmallWebRTCMediaManager replacing screen video track");
        await this.getScreenVideoTransceiver().sender.replaceTrack(event.track);
      } else if (event.type == "screenAudio") (0, $e0900798b6cc045b$export$af88d00dbe7f521).info("SmallWebRTCMediaManager does not yet support screen audio. Track is ignored.");
    }, (event) => (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("SmallWebRTCMediaManager Track stopped:", event));
  }
  initialize(options, messageHandler) {
    this._options = options;
    this._callbacks = options.callbacks ?? {};
    this._onMessage = messageHandler;
    this.mediaManager.setClientOptions(options);
    this.state = "disconnected";
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("[RTVI Transport] Initialized");
  }
  async initDevices() {
    this.state = "initializing";
    await this.mediaManager.initialize();
    this.state = "initialized";
  }
  setAudioCodec(audioCodec) {
    this.audioCodec = audioCodec;
  }
  setVideoCodec(videoCodec) {
    this.videoCodec = videoCodec;
  }
  _resolveRequestInfo(params) {
    let requestInfo = null;
    const _webrtcUrl = params.webrtcUrl ?? params.connectionUrl ?? null;
    if (_webrtcUrl) {
      const key = params.webrtcUrl ? "webrtcUrl" : "connectionUrl";
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn(`${key} is deprecated. Use webrtcRequestParams instead.`);
      if (params.webrtcRequestParams) (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn(`Both ${key} and webrtcRequestParams provided. Using webrtcRequestParams.`);
      else if (typeof _webrtcUrl === "string") requestInfo = {
        endpoint: _webrtcUrl
      };
      else (0, $e0900798b6cc045b$export$af88d00dbe7f521).error(`Invalid ${key} provided in params. Ignoring.`);
    }
    if (params.webrtcRequestParams) {
      if ((0, $d0e914667cc5346b$export$2dd7ca293b2783)(params.webrtcRequestParams))
        requestInfo = params.webrtcRequestParams;
      else (0, $e0900798b6cc045b$export$af88d00dbe7f521).error(`Invalid webrtcRequestParams provided in params. Ignoring.`);
    }
    return requestInfo ?? this._webrtcRequest;
  }
  _validateConnectionParams(connectParams) {
    if (connectParams === void 0 || connectParams === null) return void 0;
    if (typeof connectParams !== "object") throw new (0, $db6391dc7d757577$export$59b4786f333aac02)("Invalid connection parameters");
    const snakeToCamel = (snakeCaseString) => {
      return snakeCaseString.replace(/_([a-z,A-Z])/g, (_2, letter) => letter.toUpperCase());
    };
    const fixedParams = {};
    const supportedKeys = [
      "webrtcUrl",
      "connectionUrl",
      "webrtcRequestParams"
    ];
    for (const [key, val] of Object.entries(connectParams)) {
      const camelKey = snakeToCamel(key);
      if (!supportedKeys.includes(camelKey)) (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn(`Unrecognized connection parameter: ${key}. This parameter will be ignored.`);
      else fixedParams[camelKey] = val;
    }
    const webrtcRequestParams = this._resolveRequestInfo(fixedParams);
    if (webrtcRequestParams) fixedParams.webrtcRequestParams = webrtcRequestParams;
    delete fixedParams.connectionUrl;
    delete fixedParams.webrtcUrl;
    if (Object.keys(fixedParams).length === 0) return void 0;
    return fixedParams;
  }
  async _connect(connectParams) {
    var _a3, _b, _c2, _d;
    if ((_a3 = this._abortController) == null ? void 0 : _a3.signal.aborted) return;
    this.state = "connecting";
    this._webrtcRequest = (connectParams == null ? void 0 : connectParams.webrtcRequestParams) ?? this._webrtcRequest;
    if (!this._webrtcRequest) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).error("No request details provided for WebRTC connection");
      this.state = "error";
      throw new (0, $db6391dc7d757577$export$e0624a511a2c4e9)();
    }
    await this.mediaManager.connect();
    await this.startNewPeerConnection();
    if ((_b = this._abortController) == null ? void 0 : _b.signal.aborted) return;
    await new Promise((resolve2, reject) => {
      this._connectResolved = resolve2;
      this._connectFailed = reject;
    });
    this.state = "connected";
    (_d = (_c2 = this._callbacks).onConnected) == null ? void 0 : _d.call(_c2);
  }
  syncTrackStatus() {
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX, this.mediaManager.isMicEnabled));
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX, this.mediaManager.isCamEnabled));
    if (this.mediaManager.supportsScreenShare) this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$SCREEN_VIDEO_TRANSCEIVER_INDEX, this.mediaManager.isSharingScreen && !!this.mediaManager.tracks().local.screenVideo));
  }
  sendReadyMessage() {
    this.state = "ready";
    this.sendMessage((0, $c0d10c4690969999$export$69aa9ab0334b212).clientReady());
  }
  sendMessage(message) {
    var _a3;
    if (!this.dc || this.dc.readyState !== "open") {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn(`Datachannel is not ready. Message not sent: ${message}`);
      return;
    }
    (_a3 = this.dc) == null ? void 0 : _a3.send(JSON.stringify(message));
  }
  sendSignallingMessage(message) {
    var _a3;
    if (!this.dc || this.dc.readyState !== "open") {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn(`Datachannel is not ready. Message not sent: ${message}`);
      return;
    }
    const signallingMessage = new $b31644dc78dca54a$var$SignallingMessageObject(message);
    (_a3 = this.dc) == null ? void 0 : _a3.send(JSON.stringify(signallingMessage));
  }
  async _disconnect() {
    this.state = "disconnecting";
    await this.stop();
    this.state = "disconnected";
  }
  createPeerConnection() {
    const config = {
      iceServers: this._iceServers
    };
    let pc2 = new RTCPeerConnection(config);
    pc2.addEventListener("icegatheringstatechange", () => {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`iceGatheringState: ${this.pc.iceGatheringState}`);
    });
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`iceGatheringState: ${pc2.iceGatheringState}`);
    pc2.addEventListener("iceconnectionstatechange", () => this.handleICEConnectionStateChange());
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`iceConnectionState: ${pc2.iceConnectionState}`);
    pc2.addEventListener("signalingstatechange", () => {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`signalingState: ${this.pc.signalingState}`);
      if (this.pc.signalingState == "stable") this.handleReconnectionCompleted();
    });
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`signalingState: ${pc2.signalingState}`);
    pc2.addEventListener("track", (evt) => {
      const streamType = evt.transceiver ? evt.transceiver.mid === "0" ? "microphone" : evt.transceiver.mid === "1" ? "camera" : "screenVideo" : null;
      if (!streamType) {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).warn("Received track without transceiver mid", evt);
        return;
      }
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Received new remote track for ${streamType}`);
      this._incomingTracks.set(streamType, new $b31644dc78dca54a$var$WebRTCTrack(evt.track));
      evt.track.addEventListener("unmute", () => {
        var _a3, _b;
        const t2 = this._incomingTracks.get(streamType);
        if (!t2) return;
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Remote track unmuted: ${streamType}`);
        t2.status = "unmuted";
        (_b = (_a3 = this._callbacks).onTrackStarted) == null ? void 0 : _b.call(_a3, evt.track);
      });
      evt.track.addEventListener("mute", () => {
        var _a3, _b;
        const t2 = this._incomingTracks.get(streamType);
        if (!t2 || t2.status !== "unmuted") return;
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Remote track muted: ${streamType}`);
        t2.status = "muted";
        (_b = (_a3 = this._callbacks).onTrackStopped) == null ? void 0 : _b.call(_a3, evt.track);
      });
      evt.track.addEventListener("ended", () => {
        var _a3, _b;
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Remote track ended: ${streamType}`);
        (_b = (_a3 = this._callbacks).onTrackStopped) == null ? void 0 : _b.call(_a3, evt.track);
        this._incomingTracks.delete(streamType);
      });
    });
    return pc2;
  }
  handleICEConnectionStateChange() {
    if (!this.pc) return;
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`ICE Connection State: ${this.pc.iceConnectionState}`);
    if (this.pc.iceConnectionState === "failed") {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("ICE connection failed, attempting restart.");
      this.attemptReconnection(true);
    } else if (this.pc.iceConnectionState === "disconnected")
      setTimeout(() => {
        var _a3;
        if (((_a3 = this.pc) == null ? void 0 : _a3.iceConnectionState) === "disconnected") {
          (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("Still disconnected, attempting reconnection.");
          this.attemptReconnection(true);
        }
      }, 5e3);
  }
  handleReconnectionCompleted() {
    this.reconnectionAttempts = 0;
    this.isReconnecting = false;
  }
  async attemptReconnection(recreatePeerConnection = false) {
    if (this.isReconnecting) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("Reconnection already in progress, skipping.");
      return;
    }
    if (this.reconnectionAttempts >= this.maxReconnectionAttempts) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("Max reconnection attempts reached. Stopping transport.");
      await this.stop();
      return;
    }
    this.isReconnecting = true;
    this.reconnectionAttempts++;
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Reconnection attempt ${this.reconnectionAttempts}...`);
    if (recreatePeerConnection) {
      const oldPC = this.pc;
      await this.startNewPeerConnection(recreatePeerConnection);
      if (oldPC) {
        (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("closing old peer connection");
        this.closePeerConnection(oldPC);
      }
    } else await this.negotiate();
  }
  async negotiate(recreatePeerConnection = false) {
    if (!this.pc) return Promise.reject("Peer connection is not initialized");
    if (!this._webrtcRequest) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).error("No request details provided for WebRTC connection");
      this.state = "error";
      throw new (0, $db6391dc7d757577$export$e0624a511a2c4e9)();
    }
    try {
      const offer = await this.pc.createOffer();
      await this.pc.setLocalDescription(offer);
      if (this._waitForICEGathering) await new Promise((resolve2) => {
        if (this.pc.iceGatheringState === "complete") resolve2();
        else {
          const checkState = () => {
            if (this.pc.iceGatheringState === "complete") {
              this.pc.removeEventListener("icegatheringstatechange", checkState);
              resolve2();
            }
          };
          this.pc.addEventListener("icegatheringstatechange", checkState);
        }
      });
      let offerSdp = this.pc.localDescription;
      if (this.audioCodec && this.audioCodec !== "default")
        offerSdp.sdp = this.sdpFilterCodec("audio", this.audioCodec, offerSdp.sdp);
      if (this.videoCodec && this.videoCodec !== "default")
        offerSdp.sdp = this.sdpFilterCodec("video", this.videoCodec, offerSdp.sdp);
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Will create offer for peerId: ${this.pc_id}`);
      const request = (0, import_cloneDeep.default)(this._webrtcRequest);
      const requestData = {
        sdp: offerSdp.sdp,
        type: offerSdp.type,
        pc_id: this.pc_id,
        restart_pc: recreatePeerConnection
      };
      if (this._webrtcRequest.requestData) requestData.requestData = this._webrtcRequest.requestData;
      request.requestData = requestData;
      const answer = await (0, $d0e914667cc5346b$export$699251e5611cc6db)(request);
      this.pc_id = answer.pc_id;
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Received answer for peer connection id ${answer.pc_id}`);
      await this.pc.setRemoteDescription(answer);
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Remote candidate supports trickle ice: ${this.pc.canTrickleIceCandidates}`);
    } catch (e2) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`Reconnection attempt ${this.reconnectionAttempts} failed: ${e2}`);
      this.isReconnecting = false;
      setTimeout(() => this.attemptReconnection(true), 2e3);
    }
  }
  addInitialTransceivers() {
    this.pc.addTransceiver("audio", {
      direction: "sendrecv"
    });
    this.pc.addTransceiver("video", {
      direction: "sendrecv"
    });
    if (this.mediaManager.supportsScreenShare)
      this.pc.addTransceiver("video", {
        direction: "sendonly"
      });
  }
  getAudioTransceiver() {
    return this.pc.getTransceivers()[$b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX];
  }
  getVideoTransceiver() {
    return this.pc.getTransceivers()[$b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX];
  }
  getScreenVideoTransceiver() {
    return this.pc.getTransceivers()[$b31644dc78dca54a$var$SCREEN_VIDEO_TRANSCEIVER_INDEX];
  }
  async startNewPeerConnection(recreatePeerConnection = false) {
    this.pc = this.createPeerConnection();
    this.addInitialTransceivers();
    this.dc = this.createDataChannel("chat", {
      ordered: true
    });
    await this.addUserMedia();
    await this.negotiate(recreatePeerConnection);
  }
  async addUserMedia() {
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`addUserMedia this.tracks(): ${this.tracks()}`);
    let audioTrack = this.tracks().local.audio;
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`addUserMedia audioTrack: ${audioTrack}`);
    if (audioTrack) await this.getAudioTransceiver().sender.replaceTrack(audioTrack);
    let videoTrack = this.tracks().local.video;
    (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`addUserMedia videoTrack: ${videoTrack}`);
    if (videoTrack) await this.getVideoTransceiver().sender.replaceTrack(videoTrack);
    if (this.mediaManager.supportsScreenShare) {
      videoTrack = this.tracks().local.screenVideo;
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug(`addUserMedia screenVideoTrack: ${videoTrack}`);
      if (videoTrack) await this.getScreenVideoTransceiver().sender.replaceTrack(videoTrack);
    }
  }
  // Method to handle a general message (this can be expanded for other types of messages)
  handleMessage(message) {
    try {
      const messageObj = JSON.parse(message);
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("received message:", messageObj);
      if (messageObj.type === $b31644dc78dca54a$var$SIGNALLING_TYPE) this.handleSignallingMessage(messageObj);
      else if (messageObj.label === "rtvi-ai") this._onMessage({
        id: messageObj.id,
        type: messageObj.type,
        data: messageObj.data
      });
    } catch (error) {
      console.error("Failed to parse JSON message:", error);
    }
  }
  // Method to handle signalling messages specifically
  async handleSignallingMessage(messageObj) {
    const signallingMessage = messageObj;
    switch (signallingMessage.message.type) {
      case $b31644dc78dca54a$var$RENEGOTIATE_TYPE:
        this.attemptReconnection(false);
        break;
      case $b31644dc78dca54a$var$PEER_LEFT_TYPE:
        this.disconnect();
        break;
      default:
        console.warn("Unknown signalling message:", signallingMessage.message);
    }
  }
  createDataChannel(label, options) {
    const dc2 = this.pc.createDataChannel(label, options);
    dc2.addEventListener("close", () => {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("datachannel closed");
      if (this.keepAliveInterval) {
        clearInterval(this.keepAliveInterval);
        this.keepAliveInterval = null;
      }
    });
    dc2.addEventListener("open", () => {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("datachannel opened");
      if (this._connectResolved) {
        this.syncTrackStatus();
        this._connectResolved();
        this._connectResolved = null;
        this._connectFailed = null;
      }
      this.keepAliveInterval = setInterval(() => {
        const message = "ping: " + (/* @__PURE__ */ new Date()).getTime();
        dc2.send(message);
      }, 1e3);
    });
    dc2.addEventListener("message", (evt) => {
      let message = evt.data;
      this.handleMessage(message);
    });
    return dc2;
  }
  closePeerConnection(pc2) {
    pc2.getTransceivers().forEach((transceiver) => {
      if (transceiver.stop) transceiver.stop();
    });
    pc2.getSenders().forEach((sender) => {
      var _a3;
      (_a3 = sender.track) == null ? void 0 : _a3.stop();
    });
    pc2.close();
  }
  async stop() {
    var _a3, _b;
    if (!this.pc) {
      (0, $e0900798b6cc045b$export$af88d00dbe7f521).debug("Peer connection is already closed or null.");
      return;
    }
    if (this.dc) this.dc.close();
    this.closePeerConnection(this.pc);
    this.pc = null;
    await this.mediaManager.disconnect();
    this.pc_id = null;
    this.reconnectionAttempts = 0;
    this.isReconnecting = false;
    (_b = (_a3 = this._callbacks).onDisconnected) == null ? void 0 : _b.call(_a3);
    if (this._connectFailed) this._connectFailed();
    this._connectFailed = null;
    this._connectResolved = null;
  }
  getAllMics() {
    return this.mediaManager.getAllMics();
  }
  getAllCams() {
    return this.mediaManager.getAllCams();
  }
  getAllSpeakers() {
    return this.mediaManager.getAllSpeakers();
  }
  async updateMic(micId) {
    return this.mediaManager.updateMic(micId);
  }
  updateCam(camId) {
    return this.mediaManager.updateCam(camId);
  }
  updateSpeaker(speakerId) {
    return this.mediaManager.updateSpeaker(speakerId);
  }
  get selectedMic() {
    return this.mediaManager.selectedMic;
  }
  get selectedCam() {
    return this.mediaManager.selectedCam;
  }
  get selectedSpeaker() {
    return this.mediaManager.selectedSpeaker;
  }
  set iceServers(iceServers) {
    this._iceServers = iceServers;
  }
  get iceServers() {
    return this._iceServers;
  }
  enableMic(enable) {
    this.mediaManager.enableMic(enable);
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX, enable));
  }
  enableCam(enable) {
    this.mediaManager.enableCam(enable);
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX, enable));
  }
  async enableScreenShare(enable) {
    if (!this.mediaManager.supportsScreenShare) throw new (0, $db6391dc7d757577$export$bd0820eb8444fcd9)("enableScreenShare", "mediaManager", "Screen sharing is not supported by the current media manager");
    this.mediaManager.enableScreenShare(enable);
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$SCREEN_VIDEO_TRANSCEIVER_INDEX, enable));
  }
  get isCamEnabled() {
    return this.mediaManager.isCamEnabled;
  }
  get isMicEnabled() {
    return this.mediaManager.isMicEnabled;
  }
  get isSharingScreen() {
    return this.mediaManager.isSharingScreen;
  }
  get state() {
    return this._state;
  }
  set state(state) {
    var _a3, _b;
    if (this._state === state) return;
    this._state = state;
    (_b = (_a3 = this._callbacks).onTransportStateChanged) == null ? void 0 : _b.call(_a3, state);
  }
  tracks() {
    return this.mediaManager.tracks();
  }
  sdpFilterCodec(kind, codec, realSdp) {
    const allowed = [];
    const rtxRegex = new RegExp("a=fmtp:(\\d+) apt=(\\d+)\\r$");
    const codecRegex = new RegExp("a=rtpmap:([0-9]+) " + this.escapeRegExp(codec));
    const videoRegex = new RegExp("(m=" + kind + " .*?)( ([0-9]+))*\\s*$");
    const lines = realSdp.split("\n");
    let isKind = false;
    for (let i2 = 0; i2 < lines.length; i2++) {
      if (lines[i2].startsWith("m=" + kind + " ")) isKind = true;
      else if (lines[i2].startsWith("m=")) isKind = false;
      if (isKind) {
        const match = lines[i2].match(codecRegex);
        if (match) allowed.push(parseInt(match[1]));
        const matchRtx = lines[i2].match(rtxRegex);
        if (matchRtx && allowed.includes(parseInt(matchRtx[2]))) allowed.push(parseInt(matchRtx[1]));
      }
    }
    const skipRegex = "a=(fmtp|rtcp-fb|rtpmap):([0-9]+)";
    let sdp = "";
    isKind = false;
    for (let i2 = 0; i2 < lines.length; i2++) {
      if (lines[i2].startsWith("m=" + kind + " ")) isKind = true;
      else if (lines[i2].startsWith("m=")) isKind = false;
      if (isKind) {
        const skipMatch = lines[i2].match(skipRegex);
        if (skipMatch && !allowed.includes(parseInt(skipMatch[2]))) continue;
        else if (lines[i2].match(videoRegex)) sdp += lines[i2].replace(videoRegex, "$1 " + allowed.join(" ")) + "\n";
        else sdp += lines[i2] + "\n";
      } else sdp += lines[i2] + "\n";
    }
    return sdp;
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
$b31644dc78dca54a$export$62043589d053a879.SERVICE_NAME = "small-webrtc-transport";

// node_modules/.pnpm/@pipecat-ai+voice-ui-kit@0.1.1_@daily-co+daily-js@0.83.1_@pipecat-ai+client-js@1.3.0_@pipecat_khij4yv43apaa6fksg3kmyvpgq/node_modules/@pipecat-ai/voice-ui-kit/dist/index.mjs
function clamp$1(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props2) => {
      var _a3;
      const { scope, children, ...context } = props2;
      const Context = ((_a3 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a3[index2]) || BaseContext;
      const value = React.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime2.jsx)(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a3;
      const Context = ((_a3 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a3[index2]) || BaseContext;
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i2 = 0; i2 < cleanups.length; i2++) {
          const cleanup = cleanups[i2];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i2], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    const childrenArray = React.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React.Children.count(newElement) > 1) return React.Children.only(null);
          return React.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot$3 = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    if (React.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      const props22 = mergeProps(slotProps, children.props);
      if (children.type !== React.Fragment) {
        props22.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React.cloneElement(children, props22);
    }
    return React.Children.count(children) > 1 ? React.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
function isSlottable(child) {
  return React.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  var _a3, _b;
  let getter = (_a3 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a3.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props2) => {
    const { scope, children } = props2;
    const ref = import_react2.default.useRef(null);
    const itemMap = import_react2.default.useRef(/* @__PURE__ */ new Map()).current;
    return (0, import_jsx_runtime2.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react2.default.forwardRef(
    (props2, forwardedRef) => {
      const { scope, children } = props2;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime2.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react2.default.forwardRef(
    (props2, forwardedRef) => {
      const { scope, children, ...itemData } = props2;
      const ref = import_react2.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react2.default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return (0, import_jsx_runtime2.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react2.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = React.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = createSlot(`Primitive.${node}`);
  const Node2 = React.forwardRef((props2, forwardedRef) => {
    const { asChild, ...primitiveProps } = props2;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime2.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback2) {
  const callbackRef = React.useRef(callback2);
  React.useEffect(() => {
    callbackRef.current = callback2;
  });
  return React.useMemo(() => (...args) => {
    var _a3;
    return (_a3 = callbackRef.current) == null ? void 0 : _a3.call(callbackRef, ...args);
  }, []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  React.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props2;
    const context = React.useContext(DismissableLayerContext);
    const [node, setNode] = React.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime2.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props2.style
        },
        onFocusCapture: composeEventHandlers(props2.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props2.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props2.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React.forwardRef((props2, forwardedRef) => {
  const context = React.useContext(DismissableLayerContext);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime2.jsx)(Primitive.div, { ...props2, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React.useRef(false);
  const handleClickRef = React.useRef(() => {
  });
  React.useEffect(() => {
    const handlePointerDown2 = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown2);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown2);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = React.useRef(false);
  React.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count$1 = 0;
function useFocusGuards() {
  React.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$1++;
    return () => {
      if (count$1 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$1--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React.forwardRef((props2, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props2;
  const [container, setContainer] = React.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$2(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime2.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$2(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a3;
      stack = arrayRemove(stack, focusScope);
      (_a3 = stack[0]) == null ? void 0 : _a3.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useLayoutEffect22 = (globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : () => {
};
var useReactId = React[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId$1(deterministicId) {
  const [id, setId] = React.useState(useReactId());
  useLayoutEffect22(() => {
    setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round2 = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d2) => d2.overflows[0] > 0 && getSideAxis(d2.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x22,
              y: y22
            } = _ref;
            return {
              x: x22,
              y: y22
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e2) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round2(rect.width) : rect.width) / width;
  let y2 = ($2 ? round2(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip2, threshold) {
    if (skip2 === void 0) {
      skip2 = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip2) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset$1 = offset$2;
var shift$1 = shift$2;
var flip$1 = flip$2;
var size$1 = size$2;
var hide$1 = hide$2;
var arrow$2 = arrow$3;
var limitShift$1 = limitShift$2;
var computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop2 = function noop22() {
};
var index = isClient ? import_react2.useLayoutEffect : noop2;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
var shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
var limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
var flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
var size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
var hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
var arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1 = React.forwardRef((props2, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props2;
  return (0, import_jsx_runtime2.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props2.asChild ? children : (0, import_jsx_runtime2.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root$2 = Arrow$1;
function useSize(element) {
  const [size2, setSize] = React.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props2) => {
  const { __scopePopper, children } = props2;
  const [anchor, setAnchor] = React.useState(null);
  return (0, import_jsx_runtime2.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$2 = "PopperAnchor";
var PopperAnchor = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props2;
    const context = usePopperContext(ANCHOR_NAME$2, __scopePopper);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : (0, import_jsx_runtime2.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$2;
var CONTENT_NAME$6 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$6);
var PopperContent = React.forwardRef(
  (props2, forwardedRef) => {
    var _a3, _b, _c2, _d, _e2, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props2;
    const context = usePopperContext(CONTENT_NAME$6, __scopePopper);
    const [content, setContent] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = React.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a3 = middlewareData.arrow) == null ? void 0 : _a3.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React.useState();
    useLayoutEffect22(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime2.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e2 = middlewareData.transformOrigin) == null ? void 0 : _e2.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props2.dir,
        children: (0, import_jsx_runtime2.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime2.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$6;
var ARROW_NAME$5 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React.forwardRef(function PopperArrow2(props2, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props2;
  const contentContext = useContentContext(ARROW_NAME$5, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime2.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime2.jsx)(
          Root$2,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$5;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a3, _b, _c2;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a3 = middlewareData.arrow) == null ? void 0 : _a3.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$4 = Popper;
var Anchor = PopperAnchor;
var Content$1 = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$5 = "Portal";
var Portal$4 = React.forwardRef((props2, forwardedRef) => {
  var _a3;
  const { container: containerProp, ...portalProps } = props2;
  const [mounted, setMounted] = React.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a3 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a3.body);
  return container ? import_react_dom.default.createPortal((0, import_jsx_runtime2.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$4.displayName = PORTAL_NAME$5;
var useInsertionEffect = React[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = React.useRef(prop !== void 0);
    React.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from2 = wasControlled ? "controlled" : "uncontrolled";
        const to3 = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from2} to ${to3}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React.useCallback(
    (nextValue) => {
      var _a3;
      if (isControlled) {
        const value2 = isFunction2(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a3 = onChangeRef.current) == null ? void 0 : _a3.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React.useState(defaultProp);
  const prevValueRef = React.useRef(value);
  const onChangeRef = React.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React.useEffect(() => {
    var _a3;
    if (prevValueRef.current !== value) {
      (_a3 = onChangeRef.current) == null ? void 0 : _a3.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction2(value) {
  return typeof value === "function";
}
function usePrevious(value) {
  const ref = React.useRef({ value, previous: value });
  return React.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME = "VisuallyHidden";
var VisuallyHidden = React.forwardRef(
  (props2, forwardedRef) => {
    return (0, import_jsx_runtime2.jsx)(
      Primitive.span,
      {
        ...props2,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props2.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var Root$1 = VisuallyHidden;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __spreadArray(to3, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar2; i2 < l2; i2++) {
    if (ar2 || !(i2 in from2)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from2, 0, i2);
      ar2[i2] = from2[i2];
    }
  }
  return to3.concat(ar2 || Array.prototype.slice.call(from2));
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback2) {
  var ref = (0, import_react2.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback: callback2,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback2;
  return ref.facade;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a3) {
  var sideCar = _a3.sideCar, rest = __rest(_a3, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React.forwardRef(function(props2, parentRef) {
  var ref = React.useRef(null);
  var _a3 = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a3[0], setCallbacks = _a3[1];
  var forwardProps = props2.forwardProps, children = props2.children, className = props2.className, removeScrollBar = props2.removeScrollBar, enabled2 = props2.enabled, shards = props2.shards, sideCar = props2.sideCar, noRelative = props2.noRelative, noIsolation = props2.noIsolation, inert = props2.inert, allowPinchZoom = props2.allowPinchZoom, _b = props2.as, Container = _b === void 0 ? "div" : _b, gapMode = props2.gapMode, rest = __rest(props2, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled2 && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce$1 = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce2 = getNonce$1();
  if (nonce2) {
    tag.setAttribute("nonce", nonce2);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a3) {
    var styles = _a3.styles, dynamic = _a3.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs2 = window.getComputedStyle(document.body);
  var left = cs2[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs2[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs2[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a3, allowRelative, gapMode, important) {
  var left = _a3.left, top = _a3.top, right = _a3.right, gap = _a3.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter2 = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter2) ? counter2 : 0;
};
var useLockAttribute = function() {
  React.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a3) {
  var noRelative = _a3.noRelative, noImportant = _a3.noImportant, _b = _a3.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a3 = getScrollVariables(axis, current), scrollHeight = _a3[1], clientHeight = _a3[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a3) {
  var scrollTop = _a3.scrollTop, scrollHeight = _a3.scrollHeight, clientHeight = _a3.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a3) {
  var scrollLeft = _a3.scrollLeft, scrollWidth = _a3.scrollWidth, clientWidth = _a3.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a3 = getScrollVariables(axis, target), position = _a3[0], scroll_1 = _a3[1], capacity = _a3[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props2) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id = React.useState(idCounter++)[0];
  var Style2 = React.useState(styleSingleton)[0];
  var lastProps = React.useRef(props2);
  React.useEffect(function() {
    lastProps.current = props2;
  }, [props2]);
  React.useEffect(function() {
    if (props2.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props2.lockRef.current], (props2.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props2.inert, props2.lockRef.current, props2.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props2.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props2.removeScrollBar, inert = props2.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { noRelative: props2.noRelative, gapMode: props2.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
var SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props2, ref) {
  return React.createElement(RemoveScroll, __assign({}, props2, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS$1 = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope$2,
  createPopperScope
]);
var usePopperScope$3 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props2) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props2;
  const popperScope = usePopperScope$3(__scopeSelect);
  const [trigger, setTrigger] = React.useState(null);
  const [valueNode, setValueNode] = React.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = React.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return (0, import_jsx_runtime2.jsx)(Root2$4, { ...popperScope, children: (0, import_jsx_runtime2.jsxs)(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId$1(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        (0, import_jsx_runtime2.jsx)(Collection$2.Provider, { scope: __scopeSelect, children: (0, import_jsx_runtime2.jsx)(
          SelectNativeOptionsProvider,
          {
            scope: props2.__scopeSelect,
            onNativeOptionAdd: React.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? (0, import_jsx_runtime2.jsxs)(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? (0, import_jsx_runtime2.jsx)("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$4 = "SelectTrigger";
var SelectTrigger$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props2;
    const popperScope = usePopperScope$3(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME$4, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection$2(__scopeSelect);
    const pointerTypeRef = React.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return (0, import_jsx_runtime2.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime2.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME$4;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props2;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect22(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return (0, import_jsx_runtime2.jsx)(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props2;
    return (0, import_jsx_runtime2.jsx)(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$4 = "SelectPortal";
var SelectPortal = (props2) => {
  return (0, import_jsx_runtime2.jsx)(Portal$4, { asChild: true, ...props2 });
};
SelectPortal.displayName = PORTAL_NAME$4;
var CONTENT_NAME$5 = "SelectContent";
var SelectContent$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME$5, props2.__scopeSelect);
    const [fragment, setFragment] = React.useState();
    useLayoutEffect22(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM.createPortal(
        (0, import_jsx_runtime2.jsx)(SelectContentProvider, { scope: props2.__scopeSelect, children: (0, import_jsx_runtime2.jsx)(Collection$2.Slot, { scope: props2.__scopeSelect, children: (0, import_jsx_runtime2.jsx)("div", { children: props2.children }) }) }),
        frag
      ) : null;
    }
    return (0, import_jsx_runtime2.jsx)(SelectContentImpl, { ...props2, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME$5;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$5);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot$2 = createSlot("SelectContent.RemoveScroll");
var SelectContentImpl = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props2;
    const context = useSelectContext(CONTENT_NAME$5, __scopeSelect);
    const [content, setContent] = React.useState(null);
    const [viewport, setViewport] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React.useState(null);
    const [selectedItemText, setSelectedItemText] = React.useState(
      null
    );
    const getItems = useCollection$2(__scopeSelect);
    const [isPositioned, setIsPositioned] = React.useState(false);
    const firstValidItemFoundRef = React.useRef(false);
    React.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = React.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    React.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove2 = (event) => {
          var _a3, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a3 = triggerPointerDownPosRef.current) == null ? void 0 : _a3.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp2 = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove2);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove2);
          document.addEventListener("pointerup", handlePointerUp2, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove2);
          document.removeEventListener("pointerup", handlePointerUp2, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return (0, import_jsx_runtime2.jsx)(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: (0, import_jsx_runtime2.jsx)(ReactRemoveScroll, { as: Slot$2, allowPinchZoom: true, children: (0, import_jsx_runtime2.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a3;
              (_a3 = context.trigger) == null ? void 0 : _a3.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: (0, import_jsx_runtime2.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: (0, import_jsx_runtime2.jsx)(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React.forwardRef((props2, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props2;
  const context = useSelectContext(CONTENT_NAME$5, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$5, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection$2(__scopeSelect);
  const shouldExpandOnScrollRef = React.useRef(false);
  const shouldRepositionRef = React.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp$1(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp$1(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect22(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React.useState();
  useLayoutEffect22(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return (0, import_jsx_runtime2.jsx)(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: (0, import_jsx_runtime2.jsx)(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: (0, import_jsx_runtime2.jsx)(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React.forwardRef((props2, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props2;
  const popperScope = usePopperScope$3(__scopeSelect);
  return (0, import_jsx_runtime2.jsx)(
    Content$1,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$5, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, nonce: nonce2, ...viewportProps } = props2;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React.useRef(0);
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce: nonce2
        }
      ),
      (0, import_jsx_runtime2.jsx)(Collection$2.Slot, { scope: __scopeSelect, children: (0, import_jsx_runtime2.jsx)(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME$3 = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME$3);
var SelectGroup$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props2;
    const groupId = useId$1();
    return (0, import_jsx_runtime2.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: (0, import_jsx_runtime2.jsx)(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup$1.displayName = GROUP_NAME$3;
var LABEL_NAME$2 = "SelectLabel";
var SelectLabel = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props2;
    const groupContext = useSelectGroupContext(LABEL_NAME$2, __scopeSelect);
    return (0, import_jsx_runtime2.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME$3);
var SelectItem$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props2;
    const context = useSelectContext(ITEM_NAME$3, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME$3, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a3;
        return (_a3 = contentContext.itemRefCallback) == null ? void 0 : _a3.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId$1();
    const pointerTypeRef = React.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return (0, import_jsx_runtime2.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: (0, import_jsx_runtime2.jsx)(
          Collection$2.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: (0, import_jsx_runtime2.jsx)(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a3;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a3 = contentContext.onItemLeave) == null ? void 0 : _a3.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a3;
                  if (event.currentTarget === document.activeElement) {
                    (_a3 = contentContext.onItemLeave) == null ? void 0 : _a3.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a3;
                  const isTypingAhead = ((_a3 = contentContext.searchRef) == null ? void 0 : _a3.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS$1.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME$3;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props2;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a3;
        return (_a3 = contentContext.itemTextRefCallback) == null ? void 0 : _a3.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React.useMemo(
      () => (0, import_jsx_runtime2.jsx)("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect22(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME$1 = "SelectItemIndicator";
var SelectItemIndicator = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props2;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME$1, __scopeSelect);
    return itemContext.isSelected ? (0, import_jsx_runtime2.jsx)(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = React.forwardRef((props2, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props2.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props2.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? (0, import_jsx_runtime2.jsx)(
    SelectScrollButtonImpl,
    {
      ...props2,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = React.forwardRef((props2, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props2.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props2.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? (0, import_jsx_runtime2.jsx)(
    SelectScrollButtonImpl,
    {
      ...props2,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React.forwardRef((props2, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props2;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React.useRef(null);
  const getItems = useCollection$2(__scopeSelect);
  const clearAutoScrollTimer = React.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect22(() => {
    var _a3;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a3 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a3.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return (0, import_jsx_runtime2.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a3;
        (_a3 = contentContext.onItemLeave) == null ? void 0 : _a3.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME$2 = "SelectSeparator";
var SelectSeparator$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props2;
    return (0, import_jsx_runtime2.jsx)(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$4 = "SelectArrow";
var SelectArrow = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props2;
    const popperScope = usePopperScope$3(__scopeSelect);
    const context = useSelectContext(ARROW_NAME$4, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME$4, __scopeSelect);
    return context.open && contentContext.position === "popper" ? (0, import_jsx_runtime2.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME$4;
var BUBBLE_INPUT_NAME = "SelectBubbleInput";
var SelectBubbleInput = React.forwardRef(
  ({ __scopeSelect, value, ...props2 }, forwardedRef) => {
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React.useEffect(() => {
      const select = ref.current;
      if (!select) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return (0, import_jsx_runtime2.jsx)(
      Primitive.select,
      {
        ...props2,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props2.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = React.useRef("");
  const timerRef = React.useRef(0);
  const handleTypeaheadSearch = React.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray$2(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v2) => v2 !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray$2(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root2$3 = Select$1;
var Trigger$4 = SelectTrigger$1;
var Value = SelectValue$1;
var Icon$1 = SelectIcon;
var Portal$3 = SelectPortal;
var Content2$4 = SelectContent$1;
var Viewport = SelectViewport;
var Group$1 = SelectGroup$1;
var Item$1 = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator$1 = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator$1 = SelectSeparator$1;
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var toCamelCase = (string) => string.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
);
var toPascalCase = (string) => {
  const camelCase = toCamelCase(string);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
var mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
var hasA11yProp = (props2) => {
  for (const prop in props2) {
    if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
      return true;
    }
  }
};
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
var Icon = (0, import_react2.forwardRef)(
  ({
    color: color2 = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => (0, import_react2.createElement)(
    "svg",
    {
      ref,
      ...defaultAttributes,
      width: size2,
      height: size2,
      stroke: color2,
      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      className: mergeClasses("lucide", className),
      ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
      ...rest
    },
    [
      ...iconNode.map(([tag, attrs]) => (0, import_react2.createElement)(tag, attrs)),
      ...Array.isArray(children) ? children : [children]
    ]
  )
);
var createLucideIcon = (iconName, iconNode) => {
  const Component = (0, import_react2.forwardRef)(
    ({ className, ...props2 }, ref) => (0, import_react2.createElement)(Icon, {
      ref,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props2
    })
  );
  Component.displayName = toPascalCase(iconName);
  return Component;
};
var __iconNode$x = [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
];
var ArrowDown = createLucideIcon("arrow-down", __iconNode$x);
var __iconNode$w = [
  ["path", { d: "M12 8V4H8", key: "hb8ula" }],
  ["rect", { width: "16", height: "12", x: "4", y: "8", rx: "2", key: "enze0r" }],
  ["path", { d: "M2 14h2", key: "vft8re" }],
  ["path", { d: "M20 14h2", key: "4cs60a" }],
  ["path", { d: "M15 13v2", key: "1xurst" }],
  ["path", { d: "M9 13v2", key: "rq6x2g" }]
];
var Bot = createLucideIcon("bot", __iconNode$w);
var __iconNode$v = [
  ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }],
  ["path", { d: "m19 9-5 5-4-4-3 3", key: "2osh9i" }]
];
var ChartLine = createLucideIcon("chart-line", __iconNode$v);
var __iconNode$u = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]];
var Check = createLucideIcon("check", __iconNode$u);
var __iconNode$t = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
var ChevronDown = createLucideIcon("chevron-down", __iconNode$t);
var __iconNode$s = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]];
var ChevronRight = createLucideIcon("chevron-right", __iconNode$s);
var __iconNode$r = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]];
var ChevronUp = createLucideIcon("chevron-up", __iconNode$r);
var __iconNode$q = [
  ["path", { d: "M12 12h.01", key: "1mp3jc" }],
  ["path", { d: "M16 12h.01", key: "1l6xoz" }],
  ["path", { d: "m17 7 5 5-5 5", key: "1xlxn0" }],
  ["path", { d: "m7 7-5 5 5 5", key: "19njba" }],
  ["path", { d: "M8 12h.01", key: "czm47f" }]
];
var ChevronsLeftRightEllipsis = createLucideIcon("chevrons-left-right-ellipsis", __iconNode$q);
var __iconNode$p = [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
];
var ChevronsUpDown = createLucideIcon("chevrons-up-down", __iconNode$p);
var __iconNode$o = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
];
var CircleAlert = createLucideIcon("circle-alert", __iconNode$o);
var __iconNode$n = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]];
var Circle = createLucideIcon("circle", __iconNode$n);
var __iconNode$m = [
  ["path", { d: "m12 15 2 2 4-4", key: "2c609p" }],
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
];
var CopyCheck = createLucideIcon("copy-check", __iconNode$m);
var __iconNode$l = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
];
var Copy = createLucideIcon("copy", __iconNode$l);
var __iconNode$k = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
];
var EllipsisVertical = createLucideIcon("ellipsis-vertical", __iconNode$k);
var __iconNode$j = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
];
var Ellipsis = createLucideIcon("ellipsis", __iconNode$j);
var __iconNode$i = [
  [
    "path",
    {
      d: "M10 20a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341L21.74 4.67A1 1 0 0 0 21 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14z",
      key: "sc7q7i"
    }
  ]
];
var Funnel = createLucideIcon("funnel", __iconNode$i);
var __iconNode$h = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
];
var Info = createLucideIcon("info", __iconNode$h);
var __iconNode$g = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]];
var LoaderCircle = createLucideIcon("loader-circle", __iconNode$g);
var __iconNode$f = [
  ["path", { d: "m16 17 5-5-5-5", key: "1bji2h" }],
  ["path", { d: "M21 12H9", key: "dn1m92" }],
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }]
];
var LogOut = createLucideIcon("log-out", __iconNode$f);
var __iconNode$e = [
  ["path", { d: "M14 9a2 2 0 0 1-2 2H6l-4 4V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2z", key: "p1xzt8" }],
  ["path", { d: "M18 9h2a2 2 0 0 1 2 2v11l-4-4h-6a2 2 0 0 1-2-2v-1", key: "1cx29u" }]
];
var MessagesSquare = createLucideIcon("messages-square", __iconNode$e);
var __iconNode$d = [
  ["line", { x1: "2", x2: "22", y1: "2", y2: "22", key: "a6p6uj" }],
  ["path", { d: "M18.89 13.23A7.12 7.12 0 0 0 19 12v-2", key: "80xlxr" }],
  ["path", { d: "M5 10v2a7 7 0 0 0 12 5", key: "p2k8kg" }],
  ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
  ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }],
  ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
];
var MicOff = createLucideIcon("mic-off", __iconNode$d);
var __iconNode$c = [
  ["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z", key: "131961" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
];
var Mic = createLucideIcon("mic", __iconNode$c);
var __iconNode$b = [
  ["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z", key: "a7tn18" }]
];
var Moon = createLucideIcon("moon", __iconNode$b);
var __iconNode$a = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }],
  ["path", { d: "m16 15-3-3 3-3", key: "14y99z" }]
];
var PanelLeftClose = createLucideIcon("panel-left-close", __iconNode$a);
var __iconNode$9 = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }],
  ["path", { d: "m8 9 3 3-3 3", key: "12hl5m" }]
];
var PanelRightClose = createLucideIcon("panel-right-close", __iconNode$9);
var __iconNode$8 = [
  ["path", { d: "M13 2a9 9 0 0 1 9 9", key: "1itnx2" }],
  ["path", { d: "M13 6a5 5 0 0 1 5 5", key: "11nki7" }],
  [
    "path",
    {
      d: "M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384",
      key: "9njp5v"
    }
  ]
];
var PhoneCall = createLucideIcon("phone-call", __iconNode$8);
var __iconNode$7 = [
  [
    "path",
    {
      d: "M10.1 13.9a14 14 0 0 0 3.732 2.668 1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2 18 18 0 0 1-12.728-5.272",
      key: "1wngk7"
    }
  ],
  ["path", { d: "M22 2 2 22", key: "y4kqgn" }],
  [
    "path",
    {
      d: "M4.76 13.582A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 .244.473",
      key: "10hv5p"
    }
  ]
];
var PhoneOff = createLucideIcon("phone-off", __iconNode$7);
var __iconNode$6 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
];
var Send = createLucideIcon("send", __iconNode$6);
var __iconNode$5 = [
  ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }],
  ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }],
  ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]
];
var Sun = createLucideIcon("sun", __iconNode$5);
var __iconNode$4 = [
  [
    "path",
    { d: "M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196", key: "w8jjjt" }
  ],
  ["path", { d: "M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2", key: "1xawa7" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
];
var VideoOff = createLucideIcon("video-off", __iconNode$4);
var __iconNode$3 = [
  [
    "path",
    {
      d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
      key: "ftymec"
    }
  ],
  ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
];
var Video = createLucideIcon("video", __iconNode$3);
var __iconNode$2 = [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
  ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
];
var Volume2 = createLucideIcon("volume-2", __iconNode$2);
var __iconNode$1 = [
  ["path", { d: "M16 9a5 5 0 0 1 .95 2.293", key: "1fgyg8" }],
  ["path", { d: "M19.364 5.636a9 9 0 0 1 1.889 9.96", key: "l3zxae" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  [
    "path",
    {
      d: "m7 7-.587.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298V11",
      key: "1gbwow"
    }
  ],
  ["path", { d: "M9.828 4.172A.686.686 0 0 1 11 4.657v.686", key: "s2je0y" }]
];
var VolumeOff = createLucideIcon("volume-off", __iconNode$1);
var __iconNode = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
];
var X2 = createLucideIcon("x", __iconNode);
var VolumeIcon = Volume2;
var VolumeOffIcon = VolumeOff;
var EllipsisIcon = Ellipsis;
var LoaderIcon = LoaderCircle;
var SelectChevronIcon = ChevronsUpDown;
var XIcon = X2;
var PhoneCallIcon = PhoneCall;
var PhoneCallEndIcon = PhoneOff;
var ArrowDownIcon = ArrowDown;
var ChevronDownIcon = ChevronDown;
var ChevronUpIcon = ChevronUp;
var MicIcon = Mic;
var MicOffIcon = MicOff;
var SendIcon = Send;
var MoonIcon = Moon;
var SunIcon = Sun;
var CheckIcon = Check;
var ChevronRightIcon = ChevronRight;
var CircleIcon = Circle;
var EllipsisVerticalIcon = EllipsisVertical;
var VideoOffIcon = VideoOff;
var LineChartIcon = ChartLine;
var MessagesSquareIcon = MessagesSquare;
var FunnelIcon = Funnel;
var VideoIcon = Video;
var BotIcon = Bot;
var ChevronsLeftRightEllipsisIcon = ChevronsLeftRightEllipsis;
var InfoIcon = Info;
var LogoutIcon = LogOut;
var CircleAlertIcon = CircleAlert;
var PanelRightCloseIcon = PanelRightClose;
var PanelLeftCloseIcon = PanelLeftClose;
function getPipecatUiNamespace() {
  return ".voice-ui-kit";
}
function getPipecatUIContainer() {
  return document.querySelector(getPipecatUiNamespace()) ?? document.body;
}
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx;
var cva = (base, config) => (props2) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props2 === null || props2 === void 0 ? void 0 : props2.class, props2 === null || props2 === void 0 ? void 0 : props2.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props2 === null || props2 === void 0 ? void 0 : props2[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props2 && Object.entries(props2).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props2 === null || props2 === void 0 ? void 0 : props2.class, props2 === null || props2 === void 0 ? void 0 : props2.className);
};
var selectTriggerVariants = cva(
  "vkui:border-input vkui:text-foreground vkui:data-[placeholder]:text-muted-foreground vkui:font-mono vkui:text-xs vkui:[&_svg:not([class*='text-'])]:text-muted-foreground vkui:focus-visible:border-ring vkui:focus-visible:ring-ring/50 vkui:aria-invalid:ring-destructive/20 vkui:dark:aria-invalid:ring-destructive/40 vkui:aria-invalid:border-destructive vkui:dark:bg-input/30 vkui:dark:hover:bg-input/50 vkui:flex w-fit vkui:items-center vkui:justify-between vkui:rounded-element vkui:border vkui:bg-transparent vkui:whitespace-nowrap vkui:transition-[color,box-shadow] vkui:outline-none vkui:focus-visible:ring-[3px] vkui:disabled:cursor-not-allowed vkui:disabled:opacity-50 vkui:*:data-[slot=select-value]:line-clamp-1 vkui:*:data-[slot=select-value]:flex vkui:*:data-[slot=select-value]:items-center vkui:*:data-[slot=select-value]:gap-2 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "",
        ghost: "vkui:border-none  vkui:hover:bg-accent"
      },
      size: {
        default: "vkui:h-8 vkui:pl-3 vkui:pr-2.5 vkui:py-2 vkui:gap-2 vkui:[&_svg]:size-3.5",
        sm: "vkui:h-7 vkui:pl-3 vkui:pr-2.5 vkui:py-1.5 vkui:gap-2 vkui:[&_svg]:size-3.5",
        lg: "vkui:h-10 vkui:px-3.5 vkui:py-2.5 vkui:gap-3 vkui:[&_svg]:size-4"
      }
    },
    defaultVariants: {
      size: "default",
      variant: "default"
    }
  }
);
function Select({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Root2$3, { "data-slot": "select", ...props2 });
}
function SelectGroup({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Group$1, { "data-slot": "select-group", ...props2 });
}
function SelectValue({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Value, { "data-slot": "select-value", ...props2 });
}
function SelectTrigger({
  className,
  size: size2 = "default",
  variant = "default",
  children,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsxs)(
    Trigger$4,
    {
      "data-slot": "select-trigger",
      "data-size": size2,
      className: cn(
        selectTriggerVariants({ size: size2, variant }),
        "vkui:truncate",
        className
      ),
      ...props2,
      children: [
        (0, import_jsx_runtime2.jsx)("span", { className: "vkui:truncate vkui:flex-1 vkui:min-w-0", children }),
        (0, import_jsx_runtime2.jsx)(Icon$1, { asChild: true, children: (0, import_jsx_runtime2.jsx)(SelectChevronIcon, { className: "vkui:opacity-50 vkui:flex-none" }) })
      ]
    }
  );
}
function SelectGuide({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "span",
    {
      "data-slot": "select-guide",
      className: cn("vkui:text-subtle vkui:font-sans", className),
      ...props2
    }
  );
}
function SelectContent({
  className,
  children,
  position = "popper",
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Portal$3, { container: getPipecatUIContainer(), children: (0, import_jsx_runtime2.jsxs)(
    Content2$4,
    {
      "data-slot": "select-content",
      className: cn(
        "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:relative vkui:z-50 vkui:max-h-(--radix-select-content-available-height) vkui:min-w-[8rem] vkui:origin-(--radix-select-content-transform-origin) vkui:overflow-x-hidden vkui:overflow-y-auto vkui:rounded-md vkui:border vkui:shadow-md",
        position === "popper" && "vkui:data-[side=bottom]:translate-y-1 vkui:data-[side=left]:-translate-x-1 vkui:data-[side=right]:translate-x-1 vkui:data-[side=top]:-translate-y-1",
        className
      ),
      position,
      ...props2,
      children: [
        (0, import_jsx_runtime2.jsx)(SelectScrollUpButton, {}),
        (0, import_jsx_runtime2.jsx)(
          Viewport,
          {
            className: cn(
              "vkui:p-1",
              position === "popper" && "vkui:h-[var(--radix-select-trigger-height)] vkui:w-full vkui:min-w-[var(--radix-select-trigger-width)] vkui:scroll-my-1"
            ),
            children
          }
        ),
        (0, import_jsx_runtime2.jsx)(SelectScrollDownButton, {})
      ]
    }
  ) });
}
function SelectItem({
  className,
  children,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsxs)(
    Item$1,
    {
      "data-slot": "select-item",
      className: cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:[&_svg:not([class*='text-'])]:text-muted-foreground vkui:relative vkui:flex vkui:w-full vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-sm vkui:py-1.5 vkui:pr-8 vkui:pl-2 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 [&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4 vkui:*:[span]:last:flex vkui:*:[span]:last:items-center vkui:*:[span]:last:gap-2",
        className
      ),
      ...props2,
      children: [
        (0, import_jsx_runtime2.jsx)("span", { className: "vkui:absolute vkui:right-2 vkui:flex vkui:size-3.5 vkui:items-center vkui:justify-center", children: (0, import_jsx_runtime2.jsx)(ItemIndicator$1, { children: (0, import_jsx_runtime2.jsx)(CheckIcon, { className: "size-4" }) }) }),
        (0, import_jsx_runtime2.jsx)(ItemText, { children })
      ]
    }
  );
}
function SelectSeparator({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Separator$1,
    {
      "data-slot": "select-separator",
      className: cn(
        "vkui:bg-border vkui:pointer-events-none vkui:-mx-1 vkui:my-1 vkui:h-px",
        className
      ),
      ...props2
    }
  );
}
function SelectScrollUpButton({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    ScrollUpButton,
    {
      "data-slot": "select-scroll-up-button",
      className: cn(
        "vkui:flex vkui:cursor-default vkui:items-center vkui:justify-center vkui:py-1",
        className
      ),
      ...props2,
      children: (0, import_jsx_runtime2.jsx)(ChevronUpIcon, { className: "size-4" })
    }
  );
}
function SelectScrollDownButton({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    ScrollDownButton,
    {
      "data-slot": "select-scroll-down-button",
      className: cn(
        "vkui:flex vkui:cursor-default vkui:items-center vkui:justify-center vkui:py-1",
        className
      ),
      ...props2,
      children: (0, import_jsx_runtime2.jsx)(ChevronDownIcon, { className: "size-4" })
    }
  );
}
var AudioOutput = ({ className }) => {
  const { availableSpeakers, selectedSpeaker, updateSpeaker } = $f934f1f8b10aaf19$export$642bc4d2d2a376f1();
  const handleDeviceChange = (deviceId) => {
    updateSpeaker(deviceId);
  };
  const id = (0, import_react2.useId)();
  return (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:flex vkui:items-center vkui:gap-4", children: [
    (0, import_jsx_runtime2.jsx)(
      "label",
      {
        htmlFor: id,
        className: "vkui:text-sm vkui:font-medium vkui:text-muted-foreground vkui:whitespace-nowrap vkui:flex-1",
        children: "Audio Output"
      }
    ),
    (0, import_jsx_runtime2.jsxs)(
      Select,
      {
        value: (selectedSpeaker == null ? void 0 : selectedSpeaker.deviceId) || "",
        onValueChange: handleDeviceChange,
        children: [
          (0, import_jsx_runtime2.jsx)(SelectTrigger, { id, className, variant: "ghost", children: (0, import_jsx_runtime2.jsx)(SelectValue, { placeholder: "Select a speaker" }) }),
          (0, import_jsx_runtime2.jsx)(SelectContent, { align: "end", children: availableSpeakers.map((device) => (0, import_jsx_runtime2.jsx)(
            SelectItem,
            {
              value: device.deviceId || "empty",
              children: device.label || `Speaker ${device.deviceId.slice(0, 5)}`
            },
            device.deviceId || "empty"
          )) })
        ]
      }
    )
  ] });
};
var DataList = ({
  data,
  classNames = {}
}) => {
  return (0, import_jsx_runtime2.jsx)(
    "dl",
    {
      className: cn(
        "vkui:text-sm vkui:grid vkui:grid-cols-[1fr_2fr] vkui:gap-2 vkui:items-center",
        classNames.container
      ),
      children: Object.entries(data).map(([key, value]) => (0, import_jsx_runtime2.jsxs)(import_react2.default.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)("dt", { className: cn("vkui:text-muted-foreground", classNames.key), children: key }),
        (0, import_jsx_runtime2.jsx)(
          "dd",
          {
            className: cn(
              "vkui:text-right vkui:font-mono vkui:text-xs vkui:min-w-0 vkui:truncate",
              classNames.value
            ),
            children: value
          }
        )
      ] }, key))
    }
  );
};
var ClientStatusComponent = ({
  className,
  transportState
}) => {
  return (0, import_jsx_runtime2.jsxs)(
    "span",
    {
      className: cn(
        "vkui:mono-upper vkui:text-muted-foreground vkui:font-medium vkui:flex vkui:items-center vkui:gap-1.5 vkui:leading-none vkui:justify-end",
        {
          "vkui:text-active": transportState === "connected" || transportState === "ready",
          "vkui:text-destructive": transportState === "error",
          "vkui:text-subtle/50 vkui:dark:text-subtle/80": transportState === "disconnected",
          "vkui:text-subtle": !transportState,
          "vkui:animate-pulse": [
            "initializing",
            "authenticating",
            "authenticated",
            "connecting"
          ].includes(transportState || "")
        },
        className
      ),
      children: [
        transportState || (0, import_jsx_runtime2.jsx)(TextDashBlankslate, {}),
        transportState && ["authenticating", "authenticated", "connecting"].includes(
          transportState
        ) && (0, import_jsx_runtime2.jsx)(LoaderIcon, { size: 12, className: "vkui:animate-spin" })
      ]
    }
  );
};
var ClientStatus = ({
  classNames = {},
  noAgentState = false,
  noClientState = false
}) => {
  const transportState = $33f3729bbe9f09df$export$30aee278309a867b();
  const [botStatus, setBotStatus] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (transportState === "connecting") {
      setBotStatus("connecting");
    }
  }, [transportState]);
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotReady, () => {
    if (noAgentState) return;
    setBotStatus("ready");
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotConnected, () => {
    if (noAgentState) return;
    setBotStatus("connected");
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.Disconnected, () => {
    if (noAgentState) return;
    setBotStatus("disconnected");
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotDisconnected, () => {
    if (noAgentState) return;
    setBotStatus("disconnected");
  });
  if (noAgentState && noClientState) return null;
  const data = {};
  if (!noClientState) {
    data["Client"] = (0, import_jsx_runtime2.jsx)(ClientStatusComponent, { transportState });
  }
  if (!noAgentState) {
    data["Agent"] = (0, import_jsx_runtime2.jsx)(ClientStatusComponent, { transportState: botStatus });
  }
  return (0, import_jsx_runtime2.jsx)(DataList, { classNames, data });
};
var buttonVariants = cva(
  "vkui:border vkui:inline-flex vkui:items-center vkui:justify-center vkui:gap-2 vkui:whitespace-nowrap vkui:rounded-element vkui:text-sm vkui:font-medium vkui:transition-all vkui:disabled:pointer-events-none vkui:disabled:opacity-50 vkui:[&_svg]:pointer-events-none vkui:shrink-0 vkui:[&_svg]:shrink-0 vkui:outline-none vkui:focus-visible:ring-ring/50 vkui:focus-visible:ring-[3px] vkui:aria-invalid:ring-destructive/20 vkui:dark:aria-invalid:ring-destructive/40 vkui:aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "vkui:bg-primary vkui:text-primary-foreground vkui:hover:bg-primary/90 vkui:border-transparent",
        secondary: "vkui:bg-secondary vkui:border-transparent vkui:text-secondary-foreground vkui:hover:bg-secondary/60 vkui:focus-visible:border-secondary",
        outline: "vkui:text-foreground vkui:border vkui:bg-background vkui:hover:bg-accent vkui:dark:bg-input/30 vkui:dark:border-input vkui:dark:hover:bg-input/50 vkui:focus-visible:border-ring",
        destructive: "vkui:bg-destructive vkui:border-transparent vkui:text-white vkui:hover:bg-destructive/90 vkui:focus-visible:ring-destructive/20 vkui:dark:focus-visible:ring-destructive/40 vkui:dark:bg-destructive/60",
        ghost: "vkui:text-foreground vkui:border vkui:border-transparent vkui:hover:bg-accent vkui:hover:text-accent-foreground vkui:dark:hover:bg-accent/50",
        link: "vkui:text-primary vkui:underline-offset-4 vkui:hover:underline vkui:border vkui:border-transparent",
        active: "vkui:bg-active vkui:border vkui:border-transparent vkui:text-active-foreground vkui:hover:bg-active/90 vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40",
        inactive: "vkui:bg-inactive vkui:border vkui:border-transparent vkui:text-inactive-foreground vkui:hover:bg-inactive/90 vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40"
      },
      size: {
        default: "vkui:h-8 vkui:px-4 vkui:py-2 vkui:has-[>svg]:px-3 vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:h-7 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4",
        sm: "vkui:h-7 vkui:rounded-element vkui:gap-1.5 vkui:px-3 vkui:has-[>svg]:px-2.5 vkui:[&_svg:not([class*='size-'])]:size-4 vkui:@max-xs/panel:h-6 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-3",
        lg: "vkui:h-10 vkui:rounded-element vkui:px-6 vkui:has-[>svg]:px-4 vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:h-9 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4",
        xl: "vkui:h-12 vkui:rounded-element vkui:px-8 vkui:text-lg vkui:has-[>svg]:px-6 vkui:[&_svg:not([class*='size-'])]:size-6 vkui:gap-3 vkui:@max-xs/panel:h-10 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-5",
        icon: "vkui:h-8 vkui:w-8 vkui:p-0 vkui:has-[>svg]:p-0 vkui:[&_svg:not([class*='size-'])]:size-5",
        "icon-sm": "vkui:h-7 vkui:w-7 vkui:p-0 vkui:has-[>svg]:p-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        "icon-xs": "vkui:h-6 vkui:w-6 vkui:p-0 vkui:has-[>svg]:p-0 vkui:[&_svg:not([class*='size-'])]:size-3"
      },
      state: {
        default: "",
        active: "",
        inactive: ""
      },
      isIcon: {
        true: "",
        false: ""
      }
    },
    compoundVariants: [
      {
        size: "default",
        isIcon: true,
        className: "vkui:size-8 vkui:@max-xs/panel:size-7 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4"
      },
      {
        size: "sm",
        isIcon: true,
        className: "vkui:size-7 vkui:@max-xs/panel:size-6 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-4 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-3"
      },
      {
        size: "lg",
        isIcon: true,
        className: "vkui:size-10 vkui:@max-xs/panel:size-9 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4"
      },
      {
        size: "xl",
        isIcon: true,
        className: "vkui:size-12 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4"
      },
      {
        variant: "default",
        state: "active",
        className: "vkui:bg-active vkui:text-active-foreground vkui:hover:bg-active/90 vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40"
      },
      {
        variant: "default",
        state: "inactive",
        className: "vkui:bg-inactive vkui:text-inactive-foreground vkui:hover:bg-inactive/90 vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40"
      },
      {
        variant: "secondary",
        state: "active",
        className: "vkui:bg-active vkui:text-active-foreground vkui:hover:bg-active/90 vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40 vkui:focus-visible:border-active"
      },
      {
        variant: "secondary",
        state: "inactive",
        className: "vkui:bg-inactive vkui:text-inactive-foreground vkui:hover:bg-inactive/90 vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40 vkui:focus-visible:border-inactive"
      },
      {
        variant: "outline",
        state: "active",
        className: "vkui:bg-active-accent vkui:text-active vkui:border-active vkui:hover:bg-active-accent/60 vkui:dark:bg-active-accent vkui:dark:hover:bg-active-accent/60 vkui:dark:border-active vkui:focus-visible:border-active vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40"
      },
      {
        variant: "outline",
        state: "inactive",
        className: "vkui:bg-inactive-accent vkui:text-inactive vkui:border-inactive vkui:hover:bg-inactive-accent/60 vkui:dark:bg-inactive-accent vkui:dark:hover:bg-inactive-accent/60 vkui:dark:border-inactive vkui:focus-visible:border-inactive vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40"
      }
    ],
    defaultVariants: {
      variant: "default",
      size: "default",
      state: "default",
      isIcon: false
    }
  }
);
var buttonAccentColorMap = {
  default: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-active"
  },
  secondary: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-active"
  },
  outline: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive",
    active: "--vkui-color-active"
  },
  destructive: {
    default: "--vkui-color-background",
    inactive: "--vkui-color-background",
    active: "--vkui-color-background"
  },
  ghost: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-border",
    active: "--vkui-color-active"
  },
  link: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive",
    active: "--vkui-color-active"
  },
  active: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-active"
  },
  inactive: {
    default: "--vkui-color-inactive",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-inactive"
  }
};
function Button({
  className,
  variant,
  size: size2,
  state,
  isIcon,
  isLoading = false,
  asChild = false,
  ...props2
}) {
  const Comp = asChild ? Slot$3 : "button";
  if (isLoading) {
    return (0, import_jsx_runtime2.jsxs)(
      Comp,
      {
        "data-slot": "button",
        className: cn(
          buttonVariants({ variant, size: size2, state, isIcon, className })
        ),
        ...props2,
        disabled: true,
        children: [
          (0, import_jsx_runtime2.jsx)(LoaderIcon, { className: "vkui:animate-spin" }),
          props2.children
        ]
      }
    );
  }
  return (0, import_jsx_runtime2.jsx)(
    Comp,
    {
      "data-slot": "button",
      className: cn(
        buttonVariants({ variant, size: size2, state, isIcon, className })
      ),
      ...props2
    }
  );
}
var ConnectButtonComponent = ({
  className: passedClassName,
  onClick,
  onConnect,
  onDisconnect,
  stateContent,
  size: size2 = "default",
  transportState
}) => {
  const getButtonProps = () => {
    if (stateContent && stateContent[transportState]) {
      return stateContent[transportState];
    }
    switch (transportState) {
      case "disconnected":
      case "initialized":
        return {
          children: "Connect",
          variant: "active"
        };
      case "initializing":
        return {
          children: "Initializing...",
          variant: "secondary"
        };
      case "ready":
        return {
          children: "Disconnect",
          variant: "destructive"
        };
      case "disconnecting":
        return { children: "Disconnecting...", variant: "secondary" };
      case "error":
        return { children: "Error", variant: "destructive" };
      default:
        return { children: "Connecting...", variant: "secondary" };
    }
  };
  const { children, className, variant } = getButtonProps();
  const handleClick = () => {
    onClick == null ? void 0 : onClick();
    if (["ready", "connected"].includes(transportState)) {
      onDisconnect == null ? void 0 : onDisconnect();
    } else {
      onConnect == null ? void 0 : onConnect();
    }
  };
  return (0, import_jsx_runtime2.jsx)(
    Button,
    {
      onClick: handleClick,
      variant,
      size: size2,
      disabled: !["disconnected", "ready", "initialized"].includes(transportState),
      isLoading: !["disconnected", "ready", "error", "initialized"].includes(
        transportState
      ),
      className: cn(className, passedClassName),
      children
    }
  );
};
var ConnectButton = (0, import_react2.memo)((props2) => {
  const transportState = $33f3729bbe9f09df$export$30aee278309a867b();
  return (0, import_jsx_runtime2.jsx)(ConnectButtonComponent, { transportState, ...props2 });
});
ConnectButton.displayName = "ConnectButton";
var TextDashBlankslate = ({ className }) => {
  return (0, import_jsx_runtime2.jsx)("span", { className: cn("vkui:mono-upper vkui:text-subtle/60", className), children: "---" });
};
var buttonGroupVariants = cva(
  "vkui:flex vkui:items-center vkui:button-group",
  {
    variants: {
      orientation: {
        horizontal: "vkui:flex-row vkui:*:first:rounded-e-none vkui:*:last:rounded-s-none vkui:*:-ml-[1px] vkui:*:first:ml-0",
        vertical: "vkui:flex-col vkui:*:first:rounded-b-none vkui:*:last:rounded-t-none vkui:*:-mt-[1px] vkui:*:first:mt-0 vkui:*:self-stretch"
      }
    },
    defaultVariants: {
      orientation: "horizontal"
    }
  }
);
var ButtonGroup = ({
  className,
  orientation = "horizontal",
  children,
  ...props2
}) => {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: cn(
        "vkui:flex",
        buttonGroupVariants({ orientation }),
        className
      ),
      ...props2,
      children
    }
  );
};
var cardVariants = cva("vkui:text-card-foreground vkui:flex vkui:flex-col", {
  variants: {
    size: {
      default: "vkui:gap-2 vkui:p-2 vkui:rounded-element vkui:shadow-short",
      sm: "vkui:gap-1 vkui:p-1 vkui:rounded-md vkui:shadow-xshort",
      lg: "vkui:gap-3 vkui:p-3 vkui:rounded-2xl vkui:shadow-long"
    }
  }
});
function Card({
  className,
  noGradientBorder = false,
  noShadow = false,
  size: size2 = "default",
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "card",
      className: cn(
        cardVariants({ size: size2 }),
        noShadow && "vkui:shadow-none",
        noGradientBorder && "vkui:bg-card vkui:border vkui:border-border",
        !noGradientBorder && "vkui:border vkui:border-transparent vkui:bg-origin-border vkui:borderclip vkui:bg-cardGradientBorder",
        props2.destructive && "vkui:text-destructive vkui:border-destructive",
        className
      ),
      ...props2
    }
  );
}
function CardHeader({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "card-header",
      className: cn(
        "vkui:flex vkui:gap-2 vkui:md:gap-3 vkui:p-2 vkui:md:p-3",
        className
      ),
      ...props2
    }
  );
}
function CardTitle({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "card-title",
      className: cn("vkui:leading-none vkui:font-semibold", className),
      ...props2
    }
  );
}
function CardDescription({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "card-description",
      className: cn("vkui:text-muted-foreground vkui:text-sm", className),
      ...props2
    }
  );
}
function CardAction({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "card-action",
      className: cn(
        "vkui:col-start-2 vkui:row-span-2 vkui:row-start-1 vkui:self-start vkui:justify-self-end",
        className
      ),
      ...props2
    }
  );
}
function CardContent({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "card-content",
      className: cn("vkui:gap-2 vkui:md:gap-3 vkui:p-2 vkui:md:p-3", className),
      ...props2
    }
  );
}
function CardFooter({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "card-footer",
      className: cn(
        "vkui:flex vkui:gap-2 vkui:md:gap-3 vkui:p-2 vkui:md:p-3",
        className
      ),
      ...props2
    }
  );
}
function FullScreenContainer({
  className,
  horizontal = false,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: cn(
        "vkui:w-full vkui:h-dvh vkui:bg-background vkui:flex vkui:items-center vkui:justify-center vkui:flex-col",
        horizontal && "vkui:flex-row",
        className
      ),
      ...props2
    }
  );
}
function useStateMachine(initialState2, machine) {
  return React.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props2) => {
  const { present, children } = props2;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React.useState();
  const stylesRef = React.useRef(null);
  const prevPresentRef = React.useRef(present);
  const prevAnimationNameRef = React.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef(element) {
  var _a3, _b;
  let getter = (_a3 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a3.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$2 = "RovingFocusGroup";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(GROUP_NAME$2);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$2,
  [createCollectionScope$1]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$2);
var RovingFocusGroup = React.forwardRef(
  (props2, forwardedRef) => {
    return (0, import_jsx_runtime2.jsx)(Collection$1.Provider, { scope: props2.__scopeRovingFocusGroup, children: (0, import_jsx_runtime2.jsx)(Collection$1.Slot, { scope: props2.__scopeRovingFocusGroup, children: (0, import_jsx_runtime2.jsx)(RovingFocusGroupImpl, { ...props2, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$2;
var RovingFocusGroupImpl = React.forwardRef((props2, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props2;
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME$2
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$1(__scopeRovingFocusGroup);
  const isClickFocusRef = React.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return (0, import_jsx_runtime2.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: (0, import_jsx_runtime2.jsx)(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props2.style },
          onMouseDown: composeEventHandlers(props2.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props2.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst$1(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props2.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$2 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props2;
    const autoId = useId$1();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$2, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection$1(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return (0, import_jsx_runtime2.jsx)(
      Collection$1.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: (0, import_jsx_runtime2.jsx)(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props2.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props2.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$1(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$1(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$2;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$1(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root = RovingFocusGroup;
var Item = RovingFocusGroupItem;
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection, useCollection, createCollectionScope] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$2 = createPopperScope();
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props2) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props2;
  const popperScope = usePopperScope$2(__scopeMenu);
  const [content, setContent] = React.useState(null);
  const isUsingKeyboardRef = React.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  React.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return (0, import_jsx_runtime2.jsx)(Root2$4, { ...popperScope, children: (0, import_jsx_runtime2.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: (0, import_jsx_runtime2.jsx)(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME$1 = "MenuAnchor";
var MenuAnchor = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props2;
    const popperScope = usePopperScope$2(__scopeMenu);
    return (0, import_jsx_runtime2.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME$1;
var PORTAL_NAME$3 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var MenuPortal = (props2) => {
  const { __scopeMenu, forceMount, children, container } = props2;
  const context = useMenuContext(PORTAL_NAME$3, __scopeMenu);
  return (0, import_jsx_runtime2.jsx)(PortalProvider$2, { scope: __scopeMenu, forceMount, children: (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime2.jsx)(Portal$4, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$3;
var CONTENT_NAME$4 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$4);
var MenuContent = React.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$4, props2.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props2;
    const context = useMenuContext(CONTENT_NAME$4, props2.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$4, props2.__scopeMenu);
    return (0, import_jsx_runtime2.jsx)(Collection.Provider, { scope: props2.__scopeMenu, children: (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime2.jsx)(Collection.Slot, { scope: props2.__scopeMenu, children: rootContext.modal ? (0, import_jsx_runtime2.jsx)(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime2.jsx)(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React.forwardRef(
  (props2, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$4, props2.__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime2.jsx)(
      MenuContentImpl,
      {
        ...props2,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props2.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React.forwardRef((props2, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME$4, props2.__scopeMenu);
  return (0, import_jsx_runtime2.jsx)(
    MenuContentImpl,
    {
      ...props2,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot$1 = createSlot("MenuContent.ScrollLock");
var MenuContentImpl = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props2;
    const context = useMenuContext(CONTENT_NAME$4, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$4, __scopeMenu);
    const popperScope = usePopperScope$2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeMenu);
    const getItems = useCollection(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React.useState(null);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React.useRef(0);
    const searchRef = React.useRef("");
    const pointerGraceTimerRef = React.useRef(0);
    const pointerGraceIntentRef = React.useRef(null);
    const pointerDirRef = React.useRef("right");
    const lastPointerXRef = React.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll : React.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot$1, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a3, _b;
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a3 = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a3.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React.useCallback((event) => {
      var _a3, _b;
      const isMovingTowards = pointerDirRef.current === ((_a3 = pointerGraceIntentRef.current) == null ? void 0 : _a3.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b = pointerGraceIntentRef.current) == null ? void 0 : _b.area);
    }, []);
    return (0, import_jsx_runtime2.jsx)(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React.useCallback(
          (event) => {
            var _a3;
            if (isPointerMovingToSubmenu(event)) return;
            (_a3 = contentRef.current) == null ? void 0 : _a3.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: (0, import_jsx_runtime2.jsx)(ScrollLockWrapper, { ...scrollLockWrapperProps, children: (0, import_jsx_runtime2.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a3;
              event.preventDefault();
              (_a3 = contentRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: (0, import_jsx_runtime2.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: (0, import_jsx_runtime2.jsx)(
                  Root,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: (0, import_jsx_runtime2.jsx)(
                      Content$1,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props2.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props2.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$4;
var GROUP_NAME$1 = "MenuGroup";
var MenuGroup = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props2;
    return (0, import_jsx_runtime2.jsx)(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "MenuLabel";
var MenuLabel = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props2;
    return (0, import_jsx_runtime2.jsx)(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$1 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React.forwardRef(
  (props2, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props2;
    const ref = React.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$1, props2.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$1, props2.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return (0, import_jsx_runtime2.jsx)(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props2.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a3;
          (_a3 = props2.onPointerDown) == null ? void 0 : _a3.call(props2, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props2.onPointerUp, (event) => {
          var _a3;
          if (!isPointerDownRef.current) (_a3 = event.currentTarget) == null ? void 0 : _a3.click();
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$1;
var MenuItemImpl = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props2;
    const contentContext = useMenuContentContext(ITEM_NAME$1, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React.useState(false);
    const [textContent, setTextContent] = React.useState("");
    React.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return (0, import_jsx_runtime2.jsx)(
      Collection.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: (0, import_jsx_runtime2.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: (0, import_jsx_runtime2.jsx)(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props2.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props2.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props2.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props2.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem";
var MenuCheckboxItem = React.forwardRef(
  (props2, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props2;
    return (0, import_jsx_runtime2.jsx)(ItemIndicatorProvider, { scope: props2.__scopeMenu, checked, children: (0, import_jsx_runtime2.jsx)(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$1 = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME$1,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React.forwardRef(
  (props2, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props2;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return (0, import_jsx_runtime2.jsx)(RadioGroupProvider, { scope: props2.__scopeMenu, value, onValueChange: handleValueChange, children: (0, import_jsx_runtime2.jsx)(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME$1 = "MenuRadioItem";
var MenuRadioItem = React.forwardRef(
  (props2, forwardedRef) => {
    const { value, ...radioItemProps } = props2;
    const context = useRadioGroupContext(RADIO_ITEM_NAME$1, props2.__scopeMenu);
    const checked = value === context.value;
    return (0, import_jsx_runtime2.jsx)(ItemIndicatorProvider, { scope: props2.__scopeMenu, checked, children: (0, import_jsx_runtime2.jsx)(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a3;
            return (_a3 = context.onValueChange) == null ? void 0 : _a3.call(context, value);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props2;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return (0, import_jsx_runtime2.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: (0, import_jsx_runtime2.jsx)(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME$1 = "MenuSeparator";
var MenuSeparator = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props2;
    return (0, import_jsx_runtime2.jsx)(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$3 = "MenuArrow";
var MenuArrow = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props2;
    const popperScope = usePopperScope$2(__scopeMenu);
    return (0, import_jsx_runtime2.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props2) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props2;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope$2(__scopeMenu);
  const [trigger, setTrigger] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  React.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return (0, import_jsx_runtime2.jsx)(Root2$4, { ...popperScope, children: (0, import_jsx_runtime2.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: (0, import_jsx_runtime2.jsx)(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId$1(),
          triggerId: useId$1(),
          trigger,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME$1 = "MenuSubTrigger";
var MenuSubTrigger = React.forwardRef(
  (props2, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME$1, props2.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$1, props2.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$1, props2.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$1, props2.__scopeMenu);
    const openTimerRef = React.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props2.__scopeMenu };
    const clearOpenTimer = React.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return (0, import_jsx_runtime2.jsx)(MenuAnchor, { asChild: true, ...scope, children: (0, import_jsx_runtime2.jsx)(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props2,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a3;
          (_a3 = props2.onClick) == null ? void 0 : _a3.call(props2, event);
          if (props2.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props2.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props2.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props2.onPointerLeave,
          whenMouse((event) => {
            var _a3, _b;
            clearOpenTimer();
            const contentRect = (_a3 = context.content) == null ? void 0 : _a3.getBoundingClientRect();
            if (contentRect) {
              const side = (_b = context.content) == null ? void 0 : _b.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          var _a3;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props2.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a3 = context.content) == null ? void 0 : _a3.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent";
var MenuSubContent = React.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$4, props2.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props2;
    const context = useMenuContext(CONTENT_NAME$4, props2.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$4, props2.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$1, props2.__scopeMenu);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return (0, import_jsx_runtime2.jsx)(Collection.Provider, { scope: props2.__scopeMenu, children: (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime2.jsx)(Collection.Slot, { scope: props2.__scopeMenu, children: (0, import_jsx_runtime2.jsx)(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a3;
          if (rootContext.isUsingKeyboardRef.current) (_a3 = ref.current) == null ? void 0 : _a3.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props2.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props2.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          var _a3;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a3 = subContext.trigger) == null ? void 0 : _a3.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v2) => v2 !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const ii2 = polygon[i2];
    const jj = polygon[j2];
    const xi = ii2.x;
    const yi2 = ii2.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi2 > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi2) / (yj - yi2) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$1 = Menu;
var Anchor2$1 = MenuAnchor;
var Portal$2 = MenuPortal;
var Content2$3 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2$1 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow2$1 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu$1 = (props2) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return (0, import_jsx_runtime2.jsx)(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId$1(),
      triggerRef,
      contentId: useId$1(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: (0, import_jsx_runtime2.jsx)(Root3$1, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu$1.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$3 = "DropdownMenuTrigger";
var DropdownMenuTrigger$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props2;
    const context = useDropdownMenuContext(TRIGGER_NAME$3, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime2.jsx)(Anchor2$1, { asChild: true, ...menuScope, children: (0, import_jsx_runtime2.jsx)(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props2.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger$1.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$2 = "DropdownMenuPortal";
var DropdownMenuPortal$1 = (props2) => {
  const { __scopeDropdownMenu, ...portalProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(Portal$2, { ...menuScope, ...portalProps });
};
DropdownMenuPortal$1.displayName = PORTAL_NAME$2;
var CONTENT_NAME$3 = "DropdownMenuContent";
var DropdownMenuContent$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props2;
    const context = useDropdownMenuContext(CONTENT_NAME$3, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React.useRef(false);
    return (0, import_jsx_runtime2.jsx)(
      Content2$3,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props2.onCloseAutoFocus, (event) => {
          var _a3;
          if (!hasInteractedOutsideRef.current) (_a3 = context.triggerRef.current) == null ? void 0 : _a3.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props2.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props2.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent$1.displayName = CONTENT_NAME$3;
var GROUP_NAME = "DropdownMenuGroup";
var DropdownMenuGroup$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime2.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup$1.displayName = GROUP_NAME;
var LABEL_NAME = "DropdownMenuLabel";
var DropdownMenuLabel$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime2.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "DropdownMenuItem";
var DropdownMenuItem$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime2.jsx)(Item2$1, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem$1.displayName = ITEM_NAME;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem$1 = React.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup$1 = React.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup$1.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem$1 = React.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME = "DropdownMenuSeparator";
var DropdownMenuSeparator$1 = React.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME$2 = "DropdownMenuArrow";
var DropdownMenuArrow = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime2.jsx)(Arrow2$1, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME$2;
var DropdownMenuSub$1 = (props2) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: "DropdownMenuSub"
  });
  return (0, import_jsx_runtime2.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger$1 = React.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger$1.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent$1 = React.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime2.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props2.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent$1.displayName = SUB_CONTENT_NAME;
var Root2$2 = DropdownMenu$1;
var Trigger$3 = DropdownMenuTrigger$1;
var Portal2 = DropdownMenuPortal$1;
var Content2$2 = DropdownMenuContent$1;
var Group2 = DropdownMenuGroup$1;
var Label2 = DropdownMenuLabel$1;
var Item2 = DropdownMenuItem$1;
var CheckboxItem2 = DropdownMenuCheckboxItem$1;
var RadioGroup2 = DropdownMenuRadioGroup$1;
var RadioItem2 = DropdownMenuRadioItem$1;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Separator2 = DropdownMenuSeparator$1;
var Sub2 = DropdownMenuSub$1;
var SubTrigger2 = DropdownMenuSubTrigger$1;
var SubContent2 = DropdownMenuSubContent$1;
function DropdownMenu({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Root2$2, { "data-slot": "dropdown-menu", ...props2 });
}
function DropdownMenuPortal({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Portal2,
    {
      container: getPipecatUIContainer(),
      "data-slot": "dropdown-menu-portal",
      ...props2
    }
  );
}
function DropdownMenuTrigger({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Trigger$3,
    {
      "data-slot": "dropdown-menu-trigger",
      ...props2
    }
  );
}
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(DropdownMenuPortal, { children: (0, import_jsx_runtime2.jsx)(
    Content2$2,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset,
      className: cn(
        "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:max-h-(--radix-dropdown-menu-content-available-height) vkui:min-w-[8rem] vkui:origin-(--radix-dropdown-menu-content-transform-origin) vkui:overflow-x-hidden vkui:overflow-y-auto vkui:rounded-element vkui:border vkui:p-1 vkui:shadow-short",
        className
      ),
      ...props2
    }
  ) });
}
function DropdownMenuGroup({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Group2, { "data-slot": "dropdown-menu-group", ...props2 });
}
function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Item2,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": inset,
      "data-variant": variant,
      className: cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:data-[variant=destructive]:text-destructive vkui:data-[variant=destructive]:focus:bg-destructive/10 vkui:dark:data-[variant=destructive]:focus:bg-destructive/20 vkui:data-[variant=destructive]:focus:text-destructive vkui:data-[variant=destructive]:*:[svg]:!text-destructive vkui:[&_svg:not([class*='text-'])]:text-muted-foreground vkui:relative vkui:flex vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-sm vkui:px-2 vkui:py-1.5 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 vkui:data-[inset]:pl-8 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        className
      ),
      ...props2
    }
  );
}
function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsxs)(
    CheckboxItem2,
    {
      "data-slot": "dropdown-menu-checkbox-item",
      className: cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:relative vkui:flex vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-sm vkui:py-1.5 vkui:pr-2 vkui:pl-8 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        checked && "vkui:font-medium vkui:bg-accent",
        className
      ),
      checked,
      ...props2,
      children: [
        (0, import_jsx_runtime2.jsx)("span", { className: "vkui:pointer-events-none vkui:absolute vkui:left-2 vkui:flex size-3.5 vkui:items-center vkui:justify-center", children: (0, import_jsx_runtime2.jsx)(ItemIndicator2, { children: (0, import_jsx_runtime2.jsx)(CheckIcon, {}) }) }),
        children
      ]
    }
  );
}
function DropdownMenuRadioGroup({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    RadioGroup2,
    {
      "data-slot": "dropdown-menu-radio-group",
      ...props2
    }
  );
}
function DropdownMenuRadioItem({
  className,
  children,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsxs)(
    RadioItem2,
    {
      "data-slot": "dropdown-menu-radio-item",
      className: cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:relative vkui:flex vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-panel vkui:py-1.5 vkui:pr-2 vkui:pl-8 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        className
      ),
      ...props2,
      children: [
        (0, import_jsx_runtime2.jsx)("span", { className: "vkui:pointer-events-none vkui:absolute vkui:left-2 vkui:flex vkui:size-3.5 vkui:items-center vkui:justify-center", children: (0, import_jsx_runtime2.jsx)(ItemIndicator2, { children: (0, import_jsx_runtime2.jsx)(CircleIcon, { className: "size-2 vkui:fill-current" }) }) }),
        children
      ]
    }
  );
}
function DropdownMenuLabel({
  className,
  inset,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Label2,
    {
      "data-slot": "dropdown-menu-label",
      "data-inset": inset,
      className: cn(
        "vkui:px-2 vkui:py-1.5 vkui:text-sm vkui:font-medium vkui:data-[inset]:pl-8",
        className
      ),
      ...props2
    }
  );
}
function DropdownMenuSeparator({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Separator2,
    {
      "data-slot": "dropdown-menu-separator",
      className: cn("vkui:bg-border vkui:-mx-1 vkui:my-1 vkui:h-px", className),
      ...props2
    }
  );
}
function DropdownMenuShortcut({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    "span",
    {
      "data-slot": "dropdown-menu-shortcut",
      className: cn(
        "vkui:text-muted-foreground vkui:ml-auto vkui:text-xs vkui:tracking-widest",
        className
      ),
      ...props2
    }
  );
}
function DropdownMenuSub({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Sub2, { "data-slot": "dropdown-menu-sub", ...props2 });
}
function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsxs)(
    SubTrigger2,
    {
      "data-slot": "dropdown-menu-sub-trigger",
      "data-inset": inset,
      className: cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:data-[state=open]:bg-accent vkui:data-[state=open]:text-accent-foreground vkui:flex vkui:cursor-default vkui:items-center vkui:rounded-sm vkui:px-2 vkui:py-1.5 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[inset]:pl-8",
        className
      ),
      ...props2,
      children: [
        children,
        (0, import_jsx_runtime2.jsx)(ChevronRightIcon, { className: "vkui:ml-auto vkui:size-4" })
      ]
    }
  );
}
function DropdownMenuSubContent({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    SubContent2,
    {
      "data-slot": "dropdown-menu-sub-content",
      className: cn(
        "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:min-w-[8rem] vkui:origin-(--radix-dropdown-menu-content-transform-origin) vkui:overflow-hidden vkui:rounded-md vkui:border vkui:p-1 vkui:shadow-lg",
        className
      ),
      ...props2
    }
  );
}
var ErrorCard = ({
  title = "An Error Occurred",
  error,
  className,
  noShadow = false
}) => {
  return (0, import_jsx_runtime2.jsxs)(
    Card,
    {
      className: cn(
        "vkui:shadow-long vkui:min-w-md vkui:gap-0",
        noShadow && "vkui:shadow-none",
        className
      ),
      destructive: true,
      children: [
        (0, import_jsx_runtime2.jsxs)(CardHeader, { className: "vkui:font-semibold vkui:flex vkui:flex-row vkui:items-center", children: [
          (0, import_jsx_runtime2.jsx)(InfoIcon, { size: 24 }),
          title
        ] }),
        (0, import_jsx_runtime2.jsx)(CardContent, { children: (0, import_jsx_runtime2.jsx)("p", { className: "vkui:text-sm vkui:text-balanced", children: error }) })
      ]
    }
  );
};
var inputVariants = cva(
  "vkui:file:text-foreground vkui:placeholder:text-muted-foreground vkui:selection:bg-primary vkui:selection:text-primary-foreground vkui:dark:bg-input/30 vkui:border-input vkui:flex vkui:w-full vkui:min-w-0 vkui:rounded-md vkui:border vkui:bg-transparent vkui:px-3 vkui:text-foreground vkui:transition-[color,box-shadow] vkui:outline-none vkui:file:inline-flex vkui:file:border-0 vkui:file:bg-transparent vkui:file:text-sm vkui:file:font-medium vkui:disabled:pointer-events-none vkui:disabled:cursor-not-allowed vkui:disabled:opacity-50 vkui:md:text-sm vkui:focus-visible:border-ring vkui:focus-visible:ring-ring/50 vkui:focus-visible:ring-[3px] vkui:aria-invalid:ring-destructive/20 vkui:dark:aria-invalid:ring-destructive/40 vkui:aria-invalid:border-destructive",
  {
    variants: {
      size: {
        sm: "vkui:h-7 vkui:px-2.5 vkui:py-1 vkui:text-sm",
        default: "vkui:h-8 vkui:px-3 vkui:py-1",
        lg: "vkui:h-10 vkui:px-3 vkui:py-2 vkui:rounded-lg"
      }
    },
    defaultVariants: {
      size: "default"
    }
  }
);
function Input({
  className,
  type,
  size: size2,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    "input",
    {
      type,
      "data-slot": "input",
      className: cn(inputVariants({ size: size2, className })),
      ...props2
    }
  );
}
function LayoutSection({
  className,
  sectionKey,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)("section", { "data-section": sectionKey, className: cn(className), ...props2 });
}
var LoaderSpinner = ({ size: size2 = 32 }) => {
  return (0, import_jsx_runtime2.jsx)(LoaderIcon, { className: "vkui:animate-spin vkui:opacity-50", size: size2 });
};
function Panel$1({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "panel",
      className: cn(
        "vkui:group vkui:@container/panel vkui:bg-card vkui:text-card-foreground vkui:flex vkui:flex-col vkui:rounded-panel vkui:border",
        className
      ),
      ...props2
    }
  );
}
var PanelHeaderVariants = cva("vkui:@container/panel-header", {
  variants: {
    variant: {
      default: "vkui:border-b vkui:flex vkui:items-center vkui:justify-center vkui:text-card-foreground vkui:p-2 vkui:@xs/panel:p-3 vkui:@md/panel:p-4",
      inline: "vkui:items-start vkui:text-foreground vkui:p-2 vkui:@xs/panel:p-3 vkui:@md/panel:p-4 vkui:group-has-data-[slot=panel-content]:pb-0",
      noPadding: "vkui:border-b vkui:flex vkui:items-center vkui:justify-center vkui:text-card-foreground"
    }
  },
  defaultVariants: {
    variant: "default"
  }
});
function PanelHeader({
  variant,
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "panel-header",
      className: cn(PanelHeaderVariants({ variant }), className),
      ...props2
    }
  );
}
function PanelTitle({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "panel-title",
      className: cn("vkui:mono-upper", className),
      ...props2
    }
  );
}
function PanelContent({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "panel-content",
      className: cn(
        "vkui:text-foreground vkui:flex vkui:flex-col vkui:gap-2 vkui:p-2 vkui:@xs/panel:p-3 vkui:@xs/panel:gap-3 vkui:@md/panel:p-4 vkui:@md/panel:gap-4",
        className
      ),
      ...props2
    }
  );
}
function PanelFooter({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "panel-footer",
      className: cn(
        "vkui:flex vkui:items-center vkui:p-2 vkui:@xs/panel:p-3 vkui:@md/panel:p-4",
        className
      ),
      ...props2
    }
  );
}
function PanelActions({ className, ...props2 }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      "data-slot": "panel-actions",
      className: cn(
        "vkui:flex vkui:items-center vkui:gap-1 vkui:@xs/panel:gap-2",
        className
      ),
      ...props2
    }
  );
}
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover$1 = (props2) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props2;
  const popperScope = usePopperScope$1(__scopePopover);
  const triggerRef = React.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return (0, import_jsx_runtime2.jsx)(Root2$4, { ...popperScope, children: (0, import_jsx_runtime2.jsx)(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId$1(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover$1.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props2;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope$1(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return (0, import_jsx_runtime2.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor$1.displayName = ANCHOR_NAME;
var TRIGGER_NAME$2 = "PopoverTrigger";
var PopoverTrigger$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props2;
    const context = usePopoverContext(TRIGGER_NAME$2, __scopePopover);
    const popperScope = usePopperScope$1(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = (0, import_jsx_runtime2.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props2.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : (0, import_jsx_runtime2.jsx)(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger$1.displayName = TRIGGER_NAME$2;
var PORTAL_NAME$1 = "PopoverPortal";
var [PortalProvider$1, usePortalContext$1] = createPopoverContext(PORTAL_NAME$1, {
  forceMount: void 0
});
var PopoverPortal = (props2) => {
  const { __scopePopover, forceMount, children, container } = props2;
  const context = usePopoverContext(PORTAL_NAME$1, __scopePopover);
  return (0, import_jsx_runtime2.jsx)(PortalProvider$1, { scope: __scopePopover, forceMount, children: (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime2.jsx)(Portal$4, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$2 = "PopoverContent";
var PopoverContent$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$2, props2.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props2;
    const context = usePopoverContext(CONTENT_NAME$2, props2.__scopePopover);
    return (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime2.jsx)(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime2.jsx)(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent$1.displayName = CONTENT_NAME$2;
var Slot = createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = React.forwardRef(
  (props2, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$2, props2.__scopePopover);
    const contentRef = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React.useRef(false);
    React.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime2.jsx)(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: (0, import_jsx_runtime2.jsx)(
      PopoverContentImpl,
      {
        ...props2,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props2.onCloseAutoFocus, (event) => {
          var _a3;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a3 = context.triggerRef.current) == null ? void 0 : _a3.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props2.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props2.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React.forwardRef(
  (props2, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$2, props2.__scopePopover);
    const hasInteractedOutsideRef = React.useRef(false);
    const hasPointerDownOutsideRef = React.useRef(false);
    return (0, import_jsx_runtime2.jsx)(
      PopoverContentImpl,
      {
        ...props2,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a3, _b;
          (_a3 = props2.onCloseAutoFocus) == null ? void 0 : _a3.call(props2, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a3, _b;
          (_a3 = props2.onInteractOutside) == null ? void 0 : _a3.call(props2, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props2;
    const context = usePopoverContext(CONTENT_NAME$2, __scopePopover);
    const popperScope = usePopperScope$1(__scopePopover);
    useFocusGuards();
    return (0, import_jsx_runtime2.jsx)(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: (0, import_jsx_runtime2.jsx)(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: (0, import_jsx_runtime2.jsx)(
              Content$1,
              {
                "data-state": getState(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props2;
    const context = usePopoverContext(CLOSE_NAME, __scopePopover);
    return (0, import_jsx_runtime2.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props2.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME$1 = "PopoverArrow";
var PopoverArrow = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props2;
    const popperScope = usePopperScope$1(__scopePopover);
    return (0, import_jsx_runtime2.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME$1;
function getState(open) {
  return open ? "open" : "closed";
}
var Root2$1 = Popover$1;
var Anchor2 = PopoverAnchor$1;
var Trigger$2 = PopoverTrigger$1;
var Portal$1 = PopoverPortal;
var Content2$1 = PopoverContent$1;
function Popover({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Root2$1, { "data-slot": "popover", ...props2 });
}
function PopoverTrigger({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Trigger$2, { "data-slot": "popover-trigger", ...props2 });
}
function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Portal$1, { container: getPipecatUIContainer(), children: (0, import_jsx_runtime2.jsx)(
    Content2$1,
    {
      "data-slot": "popover-content",
      align,
      sideOffset,
      className: cn(
        "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:w-72 origin-(--radix-popover-content-transform-origin) vkui:rounded-md vkui:border vkui:p-4 vkui:shadow-md vkui:outline-hidden",
        className
      ),
      ...props2
    }
  ) });
}
function PopoverAnchor({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Anchor2, { "data-slot": "popover-anchor", ...props2 });
}
var PanelGroupContext = (0, import_react2.createContext)(null);
PanelGroupContext.displayName = "PanelGroupContext";
var DATA_ATTRIBUTES = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
};
var PRECISION = 10;
var useIsomorphicLayoutEffect = import_react2.useLayoutEffect;
var useId = React["useId".toString()];
var wrappedUseId = typeof useId === "function" ? useId : () => null;
var counter = 0;
function useUniqueId(idFromParams = null) {
  const idFromUseId = wrappedUseId();
  const idRef = (0, import_react2.useRef)(idFromParams || idFromUseId || null);
  if (idRef.current === null) {
    idRef.current = "" + counter++;
  }
  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;
}
function PanelWithForwardedRef({
  children,
  className: classNameFromProps = "",
  collapsedSize,
  collapsible,
  defaultSize,
  forwardedRef,
  id: idFromProps,
  maxSize,
  minSize,
  onCollapse,
  onExpand,
  onResize,
  order,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const context = (0, import_react2.useContext)(PanelGroupContext);
  if (context === null) {
    throw Error(`Panel components must be rendered within a PanelGroup container`);
  }
  const {
    collapsePanel,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    reevaluatePanelConstraints,
    registerPanel,
    resizePanel: resizePanel2,
    unregisterPanel
  } = context;
  const panelId = useUniqueId(idFromProps);
  const panelDataRef = (0, import_react2.useRef)({
    callbacks: {
      onCollapse,
      onExpand,
      onResize
    },
    constraints: {
      collapsedSize,
      collapsible,
      defaultSize,
      maxSize,
      minSize
    },
    id: panelId,
    idIsFromProps: idFromProps !== void 0,
    order
  });
  (0, import_react2.useRef)({
    didLogMissingDefaultSizeWarning: false
  });
  useIsomorphicLayoutEffect(() => {
    const {
      callbacks,
      constraints
    } = panelDataRef.current;
    const prevConstraints = {
      ...constraints
    };
    panelDataRef.current.id = panelId;
    panelDataRef.current.idIsFromProps = idFromProps !== void 0;
    panelDataRef.current.order = order;
    callbacks.onCollapse = onCollapse;
    callbacks.onExpand = onExpand;
    callbacks.onResize = onResize;
    constraints.collapsedSize = collapsedSize;
    constraints.collapsible = collapsible;
    constraints.defaultSize = defaultSize;
    constraints.maxSize = maxSize;
    constraints.minSize = minSize;
    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {
      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);
    }
  });
  useIsomorphicLayoutEffect(() => {
    const panelData = panelDataRef.current;
    registerPanel(panelData);
    return () => {
      unregisterPanel(panelData);
    };
  }, [order, panelId, registerPanel, unregisterPanel]);
  (0, import_react2.useImperativeHandle)(forwardedRef, () => ({
    collapse: () => {
      collapsePanel(panelDataRef.current);
    },
    expand: (minSize2) => {
      expandPanel(panelDataRef.current, minSize2);
    },
    getId() {
      return panelId;
    },
    getSize() {
      return getPanelSize(panelDataRef.current);
    },
    isCollapsed() {
      return isPanelCollapsed(panelDataRef.current);
    },
    isExpanded() {
      return !isPanelCollapsed(panelDataRef.current);
    },
    resize: (size2) => {
      resizePanel2(panelDataRef.current, size2);
    }
  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel2]);
  const style = getPanelStyle(panelDataRef.current, defaultSize);
  return (0, import_react2.createElement)(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: panelId,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    [DATA_ATTRIBUTES.groupId]: groupId,
    [DATA_ATTRIBUTES.panel]: "",
    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || void 0,
    [DATA_ATTRIBUTES.panelId]: panelId,
    [DATA_ATTRIBUTES.panelSize]: parseFloat("" + style.flexGrow).toFixed(1)
  });
}
var Panel = (0, import_react2.forwardRef)((props2, ref) => (0, import_react2.createElement)(PanelWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelWithForwardedRef.displayName = "Panel";
Panel.displayName = "forwardRef(Panel)";
var nonce;
function getNonce() {
  return nonce;
}
function setNonce(value) {
  nonce = value;
}
var currentCursorStyle = null;
var enabled = true;
var prevRuleIndex = -1;
var styleElement = null;
function disableGlobalCursorStyles() {
  enabled = false;
}
function enableGlobalCursorStyles() {
  enabled = true;
}
function getCursorStyle(state, constraintFlags) {
  if (constraintFlags) {
    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;
    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;
    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;
    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
    if (horizontalMin) {
      if (verticalMin) {
        return "se-resize";
      } else if (verticalMax) {
        return "ne-resize";
      } else {
        return "e-resize";
      }
    } else if (horizontalMax) {
      if (verticalMin) {
        return "sw-resize";
      } else if (verticalMax) {
        return "nw-resize";
      } else {
        return "w-resize";
      }
    } else if (verticalMin) {
      return "s-resize";
    } else if (verticalMax) {
      return "n-resize";
    }
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  if (styleElement !== null) {
    document.head.removeChild(styleElement);
    currentCursorStyle = null;
    styleElement = null;
    prevRuleIndex = -1;
  }
}
function setGlobalCursorStyle(state, constraintFlags) {
  var _styleElement$sheet$i, _styleElement$sheet2;
  if (!enabled) {
    return;
  }
  const style = getCursorStyle(state, constraintFlags);
  if (currentCursorStyle === style) {
    return;
  }
  currentCursorStyle = style;
  if (styleElement === null) {
    styleElement = document.createElement("style");
    const nonce2 = getNonce();
    if (nonce2) {
      styleElement.setAttribute("nonce", nonce2);
    }
    document.head.appendChild(styleElement);
  }
  if (prevRuleIndex >= 0) {
    var _styleElement$sheet;
    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);
  }
  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isPointerEvent(event) {
  return event.type.startsWith("pointer");
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function getResizeEventCoordinates(event) {
  if (isPointerEvent(event)) {
    if (event.isPrimary) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
  } else if (isMouseEvent(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return {
    x: Infinity,
    y: Infinity
  };
}
function getInputType() {
  if (typeof matchMedia === "function") {
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
}
function intersects(rectOne, rectTwo, strict) {
  if (strict) {
    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
  } else {
    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;
  }
}
function compare(a2, b2) {
  if (a2 === b2) throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: get_ancestors(a2),
    b: get_ancestors(b2)
  };
  let common_ancestor;
  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {
    a2 = ancestors.a.pop();
    b2 = ancestors.b.pop();
    common_ancestor = a2;
  }
  assert(common_ancestor, "Stacking order can only be calculated for elements with a common ancestor");
  const z_indexes = {
    a: get_z_index(find_stacking_context(ancestors.a)),
    b: get_z_index(find_stacking_context(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes;
    const furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i2 = children.length;
    while (i2--) {
      const child = children[i2];
      if (child === furthest_ancestors.a) return 1;
      if (child === furthest_ancestors.b) return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
var props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function is_flex_item(node) {
  var _get_parent;
  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;
  return display === "flex" || display === "inline-flex";
}
function creates_stacking_context(node) {
  const style = getComputedStyle(node);
  if (style.position === "fixed") return true;
  if (style.zIndex !== "auto" && (style.position !== "static" || is_flex_item(node))) return true;
  if (+style.opacity < 1) return true;
  if ("transform" in style && style.transform !== "none") return true;
  if ("webkitTransform" in style && style.webkitTransform !== "none") return true;
  if ("mixBlendMode" in style && style.mixBlendMode !== "normal") return true;
  if ("filter" in style && style.filter !== "none") return true;
  if ("webkitFilter" in style && style.webkitFilter !== "none") return true;
  if ("isolation" in style && style.isolation === "isolate") return true;
  if (props.test(style.willChange)) return true;
  if (style.webkitOverflowScrolling === "touch") return true;
  return false;
}
function find_stacking_context(nodes) {
  let i2 = nodes.length;
  while (i2--) {
    const node = nodes[i2];
    assert(node, "Missing node");
    if (creates_stacking_context(node)) return node;
  }
  return null;
}
function get_z_index(node) {
  return node && Number(getComputedStyle(node).zIndex) || 0;
}
function get_ancestors(node) {
  const ancestors = [];
  while (node) {
    ancestors.push(node);
    node = get_parent(node);
  }
  return ancestors;
}
function get_parent(node) {
  const {
    parentNode
  } = node;
  if (parentNode && parentNode instanceof ShadowRoot) {
    return parentNode.host;
  }
  return parentNode;
}
var EXCEEDED_HORIZONTAL_MIN = 1;
var EXCEEDED_HORIZONTAL_MAX = 2;
var EXCEEDED_VERTICAL_MIN = 4;
var EXCEEDED_VERTICAL_MAX = 8;
var isCoarsePointer = getInputType() === "coarse";
var intersectingHandles = [];
var isPointerDown = false;
var ownerDocumentCounts = /* @__PURE__ */ new Map();
var panelConstraintFlags = /* @__PURE__ */ new Map();
var registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
  var _ownerDocumentCounts$;
  const {
    ownerDocument
  } = element;
  const data = {
    direction,
    element,
    hitAreaMargins,
    setResizeHandlerState
  };
  const count2 = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;
  ownerDocumentCounts.set(ownerDocument, count2 + 1);
  registeredResizeHandlers.add(data);
  updateListeners();
  return function unregisterResizeHandle() {
    var _ownerDocumentCounts$2;
    panelConstraintFlags.delete(resizeHandleId);
    registeredResizeHandlers.delete(data);
    const count3 = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;
    ownerDocumentCounts.set(ownerDocument, count3 - 1);
    updateListeners();
    if (count3 === 1) {
      ownerDocumentCounts.delete(ownerDocument);
    }
    if (intersectingHandles.includes(data)) {
      const index2 = intersectingHandles.indexOf(data);
      if (index2 >= 0) {
        intersectingHandles.splice(index2, 1);
      }
      updateCursor();
      setResizeHandlerState("up", true, null);
    }
  };
}
function handlePointerDown(event) {
  const {
    target
  } = event;
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  isPointerDown = true;
  recalculateIntersectingHandles({
    target,
    x: x2,
    y: y2
  });
  updateListeners();
  if (intersectingHandles.length > 0) {
    updateResizeHandlerStates("down", event);
    event.preventDefault();
    if (!isWithinResizeHandle(target)) {
      event.stopImmediatePropagation();
    }
  }
}
function handlePointerMove(event) {
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  if (isPointerDown && event.buttons === 0) {
    isPointerDown = false;
    updateResizeHandlerStates("up", event);
  }
  if (!isPointerDown) {
    const {
      target
    } = event;
    recalculateIntersectingHandles({
      target,
      x: x2,
      y: y2
    });
  }
  updateResizeHandlerStates("move", event);
  updateCursor();
  if (intersectingHandles.length > 0) {
    event.preventDefault();
  }
}
function handlePointerUp(event) {
  const {
    target
  } = event;
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear();
  isPointerDown = false;
  if (intersectingHandles.length > 0) {
    event.preventDefault();
    if (!isWithinResizeHandle(target)) {
      event.stopImmediatePropagation();
    }
  }
  updateResizeHandlerStates("up", event);
  recalculateIntersectingHandles({
    target,
    x: x2,
    y: y2
  });
  updateCursor();
  updateListeners();
}
function isWithinResizeHandle(element) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {
      return true;
    }
    currentElement = currentElement.parentElement;
  }
  return false;
}
function recalculateIntersectingHandles({
  target,
  x: x2,
  y: y2
}) {
  intersectingHandles.splice(0);
  let targetElement = null;
  if (target instanceof HTMLElement || target instanceof SVGElement) {
    targetElement = target;
  }
  registeredResizeHandlers.forEach((data) => {
    const {
      element: dragHandleElement,
      hitAreaMargins
    } = data;
    const dragHandleRect = dragHandleElement.getBoundingClientRect();
    const {
      bottom,
      left,
      right,
      top
    } = dragHandleRect;
    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    const eventIntersects = x2 >= left - margin && x2 <= right + margin && y2 >= top - margin && y2 <= bottom + margin;
    if (eventIntersects) {
      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      compare(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement;
        let didIntersect = false;
        while (currentElement) {
          if (currentElement.contains(dragHandleElement)) {
            break;
          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {
            didIntersect = true;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect) {
          return;
        }
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = false;
  let intersectsVertical = false;
  intersectingHandles.forEach((data) => {
    const {
      direction
    } = data;
    if (direction === "horizontal") {
      intersectsHorizontal = true;
    } else {
      intersectsVertical = true;
    }
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  });
  if (intersectsHorizontal && intersectsVertical) {
    setGlobalCursorStyle("intersection", constraintFlags);
  } else if (intersectsHorizontal) {
    setGlobalCursorStyle("horizontal", constraintFlags);
  } else if (intersectsVertical) {
    setGlobalCursorStyle("vertical", constraintFlags);
  } else {
    resetGlobalCursorStyle();
  }
}
var listenersAbortController;
function updateListeners() {
  var _listenersAbortContro;
  (_listenersAbortContro = listenersAbortController) === null || _listenersAbortContro === void 0 ? void 0 : _listenersAbortContro.abort();
  listenersAbortController = new AbortController();
  const options = {
    capture: true,
    signal: listenersAbortController.signal
  };
  if (!registeredResizeHandlers.size) {
    return;
  }
  if (isPointerDown) {
    if (intersectingHandles.length > 0) {
      ownerDocumentCounts.forEach((count2, ownerDocument) => {
        const {
          body
        } = ownerDocument;
        if (count2 > 0) {
          body.addEventListener("contextmenu", handlePointerUp, options);
          body.addEventListener("pointerleave", handlePointerMove, options);
          body.addEventListener("pointermove", handlePointerMove, options);
        }
      });
    }
    ownerDocumentCounts.forEach((_2, ownerDocument) => {
      const {
        body
      } = ownerDocument;
      body.addEventListener("pointerup", handlePointerUp, options);
      body.addEventListener("pointercancel", handlePointerUp, options);
    });
  } else {
    ownerDocumentCounts.forEach((count2, ownerDocument) => {
      const {
        body
      } = ownerDocument;
      if (count2 > 0) {
        body.addEventListener("pointerdown", handlePointerDown, options);
        body.addEventListener("pointermove", handlePointerMove, options);
      }
    });
  }
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const {
      setResizeHandlerState
    } = data;
    const isActive = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive, event);
  });
}
function useForceUpdate() {
  const [_2, setCount] = (0, import_react2.useState)(0);
  return (0, import_react2.useCallback)(() => setCount((prevCount) => prevCount + 1), []);
}
function assert(expectedCondition, message) {
  if (!expectedCondition) {
    console.error(message);
    throw Error(message);
  }
}
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {
    return 0;
  } else {
    return actual > expected ? 1 : -1;
  }
}
function fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyLayoutsEqual(actual, expected, fractionDigits) {
  if (actual.length !== expected.length) {
    return false;
  }
  for (let index2 = 0; index2 < actual.length; index2++) {
    const actualSize = actual[index2];
    const expectedSize = expected[index2];
    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {
      return false;
    }
  }
  return true;
}
function resizePanel({
  panelConstraints: panelConstraintsArray,
  panelIndex,
  size: size2
}) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);
  let {
    collapsedSize = 0,
    collapsible,
    maxSize = 100,
    minSize = 0
  } = panelConstraints;
  if (fuzzyCompareNumbers(size2, minSize) < 0) {
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      if (fuzzyCompareNumbers(size2, halfwayPoint) < 0) {
        size2 = collapsedSize;
      } else {
        size2 = minSize;
      }
    } else {
      size2 = minSize;
    }
  }
  size2 = Math.min(maxSize, size2);
  size2 = parseFloat(size2.toFixed(PRECISION));
  return size2;
}
function adjustLayoutByDelta({
  delta,
  initialLayout,
  panelConstraints: panelConstraintsArray,
  pivotIndices,
  prevLayout,
  trigger
}) {
  if (fuzzyNumbersEqual(delta, 0)) {
    return initialLayout;
  }
  const nextLayout = [...initialLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null, "Invalid first pivot index");
  assert(secondPivotIndex != null, "Invalid second pivot index");
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const panelConstraints = panelConstraintsArray[index2];
        assert(panelConstraints, `Panel constraints not found for index ${index2}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index2];
          assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index2 = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const panelConstraints = panelConstraintsArray[index2];
        assert(panelConstraints, `No panel constraints found for index ${index2}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index2];
          assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
          if (fuzzyNumbersEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = initialLayout[index2];
      assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
      const maxSafeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index2,
        size: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index2 += increment;
      if (index2 < 0 || index2 >= panelConstraintsArray.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index2 = pivotIndex;
    while (index2 >= 0 && index2 < panelConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = initialLayout[index2];
      assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index2,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index2] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index2--;
      } else {
        index2++;
      }
    }
  }
  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = initialLayout[pivotIndex];
    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index2 = pivotIndex2;
      while (index2 >= 0 && index2 < panelConstraintsArray.length) {
        const prevSize2 = nextLayout[index2];
        assert(prevSize2 != null, `Previous layout not found for panel index ${index2}`);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index2,
          size: unsafeSize2
        });
        if (!fuzzyNumbersEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index2] = safeSize2;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0)) {
          break;
        }
        if (delta > 0) {
          index2--;
        } else {
          index2++;
        }
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size2) => size2 + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100)) {
    return prevLayout;
  }
  return nextLayout;
}
function calculateAriaValues({
  layout,
  panelsArray,
  pivotIndices
}) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  assert(firstIndex != null, "No pivot index found");
  panelsArray.forEach((panelData, index2) => {
    const {
      constraints
    } = panelData;
    const {
      maxSize = 100,
      minSize = 0
    } = constraints;
    if (index2 === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id="${groupId}"]`));
}
function getResizeHandleElementIndex(groupId, id, scope = document) {
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index2 = handles.findIndex((handle) => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);
  return index2 !== null && index2 !== void 0 ? index2 : null;
}
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index2 = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
  return index2 != null ? [index2, index2 + 1] : [-1, -1];
}
function isHTMLElement(target) {
  if (target instanceof HTMLElement) {
    return true;
  }
  return typeof target === "object" && target !== null && "tagName" in target && "getAttribute" in target;
}
function getPanelGroupElement(id, rootElement = document) {
  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {
    return rootElement;
  }
  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandleElement(id, scope = document) {
  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;
  const handle = getResizeHandleElement(handleId, scope);
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index2 = handle ? handles.indexOf(handle) : -1;
  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index2]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;
  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index2 + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;
  return [idBefore, idAfter];
}
function useWindowSplitterPanelGroupBehavior({
  committedValuesRef,
  eagerValuesRef,
  groupId,
  layout,
  panelDataArray,
  panelGroupElement,
  setLayout
}) {
  (0, import_react2.useRef)({
    didWarnAboutMissingResizeHandle: false
  });
  useIsomorphicLayoutEffect(() => {
    if (!panelGroupElement) {
      return;
    }
    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    for (let index2 = 0; index2 < panelDataArray.length - 1; index2++) {
      const {
        valueMax,
        valueMin,
        valueNow
      } = calculateAriaValues({
        layout,
        panelsArray: panelDataArray,
        pivotIndices: [index2, index2 + 1]
      });
      const resizeHandleElement = resizeHandleElements[index2];
      if (resizeHandleElement == null) ;
      else {
        const panelData = panelDataArray[index2];
        assert(panelData, `No panel data found for index "${index2}"`);
        resizeHandleElement.setAttribute("aria-controls", panelData.id);
        resizeHandleElement.setAttribute("aria-valuemax", "" + Math.round(valueMax));
        resizeHandleElement.setAttribute("aria-valuemin", "" + Math.round(valueMin));
        resizeHandleElement.setAttribute("aria-valuenow", valueNow != null ? "" + Math.round(valueNow) : "");
      }
    }
    return () => {
      resizeHandleElements.forEach((resizeHandleElement, index2) => {
        resizeHandleElement.removeAttribute("aria-controls");
        resizeHandleElement.removeAttribute("aria-valuemax");
        resizeHandleElement.removeAttribute("aria-valuemin");
        resizeHandleElement.removeAttribute("aria-valuenow");
      });
    };
  }, [groupId, layout, panelDataArray, panelGroupElement]);
  (0, import_react2.useEffect)(() => {
    if (!panelGroupElement) {
      return;
    }
    const eagerValues = eagerValuesRef.current;
    assert(eagerValues, `Eager values not found`);
    const {
      panelDataArray: panelDataArray2
    } = eagerValues;
    const groupElement = getPanelGroupElement(groupId, panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    assert(handles, `No resize handles found for group id "${groupId}"`);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);
      assert(handleId, `Resize handle element has no handle id attribute`);
      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray2, panelGroupElement);
      if (idBefore == null || idAfter == null) {
        return () => {
        };
      }
      const onKeyDown = (event) => {
        if (event.defaultPrevented) {
          return;
        }
        switch (event.key) {
          case "Enter": {
            event.preventDefault();
            const index2 = panelDataArray2.findIndex((panelData) => panelData.id === idBefore);
            if (index2 >= 0) {
              const panelData = panelDataArray2[index2];
              assert(panelData, `No panel data found for index ${index2}`);
              const size2 = layout[index2];
              const {
                collapsedSize = 0,
                collapsible,
                minSize = 0
              } = panelData.constraints;
              if (size2 != null && collapsible) {
                const nextLayout = adjustLayoutByDelta({
                  delta: fuzzyNumbersEqual(size2, collapsedSize) ? minSize - collapsedSize : collapsedSize - size2,
                  initialLayout: layout,
                  panelConstraints: panelDataArray2.map((panelData2) => panelData2.constraints),
                  pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),
                  prevLayout: layout,
                  trigger: "keyboard"
                });
                if (layout !== nextLayout) {
                  setLayout(nextLayout);
                }
              }
            }
            break;
          }
        }
      };
      handle.addEventListener("keydown", onKeyDown);
      return () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    return () => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    };
  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);
}
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) {
    return false;
  }
  for (let index2 = 0; index2 < arrayA.length; index2++) {
    if (arrayA[index2] !== arrayB[index2]) {
      return false;
    }
  }
  return true;
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal";
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  return isHorizontal ? x2 : y2;
}
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement, `No resize handle element found for id "${dragHandleId}"`);
  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);
  assert(groupId, `Resize handle element has no group id attribute`);
  let {
    initialCursorPosition
  } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event);
  const groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement, `No group element found for id "${groupId}"`);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    if (event.shiftKey) {
      delta = 100;
    } else if (keyboardResizeBy != null) {
      delta = keyboardResizeBy;
    } else {
      delta = 10;
    }
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null) {
      return 0;
    }
    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
  }
}
function calculateUnsafeDefaultLayout({
  panelDataArray
}) {
  const layout = Array(panelDataArray.length);
  const panelConstraintsArray = panelDataArray.map((panelData) => panelData.constraints);
  let numPanelsWithSizes = 0;
  let remainingSize = 100;
  for (let index2 = 0; index2 < panelDataArray.length; index2++) {
    const panelConstraints = panelConstraintsArray[index2];
    assert(panelConstraints, `Panel constraints not found for index ${index2}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      numPanelsWithSizes++;
      layout[index2] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index2 = 0; index2 < panelDataArray.length; index2++) {
    const panelConstraints = panelConstraintsArray[index2];
    assert(panelConstraints, `Panel constraints not found for index ${index2}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      continue;
    }
    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;
    const size2 = remainingSize / numRemainingPanels;
    numPanelsWithSizes++;
    layout[index2] = size2;
    remainingSize -= size2;
  }
  return layout;
}
function callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {
  layout.forEach((size2, index2) => {
    const panelData = panelsArray[index2];
    assert(panelData, `Panel data not found for index ${index2}`);
    const {
      callbacks,
      constraints,
      id: panelId
    } = panelData;
    const {
      collapsedSize = 0,
      collapsible
    } = constraints;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size2 !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size2;
      const {
        onCollapse,
        onExpand,
        onResize
      } = callbacks;
      if (onResize) {
        onResize(size2, lastNotifiedSize);
      }
      if (collapsible && (onCollapse || onExpand)) {
        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size2, collapsedSize)) {
          onExpand();
        }
        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size2, collapsedSize)) {
          onCollapse();
        }
      }
    }
  });
}
function compareLayouts(a2, b2) {
  if (a2.length !== b2.length) {
    return false;
  } else {
    for (let index2 = 0; index2 < a2.length; index2++) {
      if (a2[index2] != b2[index2]) {
        return false;
      }
    }
  }
  return true;
}
function computePanelFlexBoxStyle({
  defaultSize,
  dragState,
  layout,
  panelData,
  panelIndex,
  precision = 3
}) {
  const size2 = layout[panelIndex];
  let flexGrow;
  if (size2 == null) {
    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : "1";
  } else if (panelData.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size2.toPrecision(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}
function debounce2(callback2, durationMs = 10) {
  let timeoutId = null;
  let callable = (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      callback2(...args);
    }, durationMs);
  };
  return callable;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name) => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error) {
    console.error(error);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `react-resizable-panels:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel) => {
    const {
      constraints,
      id,
      idIsFromProps,
      order
    } = panel;
    if (idIsFromProps) {
      return id;
    } else {
      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
    }
  }).sort((a2, b2) => a2.localeCompare(b2)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId);
    const serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed === "object" && parsed != null) {
        return parsed;
      }
    }
  } catch (error) {
  }
  return null;
}
function loadPanelGroupState(autoSaveId, panels, storage) {
  var _loadSerializedPanelG, _state$panelKey;
  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};
  const panelKey = getPanelKey(panels);
  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {
  var _loadSerializedPanelG2;
  const panelGroupKey = getPanelGroupKey(autoSaveId);
  const panelKey = getPanelKey(panels);
  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}
function validatePanelGroupLayout({
  layout: prevLayout,
  panelConstraints
}) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== panelConstraints.length) {
    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size2) => `${size2}%`).join(", ")}`);
  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {
    for (let index2 = 0; index2 < panelConstraints.length; index2++) {
      const unsafeSize = nextLayout[index2];
      assert(unsafeSize != null, `No layout data found for index ${index2}`);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index2] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index2 = 0; index2 < panelConstraints.length; index2++) {
    const unsafeSize = nextLayout[index2];
    assert(unsafeSize != null, `No layout data found for index ${index2}`);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index2,
      size: unsafeSize
    });
    if (unsafeSize != safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index2] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) {
    for (let index2 = 0; index2 < panelConstraints.length; index2++) {
      const prevSize = nextLayout[index2];
      assert(prevSize != null, `No layout data found for index ${index2}`);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePanel({
        panelConstraints,
        panelIndex: index2,
        size: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index2] = safeSize;
        if (fuzzyNumbersEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextLayout;
}
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var defaultStorage = {
  getItem: (name) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var debounceMap = {};
function PanelGroupWithForwardedRef({
  autoSaveId = null,
  children,
  className: classNameFromProps = "",
  direction,
  forwardedRef,
  id: idFromProps = null,
  onLayout = null,
  keyboardResizeBy = null,
  storage = defaultStorage,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const groupId = useUniqueId(idFromProps);
  const panelGroupElementRef = (0, import_react2.useRef)(null);
  const [dragState, setDragState] = (0, import_react2.useState)(null);
  const [layout, setLayout] = (0, import_react2.useState)([]);
  const forceUpdate = useForceUpdate();
  const panelIdToLastNotifiedSizeMapRef = (0, import_react2.useRef)({});
  const panelSizeBeforeCollapseRef = (0, import_react2.useRef)(/* @__PURE__ */ new Map());
  const prevDeltaRef = (0, import_react2.useRef)(0);
  const committedValuesRef = (0, import_react2.useRef)({
    autoSaveId,
    direction,
    dragState,
    id: groupId,
    keyboardResizeBy,
    onLayout,
    storage
  });
  const eagerValuesRef = (0, import_react2.useRef)({
    layout,
    panelDataArray: [],
    panelDataArrayChanged: false
  });
  (0, import_react2.useRef)({
    didLogIdAndOrderWarning: false,
    didLogPanelConstraintsWarning: false,
    prevPanelIds: []
  });
  (0, import_react2.useImperativeHandle)(forwardedRef, () => ({
    getId: () => committedValuesRef.current.id,
    getLayout: () => {
      const {
        layout: layout2
      } = eagerValuesRef.current;
      return layout2;
    },
    setLayout: (unsafeLayout) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const safeLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, safeLayout)) {
        setLayout(safeLayout);
        eagerValuesRef.current.layout = safeLayout;
        if (onLayout2) {
          onLayout2(safeLayout);
        }
        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  }), []);
  useIsomorphicLayoutEffect(() => {
    committedValuesRef.current.autoSaveId = autoSaveId;
    committedValuesRef.current.direction = direction;
    committedValuesRef.current.dragState = dragState;
    committedValuesRef.current.id = groupId;
    committedValuesRef.current.onLayout = onLayout;
    committedValuesRef.current.storage = storage;
  });
  useWindowSplitterPanelGroupBehavior({
    committedValuesRef,
    eagerValuesRef,
    groupId,
    layout,
    panelDataArray: eagerValuesRef.current.panelDataArray,
    setLayout,
    panelGroupElement: panelGroupElementRef.current
  });
  (0, import_react2.useEffect)(() => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    if (autoSaveId) {
      if (layout.length === 0 || layout.length !== panelDataArray.length) {
        return;
      }
      let debouncedSave = debounceMap[autoSaveId];
      if (debouncedSave == null) {
        debouncedSave = debounce2(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
        debounceMap[autoSaveId] = debouncedSave;
      }
      const clonedPanelDataArray = [...panelDataArray];
      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);
      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);
    }
  }, [autoSaveId, layout, storage]);
  (0, import_react2.useEffect)(() => {
  });
  const collapsePanel = (0, import_react2.useCallback)((panelData) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const expandPanel = (0, import_react2.useCallback)((panelData, minSizeOverride) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize = 0,
        minSize: minSizeFromProps = 0,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;
      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);
        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const getPanelSize = (0, import_react2.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return panelSize;
  }, []);
  const getPanelStyle = (0, import_react2.useCallback)((panelData, defaultSize) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const panelIndex = findPanelDataIndex(panelDataArray, panelData);
    return computePanelFlexBoxStyle({
      defaultSize,
      dragState,
      layout,
      panelData: panelDataArray,
      panelIndex
    });
  }, [dragState, layout]);
  const isPanelCollapsed = (0, import_react2.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);
  }, []);
  const isPanelExpanded = (0, import_react2.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
  }, []);
  const registerPanel = (0, import_react2.useCallback)((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    panelDataArray.push(panelData);
    panelDataArray.sort((panelA, panelB) => {
      const orderA = panelA.order;
      const orderB = panelB.order;
      if (orderA == null && orderB == null) {
        return 0;
      } else if (orderA == null) {
        return -1;
      } else if (orderB == null) {
        return 1;
      } else {
        return orderA - orderB;
      }
    });
    eagerValuesRef.current.panelDataArrayChanged = true;
    forceUpdate();
  }, [forceUpdate]);
  useIsomorphicLayoutEffect(() => {
    if (eagerValuesRef.current.panelDataArrayChanged) {
      eagerValuesRef.current.panelDataArrayChanged = false;
      const {
        autoSaveId: autoSaveId2,
        onLayout: onLayout2,
        storage: storage2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      let unsafeLayout = null;
      if (autoSaveId2) {
        const state = loadPanelGroupState(autoSaveId2, panelDataArray, storage2);
        if (state) {
          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));
          unsafeLayout = state.layout;
        }
      }
      if (unsafeLayout == null) {
        unsafeLayout = calculateUnsafeDefaultLayout({
          panelDataArray
        });
      }
      const nextLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, nextLayout)) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  });
  useIsomorphicLayoutEffect(() => {
    const eagerValues = eagerValuesRef.current;
    return () => {
      eagerValues.layout = [];
    };
  }, []);
  const registerResizeHandle2 = (0, import_react2.useCallback)((dragHandleId) => {
    let isRTL2 = false;
    const panelGroupElement = panelGroupElementRef.current;
    if (panelGroupElement) {
      const style2 = window.getComputedStyle(panelGroupElement, null);
      if (style2.getPropertyValue("direction") === "rtl") {
        isRTL2 = true;
      }
    }
    return function resizeHandler(event) {
      event.preventDefault();
      const panelGroupElement2 = panelGroupElementRef.current;
      if (!panelGroupElement2) {
        return () => null;
      }
      const {
        direction: direction2,
        dragState: dragState2,
        id: groupId2,
        keyboardResizeBy: keyboardResizeBy2,
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const {
        initialLayout
      } = dragState2 !== null && dragState2 !== void 0 ? dragState2 : {};
      const pivotIndices = determinePivotIndices(groupId2, dragHandleId, panelGroupElement2);
      let delta = calculateDeltaPercentage(event, dragHandleId, direction2, dragState2, keyboardResizeBy2, panelGroupElement2);
      const isHorizontal = direction2 === "horizontal";
      if (isHorizontal && isRTL2) {
        delta = -delta;
      }
      const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
      const nextLayout = adjustLayoutByDelta({
        delta,
        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,
        panelConstraints,
        pivotIndices,
        prevLayout,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      });
      const layoutChanged = !compareLayouts(prevLayout, nextLayout);
      if (isPointerEvent(event) || isMouseEvent(event)) {
        if (prevDeltaRef.current != delta) {
          prevDeltaRef.current = delta;
          if (!layoutChanged && delta !== 0) {
            if (isHorizontal) {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);
            } else {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);
            }
          } else {
            reportConstraintsViolation(dragHandleId, 0);
          }
        }
      }
      if (layoutChanged) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    };
  }, []);
  const resizePanel2 = (0, import_react2.useCallback)((panelData, unsafePanelSize) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
    const {
      panelSize,
      pivotIndices
    } = panelDataHelper(panelDataArray, panelData, prevLayout);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      initialLayout: prevLayout,
      panelConstraints: panelConstraintsArray,
      pivotIndices,
      prevLayout,
      trigger: "imperative-api"
    });
    if (!compareLayouts(prevLayout, nextLayout)) {
      setLayout(nextLayout);
      eagerValuesRef.current.layout = nextLayout;
      if (onLayout2) {
        onLayout2(nextLayout);
      }
      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
    }
  }, []);
  const reevaluatePanelConstraints = (0, import_react2.useCallback)((panelData, prevConstraints) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize: prevCollapsedSize = 0,
      collapsible: prevCollapsible
    } = prevConstraints;
    const {
      collapsedSize: nextCollapsedSize = 0,
      collapsible: nextCollapsible,
      maxSize: nextMaxSize = 100,
      minSize: nextMinSize = 0
    } = panelData.constraints;
    const {
      panelSize: prevPanelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    if (prevPanelSize == null) {
      return;
    }
    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {
      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {
        resizePanel2(panelData, nextCollapsedSize);
      }
    } else if (prevPanelSize < nextMinSize) {
      resizePanel2(panelData, nextMinSize);
    } else if (prevPanelSize > nextMaxSize) {
      resizePanel2(panelData, nextMaxSize);
    }
  }, [resizePanel2]);
  const startDragging = (0, import_react2.useCallback)((dragHandleId, event) => {
    const {
      direction: direction2
    } = committedValuesRef.current;
    const {
      layout: layout2
    } = eagerValuesRef.current;
    if (!panelGroupElementRef.current) {
      return;
    }
    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);
    assert(handleElement, `Drag handle element not found for id "${dragHandleId}"`);
    const initialCursorPosition = getResizeEventCursorPosition(direction2, event);
    setDragState({
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: layout2
    });
  }, []);
  const stopDragging = (0, import_react2.useCallback)(() => {
    setDragState(null);
  }, []);
  const unregisterPanel = (0, import_react2.useCallback)((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const index2 = findPanelDataIndex(panelDataArray, panelData);
    if (index2 >= 0) {
      panelDataArray.splice(index2, 1);
      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];
      eagerValuesRef.current.panelDataArrayChanged = true;
      forceUpdate();
    }
  }, [forceUpdate]);
  const context = (0, import_react2.useMemo)(() => ({
    collapsePanel,
    direction,
    dragState,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    isPanelExpanded,
    reevaluatePanelConstraints,
    registerPanel,
    registerResizeHandle: registerResizeHandle2,
    resizePanel: resizePanel2,
    startDragging,
    stopDragging,
    unregisterPanel,
    panelGroupElement: panelGroupElementRef.current
  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle2, resizePanel2, startDragging, stopDragging, unregisterPanel]);
  const style = {
    display: "flex",
    flexDirection: direction === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return (0, import_react2.createElement)(PanelGroupContext.Provider, {
    value: context
  }, (0, import_react2.createElement)(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    ref: panelGroupElementRef,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    [DATA_ATTRIBUTES.group]: "",
    [DATA_ATTRIBUTES.groupDirection]: direction,
    [DATA_ATTRIBUTES.groupId]: groupId
  }));
}
var PanelGroup = (0, import_react2.forwardRef)((props2, ref) => (0, import_react2.createElement)(PanelGroupWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelGroupWithForwardedRef.displayName = "PanelGroup";
PanelGroup.displayName = "forwardRef(PanelGroup)";
function findPanelDataIndex(panelDataArray, panelData) {
  return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
}
function panelDataHelper(panelDataArray, panelData, layout) {
  const panelIndex = findPanelDataIndex(panelDataArray, panelData);
  const isLastPanel = panelIndex === panelDataArray.length - 1;
  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];
  const panelSize = layout[panelIndex];
  return {
    ...panelData.constraints,
    panelSize,
    pivotIndices
  };
}
function useWindowSplitterResizeHandlerBehavior({
  disabled,
  handleId,
  resizeHandler,
  panelGroupElement
}) {
  (0, import_react2.useEffect)(() => {
    if (disabled || resizeHandler == null || panelGroupElement == null) {
      return;
    }
    const handleElement = getResizeHandleElement(handleId, panelGroupElement);
    if (handleElement == null) {
      return;
    }
    const onKeyDown = (event) => {
      if (event.defaultPrevented) {
        return;
      }
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home": {
          event.preventDefault();
          resizeHandler(event);
          break;
        }
        case "F6": {
          event.preventDefault();
          const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);
          assert(groupId, `No group element found for id "${groupId}"`);
          const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
          const index2 = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);
          assert(index2 !== null, `No resize element found for id "${handleId}"`);
          const nextIndex = event.shiftKey ? index2 > 0 ? index2 - 1 : handles.length - 1 : index2 + 1 < handles.length ? index2 + 1 : 0;
          const nextHandle = handles[nextIndex];
          nextHandle.focus();
          break;
        }
      }
    };
    handleElement.addEventListener("keydown", onKeyDown);
    return () => {
      handleElement.removeEventListener("keydown", onKeyDown);
    };
  }, [panelGroupElement, disabled, handleId, resizeHandler]);
}
function PanelResizeHandle({
  children = null,
  className: classNameFromProps = "",
  disabled = false,
  hitAreaMargins,
  id: idFromProps,
  onBlur,
  onClick,
  onDragging,
  onFocus,
  onPointerDown,
  onPointerUp,
  style: styleFromProps = {},
  tabIndex = 0,
  tagName: Type = "div",
  ...rest
}) {
  var _hitAreaMargins$coars, _hitAreaMargins$fine;
  const elementRef = (0, import_react2.useRef)(null);
  const callbacksRef = (0, import_react2.useRef)({
    onClick,
    onDragging,
    onPointerDown,
    onPointerUp
  });
  (0, import_react2.useEffect)(() => {
    callbacksRef.current.onClick = onClick;
    callbacksRef.current.onDragging = onDragging;
    callbacksRef.current.onPointerDown = onPointerDown;
    callbacksRef.current.onPointerUp = onPointerUp;
  });
  const panelGroupContext = (0, import_react2.useContext)(PanelGroupContext);
  if (panelGroupContext === null) {
    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);
  }
  const {
    direction,
    groupId,
    registerResizeHandle: registerResizeHandleWithParentGroup,
    startDragging,
    stopDragging,
    panelGroupElement
  } = panelGroupContext;
  const resizeHandleId = useUniqueId(idFromProps);
  const [state, setState] = (0, import_react2.useState)("inactive");
  const [isFocused, setIsFocused] = (0, import_react2.useState)(false);
  const [resizeHandler, setResizeHandler] = (0, import_react2.useState)(null);
  const committedValuesRef = (0, import_react2.useRef)({
    state
  });
  useIsomorphicLayoutEffect(() => {
    committedValuesRef.current.state = state;
  });
  (0, import_react2.useEffect)(() => {
    if (disabled) {
      setResizeHandler(null);
    } else {
      const resizeHandler2 = registerResizeHandleWithParentGroup(resizeHandleId);
      setResizeHandler(() => resizeHandler2);
    }
  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);
  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;
  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;
  (0, import_react2.useEffect)(() => {
    if (disabled || resizeHandler == null) {
      return;
    }
    const element = elementRef.current;
    assert(element, "Element ref not attached");
    let didMove = false;
    const setResizeHandlerState = (action, isActive, event) => {
      if (!isActive) {
        setState("inactive");
        return;
      }
      switch (action) {
        case "down": {
          setState("drag");
          didMove = false;
          assert(event, 'Expected event to be defined for "down" action');
          startDragging(resizeHandleId, event);
          const {
            onDragging: onDragging2,
            onPointerDown: onPointerDown2
          } = callbacksRef.current;
          onDragging2 === null || onDragging2 === void 0 ? void 0 : onDragging2(true);
          onPointerDown2 === null || onPointerDown2 === void 0 ? void 0 : onPointerDown2();
          break;
        }
        case "move": {
          const {
            state: state2
          } = committedValuesRef.current;
          didMove = true;
          if (state2 !== "drag") {
            setState("hover");
          }
          assert(event, 'Expected event to be defined for "move" action');
          resizeHandler(event);
          break;
        }
        case "up": {
          setState("hover");
          stopDragging();
          const {
            onClick: onClick2,
            onDragging: onDragging2,
            onPointerUp: onPointerUp2
          } = callbacksRef.current;
          onDragging2 === null || onDragging2 === void 0 ? void 0 : onDragging2(false);
          onPointerUp2 === null || onPointerUp2 === void 0 ? void 0 : onPointerUp2();
          if (!didMove) {
            onClick2 === null || onClick2 === void 0 ? void 0 : onClick2();
          }
          break;
        }
      }
    };
    return registerResizeHandle(resizeHandleId, element, direction, {
      coarse: coarseHitAreaMargins,
      fine: fineHitAreaMargins
    }, setResizeHandlerState);
  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);
  useWindowSplitterResizeHandlerBehavior({
    disabled,
    handleId: resizeHandleId,
    resizeHandler,
    panelGroupElement
  });
  const style = {
    touchAction: "none",
    userSelect: "none"
  };
  return (0, import_react2.createElement)(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    onBlur: () => {
      setIsFocused(false);
      onBlur === null || onBlur === void 0 ? void 0 : onBlur();
    },
    onFocus: () => {
      setIsFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus();
    },
    ref: elementRef,
    role: "separator",
    style: {
      ...style,
      ...styleFromProps
    },
    tabIndex,
    // CSS selectors
    [DATA_ATTRIBUTES.groupDirection]: direction,
    [DATA_ATTRIBUTES.groupId]: groupId,
    [DATA_ATTRIBUTES.resizeHandle]: "",
    [DATA_ATTRIBUTES.resizeHandleActive]: state === "drag" ? "pointer" : isFocused ? "keyboard" : void 0,
    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,
    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,
    [DATA_ATTRIBUTES.resizeHandleState]: state
  });
}
PanelResizeHandle.displayName = "PanelResizeHandle";
function usePanelGroupContext() {
  const context = (0, import_react2.useContext)(PanelGroupContext);
  return {
    direction: context === null || context === void 0 ? void 0 : context.direction,
    groupId: context === null || context === void 0 ? void 0 : context.groupId
  };
}
function getPanelElement(id, scope = document) {
  const element = scope.querySelector(`[data-panel-id="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getPanelElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id="${groupId}"]`));
}
function getIntersectingRectangle(rectOne, rectTwo, strict) {
  if (!intersects(rectOne, rectTwo, strict)) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  return {
    x: Math.max(rectOne.x, rectTwo.x),
    y: Math.max(rectOne.y, rectTwo.y),
    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),
    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)
  };
}
var reactResizablePanels_browser = Object.freeze(Object.defineProperty({
  __proto__: null,
  DATA_ATTRIBUTES,
  Panel,
  PanelGroup,
  PanelResizeHandle,
  assert,
  disableGlobalCursorStyles,
  enableGlobalCursorStyles,
  getIntersectingRectangle,
  getPanelElement,
  getPanelElementsForGroup,
  getPanelGroupElement,
  getResizeHandleElement,
  getResizeHandleElementIndex,
  getResizeHandleElementsForGroup,
  getResizeHandlePanelIds,
  intersects,
  setNonce,
  usePanelGroupContext
}, Symbol.toStringTag, { value: "Module" }));
function ResizablePanelGroup({
  className,
  ...props2
}) {
  disableGlobalCursorStyles();
  return (0, import_jsx_runtime2.jsx)(
    PanelGroup,
    {
      "data-slot": "resizable-panel-group",
      className: cn(
        "vkui:flex vkui:h-full vkui:w-full vkui:data-[panel-group-direction=vertical]:flex-col",
        className
      ),
      ...props2
    }
  );
}
function ResizablePanel({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Panel, { "data-slot": "resizable-panel", ...props2 });
}
function ResizableHandle({
  withHandle,
  className,
  ...props2
}) {
  const { direction } = usePanelGroupContext();
  return (0, import_jsx_runtime2.jsx)(
    PanelResizeHandle,
    {
      "data-slot": "resizable-handle",
      className: cn(
        "vkui:focus-visible:ring-ring vkui:relative vkui:flex vkui:w-px vkui:items-center vkui:justify-center vkui:after:absolute vkui:after:inset-y-0 vkui:after:left-1/2 vkui:after:w-1 vkui:after:-translate-x-1/2 vkui:focus-visible:ring-1 vkui:focus-visible:ring-offset-1 focus-visible:outline-hidden vkui:data-[panel-group-direction=vertical]:h-px vkui:data-[panel-group-direction=vertical]:w-full vkui:data-[panel-group-direction=vertical]:after:left-0 vkui:data-[panel-group-direction=vertical]:after:h-1 vkui:data-[panel-group-direction=vertical]:after:w-full vkui:data-[panel-group-direction=vertical]:after:-translate-y-1/2 vkui:data-[panel-group-direction=vertical]:after:translate-x-0 vkui:[&[data-panel-group-direction=vertical]>div]:rotate-90",
        direction === "vertical" ? "vkui:cursor-row-resize" : "vkui:cursor-col-resize",
        className
      ),
      ...props2,
      children: withHandle && (0, import_jsx_runtime2.jsx)("div", { className: "vkui:border-transparent vkui:z-10 vkui:flex vkui:h-8 vkui:w-4 vkui:items-center vkui:justify-center vkui:rounded-xs vkui:border vkui:text-subtle vkui:hover:text-foreground vkui:focus:text-foreground", children: (0, import_jsx_runtime2.jsx)(EllipsisVerticalIcon, { size: 16 }) })
    }
  );
}
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props2;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: TABS_NAME
    });
    return (0, import_jsx_runtime2.jsx)(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId$1(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: (0, import_jsx_runtime2.jsx)(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props2;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return (0, import_jsx_runtime2.jsx)(
      Root,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: (0, import_jsx_runtime2.jsx)(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$1 = "TabsTrigger";
var TabsTrigger$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props2;
    const context = useTabsContext(TRIGGER_NAME$1, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return (0, import_jsx_runtime2.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: (0, import_jsx_runtime2.jsx)(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props2.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props2.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$1;
var CONTENT_NAME$1 = "TabsContent";
var TabsContent$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props2;
    const context = useTabsContext(CONTENT_NAME$1, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React.useRef(isSelected);
    React.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || isSelected, children: ({ present }) => (0, import_jsx_runtime2.jsx)(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props2.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$1;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2 = Tabs$1;
var List = TabsList$1;
var Trigger$1 = TabsTrigger$1;
var Content = TabsContent$1;
function Tabs({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Root2,
    {
      "data-slot": "tabs",
      className: cn("vkui:flex vkui:flex-col vkui:gap-2", className),
      ...props2
    }
  );
}
function TabsList({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    List,
    {
      "data-slot": "tabs-list",
      className: cn(
        "vkui:bg-muted vkui:text-muted-foreground vkui:inline-flex vkui:h-10 vkui:p-1 vkui:w-fit vkui:items-center vkui:justify-center vkui:rounded-md p-[3px] vkui:gap-1",
        className
      ),
      ...props2
    }
  );
}
function TabsTrigger({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Trigger$1,
    {
      "data-slot": "tabs-trigger",
      className: cn(
        "vkui:data-[state=active]:bg-background vkui:data-[state=active]:text-foreground vkui:focus-visible:border-ring vkui:focus-visible:ring-ring/50 vkui:focus-visible:outline-ring vkui:hover:bg-muted-foreground/10 vkui:text-foreground vkui:inline-flex vkui:h-[calc(100%-1px)] vkui:flex-1 vkui:items-center vkui:justify-center vkui:gap-1.5 vkui:rounded-sm vkui:border vkui:border-transparent vkui:px-2 vkui:py-1 vkui:text-xs vkui:font-bold vkui:whitespace-nowrap vkui:transition-[color,box-shadow] vkui:focus-visible:ring-[3px] vkui:focus-visible:outline-1 vkui:disabled:pointer-events-none vkui:disabled:opacity-50 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 vkui:mono-upper",
        className
      ),
      ...props2
    }
  );
}
function TabsContent({
  className,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Content,
    {
      "data-slot": "tabs-content",
      forceMount: true,
      className: cn(
        "vkui:flex-1 vkui:outline-none vkui:data-[state=inactive]:hidden",
        className
      ),
      ...props2
    }
  );
}
var [createTooltipContext2, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext2(PROVIDER_NAME);
var TooltipProvider$1 = (props2) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props2;
  const isOpenDelayedRef = React.useRef(true);
  const isPointerInTransitRef = React.useRef(false);
  const skipDelayTimerRef = React.useRef(0);
  React.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return (0, import_jsx_runtime2.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: React.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: React.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider$1.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext2(TOOLTIP_NAME);
var Tooltip$1 = (props2) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props2;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props2.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = React.useState(null);
  const contentId = useId$1();
  const openTimerRef = React.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return (0, import_jsx_runtime2.jsx)(Root2$4, { ...popperScope, children: (0, import_jsx_runtime2.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props2;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React.useRef(false);
    const hasPointerMoveOpenedRef = React.useRef(false);
    const handlePointerUp2 = React.useCallback(() => isPointerDownRef.current = false, []);
    React.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp2);
    }, [handlePointerUp2]);
    return (0, import_jsx_runtime2.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime2.jsx)(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props2.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props2.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props2.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp2, { once: true });
        }),
        onFocus: composeEventHandlers(props2.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props2.onBlur, context.onClose),
        onClick: composeEventHandlers(props2.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger$1.displayName = TRIGGER_NAME;
var PORTAL_NAME = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext2(PORTAL_NAME, {
  forceMount: void 0
});
var TooltipPortal = (props2) => {
  const { __scopeTooltip, forceMount, children, container } = props2;
  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);
  return (0, import_jsx_runtime2.jsx)(PortalProvider, { scope: __scopeTooltip, forceMount, children: (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime2.jsx)(Portal$4, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "TooltipContent";
var TooltipContent$1 = React.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props2.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props2;
    const context = useTooltipContext(CONTENT_NAME, props2.__scopeTooltip);
    return (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? (0, import_jsx_runtime2.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime2.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React.forwardRef((props2, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME, props2.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME, props2.__scopeTooltip);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger == null ? void 0 : trigger.contains(target)) || (content == null ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return (0, import_jsx_runtime2.jsx)(TooltipContentImpl, { ...props2, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext2(TOOLTIP_NAME, { isInside: false });
var Slottable = createSlottable("TooltipContent");
var TooltipContentImpl = React.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props2;
    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return (0, import_jsx_runtime2.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: (0, import_jsx_runtime2.jsxs)(
          Content$1,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              (0, import_jsx_runtime2.jsx)(Slottable, { children }),
              (0, import_jsx_runtime2.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: (0, import_jsx_runtime2.jsx)(Root$1, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent$1.displayName = CONTENT_NAME;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = React.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props2;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : (0, import_jsx_runtime2.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const ii2 = polygon[i2];
    const jj = polygon[j2];
    const xi = ii2.x;
    const yi2 = ii2.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi2 > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi2) / (yj - yi2) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b2) => {
    if (a2.x < b2.x) return -1;
    else if (a2.x > b2.x) return 1;
    else if (a2.y < b2.y) return -1;
    else if (a2.y > b2.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r3 = upperHull[upperHull.length - 2];
      if ((q2.x - r3.x) * (p2.y - r3.y) >= (q2.y - r3.y) * (p2.x - r3.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i2 = points.length - 1; i2 >= 0; i2--) {
    const p2 = points[i2];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r3 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r3.x) * (p2.y - r3.y) >= (q2.y - r3.y) * (p2.x - r3.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider$1;
var Root3 = Tooltip$1;
var Trigger = TooltipTrigger$1;
var Portal = TooltipPortal;
var Content2 = TooltipContent$1;
var Arrow2 = TooltipArrow;
function TooltipProvider({
  delayDuration = 0,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(
    Provider,
    {
      "data-slot": "tooltip-provider",
      delayDuration,
      ...props2
    }
  );
}
function Tooltip2({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(TooltipProvider, { children: (0, import_jsx_runtime2.jsx)(Root3, { "data-slot": "tooltip", ...props2 }) });
}
function TooltipTrigger({
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Trigger, { "data-slot": "tooltip-trigger", ...props2 });
}
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props2
}) {
  return (0, import_jsx_runtime2.jsx)(Portal, { container: getPipecatUIContainer(), children: (0, import_jsx_runtime2.jsxs)(
    Content2,
    {
      "data-slot": "tooltip-content",
      sideOffset,
      className: cn(
        "vkui:bg-primary vkui:text-primary-foreground vkui:animate-in vkui:fade-in-0 vkui:zoom-in-95 vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:w-fit vkui:origin-(--radix-tooltip-content-transform-origin) vkui:rounded-md vkui:px-3 vkui:py-1.5 vkui:text-xs vkui:text-balance",
        className
      ),
      ...props2,
      children: [
        children,
        (0, import_jsx_runtime2.jsx)(Arrow2, { className: "vkui:bg-primary vkui:fill-primary vkui:z-50 vkui:size-2.5 vkui:translate-y-[calc(-50%_-_2px)] vkui:rotate-45 vkui:rounded-[2px]" })
      ]
    }
  ) });
}
var ControlBarDivider = ({
  className
}) => {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: cn(
        "vkui:w-px vkui:bg-border vkui:self-stretch vkui:mx-2 ",
        className
      )
    }
  );
};
var ControlBar = ({
  children,
  noAnimateIn = false,
  className,
  ...props2
}) => {
  return (0, import_jsx_runtime2.jsx)(
    Card,
    {
      className: cn(
        !noAnimateIn && "vkui:animate-in vkui:fade-in vkui:slide-in-from-bottom-10 vkui:duration-500",
        className
      ),
      ...props2,
      children: (0, import_jsx_runtime2.jsx)(CardContent, { className: "vkui:flex vkui:flex-row vkui:gap-4 vkui:p-4", children })
    }
  );
};
var Thinking = ({
  "aria-label": ariaLabel = "Loading",
  className = "",
  initialDots = 1,
  interval = 500,
  maxDots = 3
}) => {
  const [dots, setDots] = (0, import_react2.useState)(initialDots);
  (0, import_react2.useEffect)(() => {
    const i2 = setInterval(() => {
      setDots((prevDots) => prevDots % maxDots + 1);
    }, interval);
    return () => clearInterval(i2);
  }, [interval, maxDots]);
  const renderDots = () => {
    return ".".repeat(dots);
  };
  return (0, import_jsx_runtime2.jsx)("span", { className, "aria-label": ariaLabel, children: renderDots() });
};
var sortByCreatedAt = (a2, b2) => {
  return new Date(a2.createdAt).getTime() - new Date(b2.createdAt).getTime();
};
var filterEmptyMessages = (message, index2, array) => {
  if (message.content) return true;
  const nextMessageWithSameRole = array.slice(index2 + 1).find((m2) => m2.role === message.role && m2.content);
  return !nextMessageWithSameRole;
};
var useConversation = ({ onMessageAdded } = {}) => {
  const [messages, setMessages] = (0, import_react2.useState)([]);
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.Connected, () => {
    setMessages([]);
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotLlmStarted, () => {
    const now = /* @__PURE__ */ new Date();
    setMessages((prev) => {
      const lastBotMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "assistant"
      );
      const lastBotMessage = prev[lastBotMessageIndex];
      if (lastBotMessage && lastBotMessage.role === "assistant" && !lastBotMessage.content) {
        return prev.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const newMessage = {
        role: "assistant",
        content: "",
        final: false,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
      };
      onMessageAdded == null ? void 0 : onMessageAdded(newMessage);
      return [...prev, newMessage].sort(sortByCreatedAt).filter(filterEmptyMessages);
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotLlmText, (data) => {
    const now = /* @__PURE__ */ new Date();
    setMessages((prev) => {
      const lastBotMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "assistant"
      );
      const lastBotMessage = prev[lastBotMessageIndex];
      if (!lastBotMessage) {
        const newMessage2 = {
          role: "assistant",
          content: data.text,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString()
        };
        onMessageAdded == null ? void 0 : onMessageAdded(newMessage2);
        return [...prev, newMessage2].sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      if (!lastBotMessage.content) {
        const newMessages = prev.slice();
        newMessages.splice(lastBotMessageIndex, 1, {
          ...lastBotMessage,
          content: data.text,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString()
        });
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const isRecent = lastBotMessage && lastBotMessage.role === "assistant" && now.getTime() - new Date(lastBotMessage.createdAt).getTime() < 1e4;
      if (isRecent) {
        const newMessages = prev.slice();
        newMessages.splice(lastBotMessageIndex, 1, {
          ...lastBotMessage,
          content: lastBotMessage.content + data.text,
          createdAt: lastBotMessage.content ? lastBotMessage.createdAt : now.toISOString(),
          updatedAt: now.toISOString()
        });
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const newMessage = {
        role: "assistant",
        content: data.text,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
      };
      onMessageAdded == null ? void 0 : onMessageAdded(newMessage);
      return [...prev, newMessage].sort(sortByCreatedAt).filter(filterEmptyMessages);
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotLlmStopped, () => {
    setMessages((prev) => {
      const lastBotMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "assistant"
      );
      const lastBotMessage = prev[lastBotMessageIndex];
      if (!lastBotMessage) return prev;
      if (lastBotMessage && lastBotMessage.role === "assistant" && !lastBotMessage.content) {
        return prev.slice(0, -1).sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      lastBotMessage.final = true;
      const newMessages = prev.slice();
      newMessages.splice(lastBotMessageIndex, 1, {
        ...lastBotMessage,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
      onMessageAdded == null ? void 0 : onMessageAdded(lastBotMessage);
      return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
    });
  });
  const userStoppedTimeout = (0, import_react2.useRef)(void 0);
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.UserStartedSpeaking, () => {
    clearTimeout(userStoppedTimeout.current);
    const now = /* @__PURE__ */ new Date();
    setMessages((prev) => {
      const lastUserMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "user"
      );
      const lastUserMessage = prev[lastUserMessageIndex];
      if (lastUserMessage && lastUserMessage.role === "user" && !lastUserMessage.content) {
        const newMessages = prev.slice();
        newMessages.splice(lastUserMessageIndex, 1, {
          ...lastUserMessage,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString()
        });
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const newMessage = {
        role: "user",
        content: "",
        final: false,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
      };
      onMessageAdded == null ? void 0 : onMessageAdded(newMessage);
      return [...prev, newMessage].sort(sortByCreatedAt).filter(filterEmptyMessages);
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.UserTranscript, (data) => {
    const now = /* @__PURE__ */ new Date();
    setMessages((prev) => {
      const lastUserMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "user"
      );
      const lastUserMessage = prev[lastUserMessageIndex];
      if (lastUserMessage && !lastUserMessage.final) {
        const updatedMessage = {
          ...lastUserMessage,
          final: data.final,
          content: data.text,
          updatedAt: now.toISOString()
        };
        onMessageAdded == null ? void 0 : onMessageAdded(updatedMessage);
        const newMessages = prev.slice();
        newMessages.splice(lastUserMessageIndex, 1, updatedMessage);
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const newMessage = {
        role: "user",
        content: data.text,
        final: data.final,
        createdAt: now.toISOString()
      };
      onMessageAdded == null ? void 0 : onMessageAdded(newMessage);
      return [...prev, newMessage].sort(sortByCreatedAt).filter(filterEmptyMessages);
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.UserStoppedSpeaking, () => {
    clearTimeout(userStoppedTimeout.current);
    userStoppedTimeout.current = setTimeout(() => {
      setMessages((prev) => {
        const lastUserMessageIndex = prev.findLastIndex(
          (msg) => msg.role === "user"
        );
        const lastUserMessage = prev[lastUserMessageIndex];
        if (!lastUserMessage || lastUserMessage.content)
          return prev.sort(sortByCreatedAt).filter(filterEmptyMessages);
        const newMessages = prev.slice();
        newMessages.splice(lastUserMessageIndex, 1);
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      });
    }, 5e3);
  });
  const getMergedMessages = () => {
    const mergedMessages = [];
    for (let i2 = 0; i2 < messages.length; i2++) {
      const currentMessage = messages[i2];
      const lastMerged = mergedMessages[mergedMessages.length - 1];
      const timeDiff = lastMerged ? Math.abs(
        new Date(currentMessage.createdAt).getTime() - new Date(lastMerged.createdAt).getTime()
      ) : Infinity;
      const shouldMerge = lastMerged && lastMerged.role === currentMessage.role && timeDiff < 3e4;
      if (shouldMerge) {
        mergedMessages[mergedMessages.length - 1] = {
          ...lastMerged,
          content: `${lastMerged.content} ${currentMessage.content}`,
          updatedAt: currentMessage.updatedAt || currentMessage.createdAt,
          final: currentMessage.final !== false
        };
      } else {
        mergedMessages.push({ ...currentMessage });
      }
    }
    return mergedMessages;
  };
  return {
    messages: getMergedMessages()
  };
};
var Conversation = ({
  classNames = {},
  noAutoscroll = false
}) => {
  const scrollRef = (0, import_react2.useRef)(null);
  const isScrolledToBottom = (0, import_react2.useRef)(true);
  const transportState = $33f3729bbe9f09df$export$30aee278309a867b();
  const maybeScrollToBottom = (0, import_react2.useCallback)(() => {
    if (!scrollRef.current) return;
    if (isScrolledToBottom.current) {
      scrollRef.current.scrollTo({
        top: scrollRef.current.scrollHeight,
        behavior: "smooth"
      });
    }
  }, []);
  const updateScrollState = (0, import_react2.useCallback)(() => {
    if (!scrollRef.current || noAutoscroll) return;
    isScrolledToBottom.current = Math.ceil(scrollRef.current.scrollHeight - scrollRef.current.scrollTop) <= Math.ceil(scrollRef.current.clientHeight);
  }, [noAutoscroll]);
  const { messages } = useConversation({
    onMessageAdded: () => {
      if (noAutoscroll) return;
      maybeScrollToBottom();
    }
  });
  (0, import_react2.useEffect)(() => {
    if (noAutoscroll) return;
    maybeScrollToBottom();
  }, [messages, maybeScrollToBottom, noAutoscroll]);
  (0, import_react2.useEffect)(() => {
    const scrollElement = scrollRef.current;
    if (!scrollElement) return;
    const handleScroll2 = () => updateScrollState();
    scrollElement.addEventListener("scroll", handleScroll2);
    updateScrollState();
    return () => scrollElement.removeEventListener("scroll", handleScroll2);
  }, [updateScrollState]);
  const isConnecting = transportState === "authenticating" || transportState === "connecting";
  const isConnected = transportState === "connected" || transportState === "ready";
  if (messages.length > 0) {
    return (0, import_jsx_runtime2.jsx)(
      "div",
      {
        ref: scrollRef,
        className: cn(
          "vkui:h-full vkui:overflow-y-auto vkui:p-4",
          classNames.container
        ),
        children: (0, import_jsx_runtime2.jsx)(
          "div",
          {
            className: cn(
              "vkui:grid vkui:grid-cols-[min-content_1fr] vkui:gap-x-4 vkui:gap-y-2",
              classNames.message
            ),
            children: messages.map((message, index2) => (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [
              (0, import_jsx_runtime2.jsx)(
                "div",
                {
                  className: cn(
                    "vkui:font-semibold vkui:font-mono vkui:text-xs vkui:leading-6",
                    {
                      "vkui:text-blue-500": message.role === "user",
                      "vkui:text-purple-500": message.role === "assistant"
                    },
                    classNames.role
                  ),
                  children: message.role
                }
              ),
              (0, import_jsx_runtime2.jsxs)(
                "div",
                {
                  className: cn(
                    "vkui:flex vkui:flex-col vkui:gap-2",
                    classNames.messageContent
                  ),
                  children: [
                    message.content || (0, import_jsx_runtime2.jsx)(Thinking, { className: classNames.thinking }),
                    (0, import_jsx_runtime2.jsx)(
                      "div",
                      {
                        className: cn(
                          "vkui:self-end vkui:text-xs vkui:text-gray-500 vkui:mb-1",
                          classNames.time
                        ),
                        children: new Date(message.createdAt).toLocaleTimeString()
                      }
                    )
                  ]
                }
              )
            ] }, index2))
          }
        )
      }
    );
  }
  if (isConnecting) {
    return (0, import_jsx_runtime2.jsx)(
      "div",
      {
        className: cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full",
          classNames.container
        ),
        children: (0, import_jsx_runtime2.jsx)("div", { className: "vkui:text-muted-foreground vkui:text-sm", children: "Connecting to agent..." })
      }
    );
  }
  if (!isConnected) {
    return (0, import_jsx_runtime2.jsx)(
      "div",
      {
        className: cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full",
          classNames.container
        ),
        children: (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:text-center vkui:p-4", children: [
          (0, import_jsx_runtime2.jsx)("div", { className: "vkui:text-muted-foreground vkui:mb-2", children: "Not connected to agent" }),
          (0, import_jsx_runtime2.jsx)("p", { className: "vkui:text-sm vkui:text-muted-foreground vkui:max-w-md", children: "Connect to an agent to see conversation messages in real-time." })
        ] })
      }
    );
  }
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: cn(
        "vkui:flex vkui:items-center vkui:justify-center vkui:h-full",
        classNames.container
      ),
      children: (0, import_jsx_runtime2.jsx)("div", { className: "vkui:text-muted-foreground vkui:text-sm", children: "Waiting for messages..." })
    }
  );
};
var CopyText = ({
  text,
  iconSize = 16,
  className = ""
}) => {
  const [copied, setCopied] = (0, import_react2.useState)(false);
  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    } catch (err) {
      console.error("Failed to copy text: ", err);
    }
  };
  return (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      className: cn(
        "vkui:flex vkui:items-center vkui:overflow-hidden vkui:w-full",
        className
      ),
      children: [
        (0, import_jsx_runtime2.jsx)("span", { className: "vkui:truncate vkui:min-w-0", children: text }),
        (0, import_jsx_runtime2.jsx)(TooltipProvider, { children: (0, import_jsx_runtime2.jsxs)(Tooltip2, { children: [
          (0, import_jsx_runtime2.jsx)(TooltipTrigger, { asChild: true, children: (0, import_jsx_runtime2.jsx)(
            Button,
            {
              variant: "ghost",
              isIcon: true,
              size: "sm",
              className: "vkui:flex-none vkui:text-muted-foreground",
              onClick: copyToClipboard,
              "aria-label": "Copy to clipboard",
              children: copied ? (0, import_jsx_runtime2.jsx)(CopyCheck, { size: iconSize }) : (0, import_jsx_runtime2.jsx)(Copy, { size: iconSize })
            }
          ) }),
          (0, import_jsx_runtime2.jsx)(TooltipContent, { children: copied ? "Copied!" : "Copy to clipboard" })
        ] }) })
      ]
    }
  );
};
var aspectRatio = 45 / 26;
var PipecatLogo = ({
  className = "",
  alt = "Pipecat Logo",
  color: color2 = "currentColor",
  height,
  width
}) => {
  const resolvedHeight = height ? height : width ? Math.round(width / aspectRatio) : 100;
  const resolvedWidth = width ? width : height ? Math.round(height * aspectRatio) : 200;
  return (0, import_jsx_runtime2.jsxs)(
    "svg",
    {
      width: resolvedWidth,
      height: resolvedHeight,
      viewBox: "0 0 45 26",
      xmlns: "http://www.w3.org/2000/svg",
      className,
      "aria-label": alt,
      children: [
        (0, import_jsx_runtime2.jsx)(
          "path",
          {
            d: "M6.19825 0.104287C6.83144 -0.13411 7.5461 0.044779 7.99232 0.553371L13.8037 7.17714H31.1545L36.9659 0.553371C37.4121 0.044779 38.1268 -0.13411 38.76 0.104287C39.3932 0.342685 39.8124 0.948477 39.8124 1.62507V16.25H44.9582V19.5H36.5624V5.94116L33.112 9.87383C32.8035 10.2255 32.3584 10.4271 31.8905 10.4271H13.0677C12.5998 10.4271 12.1547 10.2255 11.8462 9.87383L8.39581 5.94116V19.5H0V16.25H5.14582V1.62507C5.14582 0.948477 5.56505 0.342685 6.19825 0.104287Z",
            fill: color2
          }
        ),
        (0, import_jsx_runtime2.jsx)("path", { d: "M36.5624 22.75H44.9582V26H36.5624V22.75Z", fill: color2 }),
        (0, import_jsx_runtime2.jsx)("path", { d: "M0 22.75H8.39581V26H0V22.75Z", fill: color2 }),
        (0, import_jsx_runtime2.jsx)(
          "path",
          {
            d: "M17.3333 17.3334C17.3333 18.53 16.3632 19.5 15.1666 19.5C13.97 19.5 13 18.53 13 17.3334C13 16.1367 13.97 15.1667 15.1666 15.1667C16.3632 15.1667 17.3333 16.1367 17.3333 17.3334Z",
            fill: color2
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          "path",
          {
            d: "M31.9582 17.3334C31.9582 18.53 30.9882 19.5 29.7916 19.5C28.595 19.5 27.6249 18.53 27.6249 17.3334C27.6249 16.1367 28.595 15.1667 29.7916 15.1667C30.9882 15.1667 31.9582 16.1367 31.9582 17.3334Z",
            fill: color2
          }
        )
      ]
    }
  );
};
var SessionInfo = ({
  noTransportType = false,
  noSessionId = false,
  noParticipantId = false,
  noRTVIVersion = false,
  sessionId,
  participantId
}) => {
  const client = $034a56e7ee1b7bed$export$777fa8498be78705();
  let transportTypeName = "Unknown";
  if (client && "dailyCallClient" in client.transport) {
    transportTypeName = `Daily (v${Ha.version()})`;
  } else if (
    // @ts-expect-error - __proto__ not typed
    (client == null ? void 0 : client.transport.__proto__.constructor.SERVICE_NAME) === "small-webrtc-transport"
  ) {
    transportTypeName = "Small WebRTC";
  }
  const data = {};
  if (!noTransportType) {
    data["Transport"] = transportTypeName;
  }
  if (!noSessionId) {
    data["Session ID"] = sessionId ? (0, import_jsx_runtime2.jsx)(CopyText, { className: "vkui:justify-end", iconSize: 12, text: sessionId }) : (0, import_jsx_runtime2.jsx)(TextDashBlankslate, {});
  }
  if (!noParticipantId) {
    data["Participant ID"] = participantId ? (0, import_jsx_runtime2.jsx)(
      CopyText,
      {
        className: "vkui:justify-end",
        iconSize: 12,
        text: participantId
      }
    ) : (0, import_jsx_runtime2.jsx)(TextDashBlankslate, {});
  }
  if (!noRTVIVersion) {
    data["RTVI"] = (client == null ? void 0 : client.version) || (0, import_jsx_runtime2.jsx)(TextDashBlankslate, {});
  }
  return (0, import_jsx_runtime2.jsx)(
    DataList,
    {
      classNames: { container: "vkui:w-full vkui:overflow-hidden" },
      data
    }
  );
};
var transcriptOverlayVariants = cva(
  `vkui:mx-auto vkui:items-center vkui:justify-end vkui:text-center 
  vkui:*:box-decoration-clone vkui:*:text-balance vkui:*:animate-in vkui:*:fade-in vkui:*:duration-300 vkui:*:mx-auto
  vkui:*:**:bg-foreground vkui:*:**:text-background vkui:*:**:box-decoration-clone vkui:*:**:text-balance
  `,
  {
    variants: {
      size: {
        default: "vkui:*:leading-6 vkui:*:**:px-3 vkui:*:**:py-1.5 vkui:*:**:text-sm vkui:*:**:font-medium vkui:*:**:rounded-lg",
        sm: "vkui:*:leading-4 vkui:*:**:px-2 vkui:*:**:py-1 vkui:*:**:text-xs vkui:*:**:font-medium vkui:*:**:rounded-md",
        lg: "vkui:*:leading-7 vkui:*:**:px-4 vkui:*:**:py-2 vkui:*:**:text-base vkui:*:**:font-medium vkui:*:**:rounded-xl"
      }
    }
  }
);
var TranscriptOverlayPartComponent = ({ text }) => (0, import_jsx_runtime2.jsx)("span", { children: text });
var TranscriptOverlayComponent = ({
  children,
  className,
  size: size2 = "default",
  turnEnd
}) => {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: cn(
        transcriptOverlayVariants({ size: size2 }),
        turnEnd ? "vkui:animate-out vkui:fade-out vkui:duration-1000 vkui:fill-mode-forwards" : "",
        className
      ),
      children: (0, import_jsx_runtime2.jsx)("p", { children })
    }
  );
};
var TranscriptOverlay = ({
  participant = "remote",
  className,
  size: size2 = "default"
}) => {
  const [transcript, setTranscript] = (0, import_react2.useState)([]);
  const [turnEnd, setIsTurnEnd] = (0, import_react2.useState)(false);
  const transportState = $33f3729bbe9f09df$export$30aee278309a867b();
  $824ea64b5f757259$export$33a6ac53b8f02625(
    $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotTtsText,
    (0, import_react2.useCallback)(
      (event) => {
        if (participant === "local") {
          return;
        }
        if (turnEnd) {
          setTranscript([]);
          setIsTurnEnd(false);
        }
        setTranscript((prev) => [...prev, event.text]);
      },
      [turnEnd, participant]
    )
  );
  $824ea64b5f757259$export$33a6ac53b8f02625(
    $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotStoppedSpeaking,
    (0, import_react2.useCallback)(() => {
      if (participant === "local") {
        return;
      }
      setIsTurnEnd(true);
    }, [participant])
  );
  $824ea64b5f757259$export$33a6ac53b8f02625(
    $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotTtsStopped,
    (0, import_react2.useCallback)(() => {
      if (participant === "local") {
        return;
      }
      setIsTurnEnd(true);
    }, [participant])
  );
  if (transcript.length === 0 || transportState !== "ready") {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(
    TranscriptOverlayComponent,
    {
      size: size2,
      turnEnd,
      className,
      children: (0, import_jsx_runtime2.jsx)(TranscriptOverlayPartComponent, { text: transcript.join(" ") })
    }
  );
};
var VoiceVisualizer = import_react2.default.memo(
  ({
    backgroundColor = "transparent",
    barColor = "black",
    barCount: barCount2 = 5,
    barGap = 12,
    barLineCap = "round",
    barMaxHeight = 120,
    barOrigin = "center",
    barWidth = 30,
    participantType,
    className
  }) => {
    const canvasRef = (0, import_react2.useRef)(null);
    const resolvedBarColorRef = (0, import_react2.useRef)("black");
    (0, import_react2.useEffect)(() => {
      function resolveColor(color2) {
        if (!color2) return "black";
        if (color2.startsWith("--")) {
          return getComputedStyle(document.documentElement).getPropertyValue(color2).trim() || "black";
        }
        return color2;
      }
      resolvedBarColorRef.current = resolveColor(barColor);
    }, [barColor]);
    const track2 = $4b4b9099cdb5b776$export$9813dcd2d0c26814(
      "audio",
      participantType
    );
    (0, import_react2.useEffect)(() => {
      if (!canvasRef.current) return;
      const canvasWidth = barCount2 * barWidth + (barCount2 - 1) * barGap;
      const canvasHeight = barMaxHeight;
      const canvas = canvasRef.current;
      const scaleFactor = 2;
      const resizeCanvas = () => {
        canvas.width = canvasWidth * scaleFactor;
        canvas.height = canvasHeight * scaleFactor;
        canvas.style.width = `${canvasWidth}px`;
        canvas.style.height = `${canvasHeight}px`;
        canvasCtx.lineCap = barLineCap;
        canvasCtx.scale(scaleFactor, scaleFactor);
      };
      const canvasCtx = canvas.getContext("2d");
      resizeCanvas();
      if (!track2) return;
      const audioContext = new AudioContext();
      const source = audioContext.createMediaStreamSource(
        new MediaStream([track2])
      );
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 1024;
      source.connect(analyser);
      const frequencyData = new Uint8Array(analyser.frequencyBinCount);
      canvasCtx.lineCap = barLineCap;
      const bands = Array.from({ length: barCount2 }, (_2, i2) => {
        const minFreq = barCount2 > 20 ? 200 : 80;
        const maxFreq = 1e4;
        const melMin = 2595 * Math.log10(1 + minFreq / 700);
        const melMax = 2595 * Math.log10(1 + maxFreq / 700);
        const melStep = (melMax - melMin) / barCount2;
        const melValue = melMin + i2 * melStep;
        const startFreq = 700 * (Math.pow(10, melValue / 2595) - 1);
        const endFreq = 700 * (Math.pow(10, (melValue + melStep) / 2595) - 1);
        return {
          startFreq,
          endFreq,
          smoothValue: 0
        };
      });
      const getFrequencyBinIndex = (frequency) => {
        const nyquist = audioContext.sampleRate / 2;
        return Math.round(
          frequency / nyquist * (analyser.frequencyBinCount - 1)
        );
      };
      function drawSpectrum() {
        analyser.getByteFrequencyData(frequencyData);
        canvasCtx.clearRect(
          0,
          0,
          canvas.width / scaleFactor,
          canvas.height / scaleFactor
        );
        canvasCtx.fillStyle = backgroundColor;
        canvasCtx.fillRect(
          0,
          0,
          canvas.width / scaleFactor,
          canvas.height / scaleFactor
        );
        let isActive = false;
        const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
        const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
        const adjustedCircleRadius = barWidth / 2;
        const resolvedBarColor = resolvedBarColorRef.current;
        bands.forEach((band, i2) => {
          const startIndex = getFrequencyBinIndex(band.startFreq);
          const endIndex = getFrequencyBinIndex(band.endFreq);
          const bandData = frequencyData.slice(startIndex, endIndex);
          const bandValue = bandData.reduce((acc, val) => acc + val, 0) / bandData.length;
          const smoothingFactor = 0.2;
          if (bandValue < 1) {
            band.smoothValue = Math.max(
              band.smoothValue - smoothingFactor * 5,
              0
            );
          } else {
            band.smoothValue = band.smoothValue + (bandValue - band.smoothValue) * smoothingFactor;
            isActive = true;
          }
          const x2 = startX + i2 * (barWidth + barGap);
          const minHeight = 0;
          const barHeight = Math.max(
            minHeight,
            Math.min(band.smoothValue / 255 * barMaxHeight, barMaxHeight)
          );
          let yTop, yBottom;
          const canvasHeight2 = canvas.height / scaleFactor;
          switch (barOrigin) {
            case "top":
              yTop = adjustedCircleRadius;
              yBottom = Math.min(
                adjustedCircleRadius + barHeight,
                canvasHeight2 - adjustedCircleRadius
              );
              break;
            case "bottom":
              yBottom = canvasHeight2 - adjustedCircleRadius;
              yTop = Math.max(yBottom - barHeight, adjustedCircleRadius);
              break;
            case "center":
            default:
              yTop = Math.max(
                canvasHeight2 / 2 - barHeight / 2,
                adjustedCircleRadius
              );
              yBottom = Math.min(
                canvasHeight2 / 2 + barHeight / 2,
                canvasHeight2 - adjustedCircleRadius
              );
              break;
          }
          if (band.smoothValue > 0) {
            canvasCtx.beginPath();
            canvasCtx.moveTo(x2 + barWidth / 2, yTop);
            canvasCtx.lineTo(x2 + barWidth / 2, yBottom);
            canvasCtx.lineWidth = barWidth;
            canvasCtx.strokeStyle = resolvedBarColor;
            canvasCtx.stroke();
          } else {
            drawInactiveCircle(adjustedCircleRadius, resolvedBarColor, x2, yTop);
          }
        });
        if (!isActive) {
          drawInactiveCircles(adjustedCircleRadius, resolvedBarColor);
        }
        requestAnimationFrame(drawSpectrum);
      }
      function drawInactiveCircle(circleRadius, color2, x2, y2) {
        switch (barLineCap) {
          case "square":
            canvasCtx.fillStyle = color2;
            canvasCtx.fillRect(
              x2 + barWidth / 2 - circleRadius,
              y2 - circleRadius,
              circleRadius * 2,
              circleRadius * 2
            );
            break;
          case "round":
          default:
            canvasCtx.beginPath();
            canvasCtx.arc(x2 + barWidth / 2, y2, circleRadius, 0, 2 * Math.PI);
            canvasCtx.fillStyle = color2;
            canvasCtx.fill();
            canvasCtx.closePath();
            break;
        }
      }
      function drawInactiveCircles(circleRadius, color2) {
        const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
        const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
        const canvasHeight2 = canvas.height / scaleFactor;
        let y2;
        switch (barOrigin) {
          case "top":
            y2 = circleRadius;
            break;
          case "bottom":
            y2 = canvasHeight2 - circleRadius;
            break;
          case "center":
          default:
            y2 = canvasHeight2 / 2;
            break;
        }
        bands.forEach((_2, i2) => {
          const x2 = startX + i2 * (barWidth + barGap);
          drawInactiveCircle(circleRadius, color2, x2, y2);
        });
      }
      drawSpectrum();
      window.addEventListener("resize", resizeCanvas);
      return () => {
        audioContext.close();
        window.removeEventListener("resize", resizeCanvas);
      };
    }, [
      backgroundColor,
      barCount2,
      barGap,
      barLineCap,
      barMaxHeight,
      barOrigin,
      barWidth,
      track2,
      barColor
    ]);
    return (0, import_jsx_runtime2.jsx)(
      "canvas",
      {
        ref: canvasRef,
        style: {
          display: "block",
          width: "100%",
          height: "100%"
        },
        className
      }
    );
  }
);
VoiceVisualizer.displayName = "VoiceVisualizer";
var DeviceDropDown = ({
  children,
  noMenuLabel = false,
  noMenuSeparator = false,
  menuLabel = "Device select",
  availableDevices,
  selectedDevice,
  updateDevice,
  classNames
}) => {
  return (0, import_jsx_runtime2.jsxs)(DropdownMenu, { children: [
    (0, import_jsx_runtime2.jsx)(DropdownMenuTrigger, { asChild: true, children }),
    (0, import_jsx_runtime2.jsxs)(
      DropdownMenuContent,
      {
        align: "end",
        className: cn(classNames == null ? void 0 : classNames.dropdownMenuContent),
        children: [
          !noMenuLabel && (0, import_jsx_runtime2.jsx)(DropdownMenuLabel, { children: menuLabel }),
          !noMenuSeparator && (0, import_jsx_runtime2.jsx)(DropdownMenuSeparator, {}),
          availableDevices == null ? void 0 : availableDevices.map((device) => (0, import_jsx_runtime2.jsx)(
            DropdownMenuCheckboxItem,
            {
              checked: (selectedDevice == null ? void 0 : selectedDevice.deviceId) === device.deviceId,
              onCheckedChange: () => updateDevice == null ? void 0 : updateDevice(device.deviceId),
              className: cn(classNames == null ? void 0 : classNames.dropdownMenuCheckboxItem),
              children: device.label || `Device ${device.deviceId.slice(0, 5)}`
            },
            device.deviceId
          ))
        ]
      }
    )
  ] });
};
var btnClasses = "vkui:flex-1 vkui:w-full vkui:z-10 vkui:justify-start";
var UserAudioComponent = ({
  variant = "secondary",
  size: size2 = "default",
  classNames = {},
  buttonProps = {},
  dropdownButtonProps = {},
  noDevicePicker = false,
  noVisualizer = false,
  visualizerProps = {},
  isMicEnabled = false,
  state,
  availableMics,
  selectedMic,
  updateMic,
  noAudio,
  noAudioText = "Audio disabled",
  onClick
}) => {
  var _a3;
  if (noAudio || (buttonProps == null ? void 0 : buttonProps.isLoading)) {
    return (0, import_jsx_runtime2.jsx)(
      Button,
      {
        variant,
        size: size2,
        ...buttonProps,
        disabled: true,
        className: cn(
          btnClasses,
          (buttonProps == null ? void 0 : buttonProps.isLoading) && "vkui:justify-center",
          classNames.button
        ),
        children: !(buttonProps == null ? void 0 : buttonProps.isLoading) && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
          (0, import_jsx_runtime2.jsx)(MicOffIcon, {}),
          (0, import_jsx_runtime2.jsx)("span", { className: "vkui:flex-1", children: noAudioText })
        ] })
      }
    );
  }
  const buttonState = state || (isMicEnabled ? "default" : "inactive");
  const accentColor = ((_a3 = buttonAccentColorMap[variant || "default"]) == null ? void 0 : _a3[buttonState]) || "black";
  const button = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsxs)(
      Button,
      {
        onClick,
        className: cn(btnClasses, classNames.button),
        variant,
        state: buttonState,
        size: size2,
        ...buttonProps,
        children: [
          isMicEnabled ? (0, import_jsx_runtime2.jsx)(MicIcon, {}) : (0, import_jsx_runtime2.jsx)(MicOffIcon, {}),
          !noVisualizer && (0, import_jsx_runtime2.jsx)(
            VoiceVisualizer,
            {
              participantType: "local",
              backgroundColor: "transparent",
              barCount: 10,
              barGap: 2,
              barMaxHeight: size2 === "lg" ? 24 : size2 === "xl" ? 36 : 20,
              barOrigin: "center",
              barWidth: 3,
              barColor: accentColor,
              className: "vkui:mx-auto",
              ...visualizerProps
            }
          )
        ]
      }
    ),
    !noDevicePicker && (0, import_jsx_runtime2.jsx)(
      DeviceDropDown,
      {
        menuLabel: "Microphone device",
        availableDevices: availableMics,
        selectedDevice: selectedMic,
        updateDevice: updateMic,
        classNames: {
          dropdownMenuContent: classNames.dropdownMenuContent,
          dropdownMenuCheckboxItem: classNames.dropdownMenuCheckboxItem
        },
        children: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            className: cn(
              "vkui:p-2! vkui:flex-none vkui:z-0",
              classNames.dropdownMenuTrigger
            ),
            variant,
            size: size2,
            isIcon: true,
            ...dropdownButtonProps,
            children: (0, import_jsx_runtime2.jsx)(ChevronDownIcon, { size: 16 })
          }
        )
      }
    )
  ] });
  if (noDevicePicker) {
    return button;
  }
  return (0, import_jsx_runtime2.jsx)(
    ButtonGroup,
    {
      className: cn(
        "vkui:w-full",
        variant !== "outline" && "vkui:gap-[2px]",
        classNames.buttongroup
      ),
      children: button
    }
  );
};
var UserAudioControl = (props2) => {
  const client = $034a56e7ee1b7bed$export$777fa8498be78705();
  const { availableMics, selectedMic, updateMic } = $f934f1f8b10aaf19$export$642bc4d2d2a376f1();
  const hasAudio = client == null ? void 0 : client.isMicEnabled;
  const loading = hasAudio === null;
  (0, import_react2.useEffect)(() => {
    if (!client) return;
    if (["idle", "disconnected"].includes(client.state)) {
      client.initDevices();
    }
  }, [client]);
  return (0, import_jsx_runtime2.jsx)($2984fdfc31bad375$export$bc8133b69ff660a2, { children: ({ isMicEnabled, onClick }) => (0, import_jsx_runtime2.jsx)(
    UserAudioComponent,
    {
      noAudio: !hasAudio,
      onClick,
      isMicEnabled,
      availableMics,
      selectedMic,
      updateMic,
      state: isMicEnabled ? "default" : "inactive",
      buttonProps: {
        isLoading: loading
      },
      ...props2
    }
  ) });
};
var UserVideoComponent = ({
  buttonProps = {},
  classNames = {},
  dropdownButtonProps = {},
  noDevicePicker = false,
  noVideo = false,
  videoProps = {},
  onClick,
  isCamEnabled,
  availableCams = [],
  selectedCam,
  updateCam
}) => {
  return (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      className: cn(
        "vkui:bg-muted vkui:rounded-xl vkui:relative",
        {
          "vkui:aspect-video": isCamEnabled && !noVideo,
          "vkui:h-12": !isCamEnabled || noVideo
        },
        classNames.container
      ),
      children: [
        !noVideo && (0, import_jsx_runtime2.jsx)(
          $6a65deb8615a2ad7$export$85974db6d0cc43b3,
          {
            className: cn(
              "vkui:rounded-xl",
              {
                "vkui:hidden": !isCamEnabled
              },
              classNames.video
            ),
            participant: "local",
            ...videoProps
          }
        ),
        (!isCamEnabled || noVideo) && (0, import_jsx_runtime2.jsx)(
          "div",
          {
            className: cn(
              "vkui:absolute vkui:h-full vkui:left-28 vkui:flex vkui:items-center vkui:justify-start vkui:rounded-xl",
              {
                "vkui:left-16": noDevicePicker
              },
              classNames.videoOffContainer
            ),
            children: (0, import_jsx_runtime2.jsx)(
              "div",
              {
                className: cn(
                  "vkui:text-muted-foreground vkui:font-mono vkui:text-sm",
                  classNames.videoOffText
                ),
                children: isCamEnabled ? "Camera is on" : "Camera is off"
              }
            )
          }
        ),
        (0, import_jsx_runtime2.jsx)("div", { className: "vkui:absolute vkui:bottom-2 vkui:left-2", children: (0, import_jsx_runtime2.jsxs)(ButtonGroup, { className: cn(classNames.buttongroup), children: [
          (0, import_jsx_runtime2.jsx)(
            Button,
            {
              className: cn(classNames.button),
              variant: "outline",
              onClick,
              ...buttonProps,
              children: isCamEnabled ? (0, import_jsx_runtime2.jsx)(VideoIcon, {}) : (0, import_jsx_runtime2.jsx)(VideoOffIcon, {})
            }
          ),
          !noDevicePicker && (0, import_jsx_runtime2.jsx)(
            DeviceDropDown,
            {
              availableDevices: availableCams,
              selectedDevice: selectedCam,
              updateDevice: updateCam,
              classNames: {
                dropdownMenuCheckboxItem: classNames.dropdownMenuCheckboxItem,
                dropdownMenuContent: classNames.dropdownMenuContent,
                dropdownMenuTrigger: classNames.dropdownMenuTrigger
              },
              menuLabel: "Camera device",
              children: (0, import_jsx_runtime2.jsx)(
                Button,
                {
                  className: cn(classNames.dropdownMenuTrigger),
                  variant: "outline",
                  ...dropdownButtonProps,
                  children: (0, import_jsx_runtime2.jsx)(ChevronDownIcon, {})
                }
              )
            }
          )
        ] }) })
      ]
    }
  );
};
var UserVideoControl = (props2) => {
  const { availableCams, selectedCam, updateCam } = $f934f1f8b10aaf19$export$642bc4d2d2a376f1();
  return (0, import_jsx_runtime2.jsx)($7cb2ce2c4cbfb401$export$dc9a029eeca8213f, { children: ({ isCamEnabled, onClick }) => (0, import_jsx_runtime2.jsx)(
    UserVideoComponent,
    {
      ...props2,
      isCamEnabled,
      onClick,
      availableCams,
      selectedCam,
      updateCam
    }
  ) });
};
var initialState = {
  resolvedTheme: "light",
  theme: "system",
  setTheme: () => null
};
var ThemeProviderContext = (0, import_react2.createContext)(initialState);
function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "voice-ui-kit-theme",
  ...props2
}) {
  const [theme, setTheme] = (0, import_react2.useState)(() => {
    if (typeof window !== "undefined") {
      const storedTheme = localStorage.getItem(storageKey);
      return storedTheme || defaultTheme;
    }
    return defaultTheme;
  });
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    setMounted(true);
  }, []);
  (0, import_react2.useEffect)(() => {
    if (!mounted) return;
    if (theme !== "system") {
      localStorage.setItem(storageKey, theme);
    } else {
      localStorage.removeItem(storageKey);
    }
  }, [mounted, storageKey, theme]);
  (0, import_react2.useEffect)(() => {
    if (!mounted) return;
    const root = window.document.documentElement;
    root.classList.remove("vkui:light", "vkui:dark");
    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "vkui:dark" : "vkui:light";
      root.classList.add(systemTheme);
      return;
    }
    root.classList.add(`vkui:${theme}`);
  }, [theme, mounted]);
  (0, import_react2.useEffect)(() => {
    if (!mounted) return;
    const storedTheme = localStorage.getItem(storageKey);
    if (!storedTheme) {
      setTheme(defaultTheme);
    }
  }, [defaultTheme, mounted, storageKey]);
  const value = {
    theme,
    setTheme: (newTheme) => {
      setTheme(newTheme);
    },
    resolvedTheme: theme === "system" ? typeof window !== "undefined" && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : theme
  };
  return (0, import_jsx_runtime2.jsx)(ThemeProviderContext.Provider, { ...props2, value, children });
}
var AudioClientHelper = ({
  connectParams,
  transportType,
  clientOptions,
  children
}) => {
  const [client, setClient] = (0, import_react2.useState)(null);
  const [error, setError] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    let transport;
    switch (transportType) {
      case "smallwebrtc":
        transport = new $b31644dc78dca54a$export$62043589d053a879();
        break;
      case "daily":
      default:
        transport = new $683f111f61e07358$export$b1ca982aa1e488c1();
        break;
    }
    const pcClient = new $364c127d152b1085$export$8f7f86a77535f7a3({
      enableCam: false,
      enableMic: true,
      transport,
      ...clientOptions
    });
    setClient(pcClient);
    return () => {
      pcClient.disconnect();
    };
  }, [connectParams, transportType, clientOptions]);
  const handleConnect = async () => {
    if (!client || !["initialized", "disconnected", "error"].includes(client.state)) {
      return;
    }
    setError(null);
    try {
      await client.connect(connectParams);
    } catch (err) {
      console.error("Connection error:", err);
      setError(
        `Failed to start session: ${err instanceof Error ? err.message : String(err)}`
      );
    }
  };
  const handleDisconnect = async () => {
    if (!client) return;
    await client.disconnect();
  };
  if (!client) {
    return children({ loading: true, error: null });
  }
  return (0, import_jsx_runtime2.jsx)(ThemeProvider, { children: (0, import_jsx_runtime2.jsxs)($d2e362c5a07ee3c5$export$bb43666ced7a20d0, { client, children: [
    children({
      handleConnect,
      handleDisconnect,
      loading: false,
      error
    }),
    (0, import_jsx_runtime2.jsx)($f209aa7ddb77dcb2$export$b52250cb73ff4de1, {})
  ] }) });
};
var barCount = 10;
var BotAudioPanel = ({
  className,
  collapsed = false
}) => {
  const track2 = $4b4b9099cdb5b776$export$9813dcd2d0c26814("audio", "bot");
  const [maxHeight, setMaxHeight] = (0, import_react2.useState)(48);
  const [width, setWidth] = (0, import_react2.useState)(4);
  const containerRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    if (!containerRef.current) return;
    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width: width2, height } = entry.contentRect;
        const maxWidth = 240;
        const maxBarWidth = maxWidth / (2 * barCount - 1);
        const maxMaxHeight = 240 / (16 / 9);
        const barWidth = Math.max(
          Math.min(width2 / (barCount * 2), maxBarWidth),
          2
        );
        const maxHeight2 = Math.max(Math.min(height, maxMaxHeight), 20);
        setMaxHeight(maxHeight2);
        setWidth(barWidth);
      }
    });
    observer.observe(containerRef.current);
    return () => {
      observer.disconnect();
    };
  }, []);
  return (0, import_jsx_runtime2.jsxs)(
    Panel$1,
    {
      className: cn(
        "vkui:flex-1 vkui:mt-auto",
        {
          "vkui:flex-0 vkui:border-none": collapsed
        },
        className
      ),
      children: [
        !collapsed && (0, import_jsx_runtime2.jsx)(PanelHeader, { children: (0, import_jsx_runtime2.jsx)(PanelTitle, { children: "Bot Audio" }) }),
        (0, import_jsx_runtime2.jsx)(
          PanelContent,
          {
            className: cn("vkui:overflow-hidden vkui:flex-1", {
              "vkui:aspect-video": collapsed
            }),
            children: (0, import_jsx_runtime2.jsx)(
              "div",
              {
                ref: containerRef,
                className: "vkui:relative vkui:flex vkui:h-full vkui:overflow-hidden",
                children: track2 ? (0, import_jsx_runtime2.jsx)("div", { className: "vkui:m-auto", children: (0, import_jsx_runtime2.jsx)(
                  $993a744193844a95$export$59bf27bd43679db6,
                  {
                    participantType: "bot",
                    backgroundColor: "transparent",
                    barColor: "#ad46ff",
                    barCount,
                    barGap: width,
                    barLineCap: "square",
                    barMaxHeight: maxHeight,
                    barOrigin: "bottom",
                    barWidth: width
                  }
                ) }) : (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:text-subtle vkui:flex vkui:w-full vkui:gap-2 vkui:items-center vkui:justify-center", children: [
                  (0, import_jsx_runtime2.jsx)(MicOffIcon, { size: 16 }),
                  !collapsed && (0, import_jsx_runtime2.jsx)("span", { className: "vkui:font-semibold vkui:text-sm", children: "No audio" })
                ] })
              }
            )
          }
        )
      ]
    }
  );
};
var BotVideoPanel = ({
  className,
  collapsed = false
}) => {
  const track2 = $4b4b9099cdb5b776$export$9813dcd2d0c26814("video", "bot");
  return (0, import_jsx_runtime2.jsxs)(
    Panel$1,
    {
      className: cn(
        "vkui:flex-1 vkui:mb-auto",
        {
          "vkui:flex-0 vkui:border-none": collapsed
        },
        className
      ),
      children: [
        !collapsed && (0, import_jsx_runtime2.jsx)(PanelHeader, { children: (0, import_jsx_runtime2.jsx)(PanelTitle, { children: "Bot Video" }) }),
        (0, import_jsx_runtime2.jsx)(
          PanelContent,
          {
            className: cn("vkui:overflow-hidden vkui:flex-1", {
              "vkui:aspect-video": collapsed
            }),
            children: track2 ? (0, import_jsx_runtime2.jsx)(
              "div",
              {
                className: cn(
                  "vkui:relative vkui:flex vkui:h-full vkui:bg-muted vkui:rounded-sm",
                  {
                    "vkui:aspect-video": collapsed
                  }
                ),
                children: (0, import_jsx_runtime2.jsx)(
                  $6a65deb8615a2ad7$export$85974db6d0cc43b3,
                  {
                    participant: "bot",
                    className: "vkui:aspect-video vkui:max-h-full",
                    fit: "contain"
                  }
                )
              }
            ) : (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:text-subtle vkui:flex vkui:w-full vkui:h-full vkui:gap-2 vkui:items-center vkui:justify-center", children: [
              (0, import_jsx_runtime2.jsx)(VideoOffIcon, { size: 16 }),
              !collapsed && (0, import_jsx_runtime2.jsx)("span", { className: "vkui:font-semibold vkui:text-sm", children: "No video" })
            ] })
          }
        )
      ]
    }
  );
};
var ConversationPanel = ({
  noConversation = false,
  noMetrics = false
}) => {
  const defaultValue = noConversation ? "metrics" : "conversation";
  return (0, import_jsx_runtime2.jsx)(Tabs, { className: "vkui:h-full", defaultValue, children: (0, import_jsx_runtime2.jsxs)(Panel$1, { className: "vkui:h-full vkui:max-sm:border-none", children: [
    (0, import_jsx_runtime2.jsx)(PanelHeader, { variant: "noPadding", className: "vkui:py-1.5", children: (0, import_jsx_runtime2.jsxs)(TabsList, { children: [
      !noConversation && (0, import_jsx_runtime2.jsxs)(TabsTrigger, { value: "conversation", children: [
        (0, import_jsx_runtime2.jsx)(MessagesSquareIcon, { size: 20 }),
        "Conversation"
      ] }),
      !noMetrics && (0, import_jsx_runtime2.jsxs)(TabsTrigger, { value: "metrics", children: [
        (0, import_jsx_runtime2.jsx)(LineChartIcon, { size: 20 }),
        "Metrics"
      ] })
    ] }) }),
    (0, import_jsx_runtime2.jsxs)(PanelContent, { className: "vkui:p-0! vkui:overflow-hidden vkui:h-full", children: [
      !noConversation && (0, import_jsx_runtime2.jsx)(
        TabsContent,
        {
          value: "conversation",
          className: "vkui:overflow-hidden vkui:h-full",
          children: (0, import_jsx_runtime2.jsx)(Conversation, {})
        }
      ),
      !noMetrics && (0, import_jsx_runtime2.jsx)(TabsContent, { value: "metrics", className: "vkui:h-full", children: (0, import_jsx_runtime2.jsx)(Metrics, {}) })
    ] })
  ] }) });
};
var EventsPanel = ({ collapsed = false }) => {
  const client = $034a56e7ee1b7bed$export$777fa8498be78705();
  const [events, setEvents] = (0, import_react2.useState)([]);
  const scrollRef = (0, import_react2.useRef)(null);
  const isScrolledToBottom = (0, import_react2.useRef)(true);
  const addEvent = (0, import_react2.useCallback)((data) => {
    if (scrollRef.current) {
      isScrolledToBottom.current = Math.ceil(
        scrollRef.current.scrollHeight - scrollRef.current.scrollTop
      ) <= Math.ceil(scrollRef.current.clientHeight);
    }
    setEvents((prev) => {
      return [...prev, data];
    });
  }, []);
  const transportState = $33f3729bbe9f09df$export$30aee278309a867b();
  const lastTransportState = (0, import_react2.useRef)("");
  (0, import_react2.useEffect)(() => {
    if (transportState === lastTransportState.current) return;
    addEvent({
      event: "transportState",
      message: `Transport state changed: ${transportState}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
    lastTransportState.current = transportState;
  }, [addEvent, transportState]);
  (0, import_react2.useEffect)(() => {
    if (!client) return;
    addEvent({
      event: "initialized",
      message: `RTVI Client initialized (version ${client.version})`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  }, [addEvent, client]);
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotConnected, (participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotConnected,
      message: `Bot connected: ${participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotDisconnected, (participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotDisconnected,
      message: `Bot disconnected: ${participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotReady, (botData) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotReady,
      message: `Bot ready (v${botData.version}): ${JSON.stringify(botData.about ?? {})}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotStartedSpeaking, () => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotStartedSpeaking,
      message: "Bot started speaking",
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotStoppedSpeaking, () => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.BotStoppedSpeaking,
      message: "Bot stopped speaking",
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.Connected, () => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.Connected,
      message: "Client connected",
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.Disconnected, () => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.Disconnected,
      message: "Client disconnected",
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.Error, (message) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.Error,
      message: `Error: ${JSON.stringify(message)}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.ParticipantConnected, (participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.ParticipantConnected,
      message: `Participant connected: ${participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.ParticipantLeft, (participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.ParticipantLeft,
      message: `Participant left: ${participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.ServerMessage, (data) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.ServerMessage,
      message: `Server message: ${JSON.stringify(data)}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.TrackStarted, (track2, participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.TrackStarted,
      message: `Track started: ${track2.kind} for participant ${participant == null ? void 0 : participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.TrackStopped, (track2, participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.TrackStopped,
      message: `Track stopped: ${track2.kind} for participant ${participant == null ? void 0 : participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.ScreenTrackStarted, (track2, participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.ScreenTrackStarted,
      message: `Screen track started: ${track2.kind} for participant ${participant == null ? void 0 : participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.ScreenTrackStopped, (track2, participant) => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.ScreenTrackStopped,
      message: `Screen track stopped: ${track2.kind} for participant ${participant == null ? void 0 : participant.id}`,
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.UserStartedSpeaking, () => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.UserStartedSpeaking,
      message: "User started speaking",
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  $824ea64b5f757259$export$33a6ac53b8f02625($c1b4da4af54f4fa1$export$6b4624d233c61fcb.UserStoppedSpeaking, () => {
    addEvent({
      event: $c1b4da4af54f4fa1$export$6b4624d233c61fcb.UserStoppedSpeaking,
      message: "User stopped speaking",
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    });
  });
  (0, import_react2.useEffect)(() => {
    if (!scrollRef.current) return;
    if (!isScrolledToBottom.current) return;
    scrollRef.current.scrollTo({
      top: scrollRef.current.scrollHeight,
      behavior: "instant"
    });
  }, [events]);
  const [filter, setFilter] = (0, import_react2.useState)("");
  const filteredEvents = events.filter(
    (eventData) => eventData.event.toString().toLowerCase().includes(filter) || eventData.message.toLowerCase().includes(filter)
  );
  return (0, import_jsx_runtime2.jsxs)(
    Panel$1,
    {
      className: cn(
        "vkui:bg-accent vkui:dark:bg-accent/50 vkui:h-full vkui:rounded-none! vkui:max-sm:border-none vkui:sm:border-x-0 vkui:sm:mt-2",
        {
          "vkui:bg-accent vkui:opacity-50": collapsed
        }
      ),
      children: [
        (0, import_jsx_runtime2.jsxs)(
          PanelHeader,
          {
            className: cn(
              "vkui:gap-4 vkui:justify-start vkui:items-center vkui:@md:py-2 vkui:bg-background",
              {
                "vkui:py-2!": collapsed
              }
            ),
            children: [
              (0, import_jsx_runtime2.jsx)(PanelTitle, { children: "Events" }),
              !collapsed && (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:relative", children: [
                (0, import_jsx_runtime2.jsx)("div", { className: "vkui:absolute vkui:inset-y-0 vkui:left-0 vkui:flex vkui:items-center vkui:pl-2 vkui:pointer-events-none", children: (0, import_jsx_runtime2.jsx)(FunnelIcon, { size: 16 }) }),
                (0, import_jsx_runtime2.jsx)(
                  Input,
                  {
                    type: "text",
                    placeholder: "Filter",
                    className: "vkui:bg-secondary vkui:max-w-48 vkui:ps-8",
                    onChange: (e2) => {
                      setFilter(e2.target.value.toLowerCase());
                    }
                  }
                )
              ] })
            ]
          }
        ),
        !collapsed && (0, import_jsx_runtime2.jsx)(PanelContent, { ref: scrollRef, className: "vkui:overflow-y-auto", children: (0, import_jsx_runtime2.jsx)("div", { className: "vkui:grid vkui:grid-cols-[min-content_min-content_1fr] vkui:gap-x-4 vkui:gap-y-2 vkui:items-center vkui:font-mono vkui:text-xs", children: filteredEvents.map((eventData, index2) => (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [
          (0, import_jsx_runtime2.jsx)("div", { className: "vkui:text-xs vkui:text-muted-foreground vkui:text-nowrap", children: eventData.time }),
          (0, import_jsx_runtime2.jsx)("div", { className: "vkui:font-semibold", children: eventData.event }),
          (0, import_jsx_runtime2.jsx)("div", { children: eventData.message })
        ] }, index2)) }) })
      ]
    }
  );
};
var InfoPanel = ({
  noAudioOutput = false,
  noSessionInfo = false,
  noStatusInfo = false,
  noUserAudio = false,
  noUserVideo = false,
  participantId,
  sessionId
}) => {
  const noDevices = noAudioOutput && noUserAudio && noUserVideo;
  const noInfoPanel = noStatusInfo && noDevices && noSessionInfo;
  if (noInfoPanel) return null;
  return (0, import_jsx_runtime2.jsxs)(Panel$1, { className: "vkui:h-full vkui:overflow-y-auto vkui:overflow-x-hidden", children: [
    !noStatusInfo && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(PanelHeader, { variant: "inline", children: (0, import_jsx_runtime2.jsx)(PanelTitle, { children: "Status" }) }),
      (0, import_jsx_runtime2.jsx)(PanelContent, { children: (0, import_jsx_runtime2.jsx)(ClientStatus, {}) })
    ] }),
    !noDevices && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        PanelHeader,
        {
          className: "vkui:border-t vkui:border-t-border",
          variant: "inline",
          children: (0, import_jsx_runtime2.jsx)(PanelTitle, { children: "Devices" })
        }
      ),
      (0, import_jsx_runtime2.jsxs)(PanelContent, { children: [
        !noUserAudio && (0, import_jsx_runtime2.jsx)(UserAudioControl, {}),
        !noUserVideo && (0, import_jsx_runtime2.jsx)(UserVideoControl, {}),
        !noAudioOutput && (0, import_jsx_runtime2.jsx)(AudioOutput, {})
      ] })
    ] }),
    !noSessionInfo && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        PanelHeader,
        {
          className: "vkui:border-t vkui:border-t-border",
          variant: "inline",
          children: (0, import_jsx_runtime2.jsx)(PanelTitle, { children: "Session" })
        }
      ),
      (0, import_jsx_runtime2.jsx)(PanelContent, { children: (0, import_jsx_runtime2.jsx)(SessionInfo, { sessionId, participantId }) })
    ] })
  ] });
};
var useTheme = () => {
  const context = (0, import_react2.useContext)(ThemeProviderContext);
  if (context === void 0)
    throw new Error("useTheme must be used within a ThemeProvider");
  return context;
};
function ThemeModeToggle() {
  const { setTheme } = useTheme();
  return (0, import_jsx_runtime2.jsxs)(DropdownMenu, { children: [
    (0, import_jsx_runtime2.jsx)(DropdownMenuTrigger, { asChild: true, children: (0, import_jsx_runtime2.jsxs)(Button, { variant: "ghost", isIcon: true, children: [
      (0, import_jsx_runtime2.jsx)(SunIcon, { className: "vkui:h-[1.2rem] vkui:w-[1.2rem] vkui:scale-100 vkui:rotate-0 vkui:transition-all vkui:dark:scale-0 vkui:dark:-rotate-90" }),
      (0, import_jsx_runtime2.jsx)(MoonIcon, { className: "vkui:absolute vkui:h-[1.2rem] vkui:w-[1.2rem] vkui:scale-0 vkui:rotate-90 vkui:transition-all vkui:dark:scale-100 vkui:dark:rotate-0" }),
      (0, import_jsx_runtime2.jsx)("span", { className: "vkui:sr-only", children: "Toggle theme" })
    ] }) }),
    (0, import_jsx_runtime2.jsxs)(DropdownMenuContent, { align: "end", children: [
      (0, import_jsx_runtime2.jsx)(DropdownMenuItem, { onClick: () => setTheme("light"), children: "Light" }),
      (0, import_jsx_runtime2.jsx)(DropdownMenuItem, { onClick: () => setTheme("dark"), children: "Dark" }),
      (0, import_jsx_runtime2.jsx)(DropdownMenuItem, { onClick: () => setTheme("system"), children: "System" })
    ] })
  ] });
}
var BannerContext = (0, import_react2.createContext)({
  show: true,
  setShow: () => {
  }
});
var Banner = ({
  children,
  visible,
  defaultVisible = true,
  variant = "default",
  onClose,
  className,
  inset = false,
  ...props2
}) => {
  const [show, setShow] = useControllableState({
    defaultProp: defaultVisible,
    prop: visible,
    onChange: onClose
  });
  if (!show) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(BannerContext.Provider, { value: { show, setShow }, children: (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: cn(
        "vkui:flex vkui:w-full vkui:font-semibold vkui:items-center vkui:justify-between vkui:gap-2 vkui:bg-primary vkui:px-2 vkui:py-1 vkui:text-primary-foreground",
        inset && "vkui:rounded-lg",
        variant === "destructive" && "vkui:bg-destructive vkui:text-white",
        className
      ),
      ...props2,
      children
    }
  ) });
};
var BannerIcon = ({
  icon: Icon2,
  className,
  ...props2
}) => (0, import_jsx_runtime2.jsx)(
  "div",
  {
    className: cn(
      "vkui:rounded-full vkui:bg-foreground/10 vkui:dark:bg-foreground/30 vkui:p-1",
      className
    ),
    ...props2,
    children: (0, import_jsx_runtime2.jsx)(Icon2, { size: 16 })
  }
);
var BannerTitle = ({ className, ...props2 }) => (0, import_jsx_runtime2.jsx)("p", { className: cn("vkui:flex-1 vkui:text-sm", className), ...props2 });
var BannerClose = ({
  variant = "ghost",
  size: size2 = "icon",
  onClick,
  className,
  ...props2
}) => {
  const { setShow } = (0, import_react2.useContext)(BannerContext);
  const handleClick = (e2) => {
    setShow(false);
    onClick == null ? void 0 : onClick(e2);
  };
  return (0, import_jsx_runtime2.jsx)(
    Button,
    {
      className: cn(
        "vkui:shrink-0 vkui:bg-transparent vkui:hover:bg-background/10 vkui:hover:text-background",
        className
      ),
      onClick: handleClick,
      size: size2,
      variant,
      ...props2,
      children: (0, import_jsx_runtime2.jsx)(X2, { size: 18 })
    }
  );
};
var defaultClientOptions = {};
var defaultTransportOptions = {};
var ConsoleTemplate = ({
  audioCodec = "default",
  clientOptions = defaultClientOptions,
  transportOptions = defaultTransportOptions,
  connectParams,
  noAudioOutput = false,
  noBotAudio = false,
  noBotVideo = false,
  noConversation = false,
  noLogo = false,
  noMetrics = false,
  noSessionInfo = false,
  noStatusInfo = false,
  noThemeSwitch = false,
  noUserAudio = false,
  noUserVideo = false,
  title = "Pipecat Playground",
  transportType = "daily",
  videoCodec = "default",
  collapseInfoPanel = false,
  logoComponent
}) => {
  const [isBotAreaCollapsed, setIsBotAreaCollapsed] = (0, import_react2.useState)(false);
  const [isInfoPanelCollapsed, setIsInfoPanelCollapsed] = (0, import_react2.useState)(false);
  const [isEventsPanelCollapsed, setIsEventsPanelCollapsed] = (0, import_react2.useState)(false);
  const [sessionId, setSessionId] = (0, import_react2.useState)("");
  const [participantId, setParticipantId] = (0, import_react2.useState)("");
  const [client, setClient] = (0, import_react2.useState)(null);
  const [isClientReady, setIsClientReady] = (0, import_react2.useState)(false);
  const [error, setError] = (0, import_react2.useState)(null);
  const infoPanelRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(
    function initClient() {
      if (typeof window === "undefined") return;
      let transport;
      switch (transportType) {
        case "smallwebrtc":
          transport = new $b31644dc78dca54a$export$62043589d053a879(
            transportOptions
          );
          break;
        case "daily":
        default:
          transport = new $683f111f61e07358$export$b1ca982aa1e488c1(
            transportOptions
          );
          transport.dailyCallClient.on("meeting-session-updated", (event) => {
            setSessionId(event.meetingSession.id);
          });
          break;
      }
      const pcClient = new $364c127d152b1085$export$8f7f86a77535f7a3({
        enableCam: !noUserVideo,
        enableMic: !noUserAudio,
        ...clientOptions,
        transport: (clientOptions == null ? void 0 : clientOptions.transport) ?? transport,
        callbacks: {
          onParticipantJoined: (participant) => {
            var _a3, _b;
            setParticipantId(participant.id || "");
            (_b = (_a3 = clientOptions == null ? void 0 : clientOptions.callbacks) == null ? void 0 : _a3.onParticipantJoined) == null ? void 0 : _b.call(_a3, participant);
          },
          onTrackStarted(track2, participant) {
            var _a3, _b;
            if ((participant == null ? void 0 : participant.id) && participant.local)
              setParticipantId(participant.id);
            (_b = (_a3 = clientOptions == null ? void 0 : clientOptions.callbacks) == null ? void 0 : _a3.onTrackStarted) == null ? void 0 : _b.call(_a3, track2, participant);
          }
        }
      });
      pcClient.initDevices();
      setClient(pcClient);
      setIsClientReady(true);
      return () => {
        pcClient.disconnect();
      };
    },
    [clientOptions, transportOptions, noUserAudio, noUserVideo, transportType]
  );
  (0, import_react2.useEffect)(
    function updateSmallWebRTCCodecs() {
      if (!client || transportType !== "smallwebrtc") return;
      const transport = client.transport;
      if (audioCodec) {
        transport.setAudioCodec(audioCodec);
      }
      if (videoCodec) {
        transport.setVideoCodec(videoCodec);
      }
    },
    [audioCodec, client, videoCodec, transportType]
  );
  const handleConnect = async () => {
    if (!client) return;
    setError(null);
    try {
      await client.connect(connectParams);
    } catch (error2) {
      setError(error2 instanceof Error ? error2.message : "Unknown error");
      await client.disconnect();
    }
  };
  const handleDisconnect = async () => {
    if (!client) return;
    setError(null);
    await client.disconnect();
  };
  if (!isClientReady || !client) {
    return (0, import_jsx_runtime2.jsx)("div", { className: "vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:w-full", children: (0, import_jsx_runtime2.jsx)(LoaderSpinner, {}) });
  }
  const noBotArea = noBotAudio && noBotVideo;
  const noConversationPanel = noConversation && noMetrics;
  const noDevices = noAudioOutput && noUserAudio && noUserVideo;
  const noInfoPanel = noStatusInfo && noDevices && noSessionInfo;
  return (0, import_jsx_runtime2.jsxs)($d2e362c5a07ee3c5$export$bb43666ced7a20d0, { client, children: [
    error && (0, import_jsx_runtime2.jsxs)(
      Banner,
      {
        variant: "destructive",
        className: "vkui:animate-in vkui:fade-in vkui:duration-300",
        children: [
          (0, import_jsx_runtime2.jsx)(BannerIcon, { icon: CircleAlertIcon }),
          (0, import_jsx_runtime2.jsx)(BannerTitle, { children: "Unable to connect. Please check web console for errors." }),
          (0, import_jsx_runtime2.jsx)(BannerClose, { variant: "destructive" })
        ]
      }
    ),
    (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:grid vkui:grid-cols-1 vkui:grid-rows-[min-content_1fr] vkui:sm:grid-rows-[min-content_1fr_auto] vkui:h-full vkui:w-full vkui:overflow-auto", children: [
      (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:grid vkui:grid-cols-2 vkui:sm:grid-cols-[150px_1fr_150px] vkui:gap-2 vkui:items-center vkui:justify-center vkui:p-2 vkui:bg-background vkui:sm:relative vkui:top-0 vkui:w-full vkui:z-10", children: [
        noLogo ? (0, import_jsx_runtime2.jsx)("span", { className: "vkui:h-6" }) : logoComponent ?? (0, import_jsx_runtime2.jsx)(PipecatLogo, { className: "vkui:h-6 vkui:w-auto vkui:text-foreground" }),
        (0, import_jsx_runtime2.jsx)("strong", { className: "vkui:hidden vkui:sm:block vkui:text-center", children: title }),
        (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:flex vkui:items-center vkui:justify-end vkui:gap-2 vkui:sm:gap-3 vkui:xl:gap-6", children: [
          (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:flex vkui:items-center vkui:gap-1", children: [
            !noThemeSwitch && (0, import_jsx_runtime2.jsx)(ThemeModeToggle, {}),
            (0, import_jsx_runtime2.jsx)(
              Button,
              {
                className: "vkui:hidden vkui:sm:flex",
                variant: "ghost",
                isIcon: true,
                onClick: () => {
                  var _a3, _b;
                  if (isInfoPanelCollapsed) {
                    (_a3 = infoPanelRef.current) == null ? void 0 : _a3.expand();
                  } else {
                    (_b = infoPanelRef.current) == null ? void 0 : _b.collapse();
                  }
                },
                children: isInfoPanelCollapsed ? (0, import_jsx_runtime2.jsx)(PanelLeftCloseIcon, {}) : (0, import_jsx_runtime2.jsx)(PanelRightCloseIcon, {})
              }
            )
          ] }),
          (0, import_jsx_runtime2.jsx)(
            ConnectButton,
            {
              onConnect: handleConnect,
              onDisconnect: handleDisconnect
            }
          )
        ] })
      ] }),
      (0, import_jsx_runtime2.jsx)("div", { className: "vkui:hidden vkui:sm:block", children: (0, import_jsx_runtime2.jsxs)(ResizablePanelGroup, { direction: "vertical", className: "vkui:h-full", children: [
        (0, import_jsx_runtime2.jsx)(ResizablePanel, { defaultSize: 70, minSize: 50, children: (0, import_jsx_runtime2.jsxs)(ResizablePanelGroup, { direction: "horizontal", children: [
          !noBotArea && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
            (0, import_jsx_runtime2.jsxs)(
              ResizablePanel,
              {
                className: "vkui:flex vkui:flex-col vkui:gap-2 vkui:p-2 vkui:xl:gap-4",
                defaultSize: 26,
                maxSize: 30,
                minSize: 10,
                collapsible: true,
                collapsedSize: 8,
                onCollapse: () => setIsBotAreaCollapsed(true),
                onExpand: () => setIsBotAreaCollapsed(false),
                children: [
                  !noBotAudio && (0, import_jsx_runtime2.jsx)(
                    BotAudioPanel,
                    {
                      className: cn({
                        "vkui:mb-auto": noBotVideo
                      }),
                      collapsed: isBotAreaCollapsed
                    }
                  ),
                  !noBotVideo && (0, import_jsx_runtime2.jsx)(
                    BotVideoPanel,
                    {
                      className: cn({
                        "vkui:mt-auto": noBotAudio
                      }),
                      collapsed: isBotAreaCollapsed
                    }
                  )
                ]
              }
            ),
            (!noConversationPanel || !noInfoPanel) && (0, import_jsx_runtime2.jsx)(ResizableHandle, { withHandle: true })
          ] }),
          !noConversationPanel && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
            (0, import_jsx_runtime2.jsx)(
              ResizablePanel,
              {
                className: "vkui:h-full vkui:p-2",
                defaultSize: collapseInfoPanel ? 70 : 47,
                minSize: 30,
                children: (0, import_jsx_runtime2.jsx)(
                  ConversationPanel,
                  {
                    noConversation,
                    noMetrics
                  }
                )
              }
            ),
            !noInfoPanel && (0, import_jsx_runtime2.jsx)(ResizableHandle, { withHandle: true })
          ] }),
          !noInfoPanel && (0, import_jsx_runtime2.jsx)(
            ResizablePanel,
            {
              id: "info-panel",
              ref: infoPanelRef,
              collapsible: true,
              collapsedSize: 4,
              defaultSize: collapseInfoPanel ? 4 : 27,
              minSize: 15,
              onCollapse: () => setIsInfoPanelCollapsed(true),
              onExpand: () => setIsInfoPanelCollapsed(false),
              className: "vkui:p-2",
              children: isInfoPanelCollapsed ? (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:flex vkui:flex-col vkui:items-center vkui:justify-center vkui:gap-4 vkui:h-full", children: [
                !noStatusInfo && (0, import_jsx_runtime2.jsxs)(Popover, { children: [
                  (0, import_jsx_runtime2.jsx)(PopoverTrigger, { asChild: true, children: (0, import_jsx_runtime2.jsx)(Button, { variant: "ghost", size: "icon", children: (0, import_jsx_runtime2.jsx)(ChevronsLeftRightEllipsisIcon, { size: 16 }) }) }),
                  (0, import_jsx_runtime2.jsx)(PopoverContent, { side: "left", children: (0, import_jsx_runtime2.jsx)(ClientStatus, {}) })
                ] }),
                !noDevices && (0, import_jsx_runtime2.jsxs)(Popover, { children: [
                  (0, import_jsx_runtime2.jsx)(PopoverTrigger, { asChild: true, children: (0, import_jsx_runtime2.jsx)(Button, { variant: "ghost", size: "icon", children: (0, import_jsx_runtime2.jsx)(MicIcon, { size: 16 }) }) }),
                  (0, import_jsx_runtime2.jsxs)(
                    PopoverContent,
                    {
                      className: "vkui:flex vkui:flex-col vkui:gap-2",
                      side: "left",
                      children: [
                        !noUserAudio && (0, import_jsx_runtime2.jsx)(UserAudioControl, {}),
                        !noUserVideo && (0, import_jsx_runtime2.jsx)(UserVideoControl, {}),
                        !noAudioOutput && (0, import_jsx_runtime2.jsx)(AudioOutput, {})
                      ]
                    }
                  )
                ] }),
                !noSessionInfo && (0, import_jsx_runtime2.jsxs)(Popover, { children: [
                  (0, import_jsx_runtime2.jsx)(PopoverTrigger, { asChild: true, children: (0, import_jsx_runtime2.jsx)(Button, { variant: "ghost", size: "icon", children: (0, import_jsx_runtime2.jsx)(InfoIcon, { size: 16 }) }) }),
                  (0, import_jsx_runtime2.jsx)(PopoverContent, { side: "left", children: (0, import_jsx_runtime2.jsx)(
                    SessionInfo,
                    {
                      sessionId,
                      participantId
                    }
                  ) })
                ] })
              ] }) : (0, import_jsx_runtime2.jsx)(
                InfoPanel,
                {
                  noAudioOutput,
                  noSessionInfo,
                  noStatusInfo,
                  noUserAudio,
                  noUserVideo,
                  participantId,
                  sessionId
                }
              )
            }
          )
        ] }) }),
        (0, import_jsx_runtime2.jsx)(ResizableHandle, { withHandle: true }),
        (0, import_jsx_runtime2.jsx)(
          ResizablePanel,
          {
            collapsible: true,
            collapsedSize: 4,
            minSize: 7,
            onCollapse: () => setIsEventsPanelCollapsed(true),
            onExpand: () => setIsEventsPanelCollapsed(false),
            children: (0, import_jsx_runtime2.jsx)(EventsPanel, { collapsed: isEventsPanelCollapsed })
          }
        )
      ] }) }),
      (0, import_jsx_runtime2.jsxs)(
        Tabs,
        {
          defaultValue: noBotArea ? noConversationPanel ? "info" : "conversation" : "bot",
          className: "vkui:flex vkui:flex-col vkui:gap-0 vkui:sm:hidden vkui:overflow-hidden",
          children: [
            (0, import_jsx_runtime2.jsxs)("div", { className: "vkui:flex vkui:flex-col vkui:overflow-hidden vkui:flex-1", children: [
              !noBotArea && (0, import_jsx_runtime2.jsxs)(
                TabsContent,
                {
                  value: "bot",
                  className: "vkui:flex-1 vkui:overflow-auto vkui:flex vkui:flex-col vkui:gap-4 vkui:p-2",
                  children: [
                    !noBotAudio && (0, import_jsx_runtime2.jsx)(BotAudioPanel, {}),
                    !noBotVideo && (0, import_jsx_runtime2.jsx)(BotVideoPanel, {})
                  ]
                }
              ),
              !noConversationPanel && (0, import_jsx_runtime2.jsx)(
                TabsContent,
                {
                  value: "conversation",
                  className: "vkui:flex-1 vkui:overflow-auto",
                  children: (0, import_jsx_runtime2.jsx)(
                    ConversationPanel,
                    {
                      noConversation,
                      noMetrics
                    }
                  )
                }
              ),
              (0, import_jsx_runtime2.jsx)(
                TabsContent,
                {
                  value: "info",
                  className: "vkui:flex-1 vkui:overflow-auto vkui:p-2",
                  children: (0, import_jsx_runtime2.jsx)(
                    InfoPanel,
                    {
                      noAudioOutput,
                      noUserAudio,
                      noUserVideo,
                      participantId,
                      sessionId
                    }
                  )
                }
              ),
              (0, import_jsx_runtime2.jsx)(
                TabsContent,
                {
                  value: "events",
                  className: "vkui:flex-1 vkui:overflow-auto",
                  children: (0, import_jsx_runtime2.jsx)(EventsPanel, {})
                }
              )
            ] }),
            (0, import_jsx_runtime2.jsxs)(TabsList, { className: "vkui:w-full vkui:h-12 vkui:rounded-none vkui:z-10 vkui:mt-auto vkui:shrink-0", children: [
              !noBotArea && (0, import_jsx_runtime2.jsx)(TabsTrigger, { value: "bot", children: (0, import_jsx_runtime2.jsx)(BotIcon, {}) }),
              !noConversationPanel && (0, import_jsx_runtime2.jsx)(TabsTrigger, { value: "conversation", children: (0, import_jsx_runtime2.jsx)(MessagesSquareIcon, {}) }),
              (0, import_jsx_runtime2.jsx)(TabsTrigger, { value: "info", children: (0, import_jsx_runtime2.jsx)(InfoIcon, {}) }),
              (0, import_jsx_runtime2.jsx)(TabsTrigger, { value: "events", children: (0, import_jsx_runtime2.jsx)(ChevronsLeftRightEllipsisIcon, {}) })
            ] })
          ]
        }
      ),
      !noAudioOutput && (0, import_jsx_runtime2.jsx)($f209aa7ddb77dcb2$export$b52250cb73ff4de1, {})
    ] })
  ] });
};
export {
  ArrowDownIcon,
  AudioClientHelper,
  AudioOutput,
  BotAudioPanel,
  BotIcon,
  BotVideoPanel,
  Button,
  ButtonGroup,
  Card,
  CardAction,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
  CheckIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  ChevronUpIcon,
  ChevronsLeftRightEllipsisIcon,
  CircleAlertIcon,
  CircleIcon,
  ClientStatus,
  ClientStatusComponent,
  ConnectButton,
  ConnectButtonComponent,
  ConsoleTemplate,
  ControlBar,
  ControlBarDivider,
  Conversation,
  ConversationPanel,
  CopyText,
  DataList,
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
  EllipsisIcon,
  EllipsisVerticalIcon,
  ErrorCard,
  EventsPanel,
  FullScreenContainer,
  FunnelIcon,
  InfoIcon,
  InfoPanel,
  Input,
  LayoutSection,
  LineChartIcon,
  LoaderIcon,
  LoaderSpinner,
  LogoutIcon,
  MessagesSquareIcon,
  MicIcon,
  MicOffIcon,
  MoonIcon,
  Panel$1 as Panel,
  PanelActions,
  PanelContent,
  PanelFooter,
  PanelHeader,
  PanelLeftCloseIcon,
  PanelRightCloseIcon,
  PanelTitle,
  PhoneCallEndIcon,
  PhoneCallIcon,
  PipecatLogo,
  Popover,
  PopoverAnchor,
  PopoverContent,
  PopoverTrigger,
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
  reactResizablePanels_browser as ResizablePrimitive,
  Select,
  SelectChevronIcon,
  SelectContent,
  SelectGroup,
  SelectGuide,
  SelectItem,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
  SendIcon,
  SessionInfo,
  SunIcon,
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
  TextDashBlankslate,
  ThemeModeToggle,
  ThemeProvider,
  Thinking,
  Tooltip2 as Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
  TranscriptOverlay,
  TranscriptOverlayComponent,
  TranscriptOverlayPartComponent,
  UserAudioComponent,
  UserAudioControl,
  UserVideoComponent,
  UserVideoControl,
  VideoIcon,
  VideoOffIcon,
  VoiceVisualizer,
  VolumeIcon,
  VolumeOffIcon,
  XIcon,
  useConversation
};
/*! Bundled license information:

@pipecat-ai/voice-ui-kit/dist/Metrics-B9xaddk1.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)
  (*!
   * Chart.js v4.5.0
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

@daily-co/daily-js/dist/daily-esm.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)

@pipecat-ai/voice-ui-kit/dist/index.mjs:
  (**
   * @license lucide-react v0.511.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@pipecat-ai_voice-ui-kit.js.map
